/*! For license information please see peer.js.LICENSE.txt */
(()=>{var e={18166:(e,t,n)=>{"use strict";n.d(t,{H:()=>s});var r=n(6639);function s(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&r.util.assert("complex64"!==e.dtype,(()=>t+" does not support complex64 tensors in the CPU backend."))}))}},27710:(e,t,n)=>{"use strict";n.r(t),n.d(t,{MathBackendCPU:()=>h,shared:()=>p,version_cpu:()=>f});var r=n(6639),s=n(36377),o=n(18166);const a=r.kernel_impls.nonMaxSuppressionV3Impl,i=r.kernel_impls.split,u=r.kernel_impls.tile,l=r.kernel_impls.topkImpl,c=r.kernel_impls.whereImpl;function d(e,t,n,s){if("linear"===n)return e.linear(t);if("relu"===n)return e.relu(t);if("elu"===n)return r.elu(t);if("relu6"===n)return e.relu6(t);if("prelu"===n)return e.prelu(t,s);throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}class h extends r.KernelBackend{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new r.DataStorage(this,(0,r.engine)())}write(e,t,n){this.firstUse&&(this.firstUse=!1,(0,r.env)().get("IS_NODE")&&r.backend_util.warn("\n============================\nHi there ðŸ‘‹. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const s={};return this.data.set(s,{values:e,dtype:n,refCount:1}),s}makeTensorInfo(e,t,n){return{dataId:this.write(n,e,t),shape:e,dtype:t}}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,t,n,r){this.data.set(e,{values:t,dtype:r,refCount:1})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){const e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return r.backend_util.mergeRealAndImagArrays(e,t)}return this.data.get(e).values}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map((e=>r.util.decodeString(e)))}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return r.buffer(e.shape,e.dtype,n)}makeOutput(e,t,n){const s=this.write(e,t,n);return(0,r.engine)().makeTensorFromDataId(s,t,n,this)}disposeData(e){if(this.data.has(e)){const{complexTensorInfos:t}=this.data.get(e);null!=t&&(this.disposeData(t.real.dataId),this.disposeData(t.imag.dataId)),this.data.delete(e)}}disposeIntermediateTensorInfo(e){const t=e.dataId;if(this.data.has(t)){const e=this.data.get(t);e.refCount--,e.refCount<1&&this.disposeData(t)}}async time(e){const t=r.util.now();return e(),{kernelMs:r.util.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}stridedSlice(e,t,n,s){(0,o.H)(e,"stridedSlice");const a=r.slice_util.computeOutShape(t,n,s);if(a.some((e=>0===e)))return r.tensor([],a);const i=r.buffer(a,e.dtype),u=this.bufferSync(e);for(let e=0;e<i.size;e++){const n=i.indexToLoc(e),r=new Array(n.length);for(let e=0;e<r.length;e++)r[e]=n[e]*s[e]+t[e];i.set(u.get(...r),...n)}return i.toTensor()}diag(e){const t=this.readSync(e.dataId),n=r.buffer([e.size,e.size],e.dtype),s=n.values;for(let n=0;n<t.length;n++)s[n*e.size+n]=t[n];return n.toTensor()}unstack(e,t){const n=e.shape[t],s=new Array(e.rank-1);let o=0;for(let n=0;n<e.rank;n++)n!==t&&(s[o++]=e.shape[n]);const a=new Array(e.rank).fill(0),i=e.shape.slice();i[t]=1;const u=new Array(n);for(let n=0;n<u.length;n++)a[t]=n,u[n]=r.slice(e,a,i).reshape(s);return u}reverse(e,t){(0,o.H)(e,"reverse");const n=r.buffer(e.shape,e.dtype),s=this.bufferSync(e);for(let r=0;r<n.size;r++){const o=n.indexToLoc(r),a=o.slice();t.forEach((t=>a[t]=e.shape[t]-1-a[t])),n.set(s.get(...a),...o)}return n.toTensor()}neg(e){return(0,o.H)(e,"neg"),r.mul(r.scalar(-1),e)}addN(e){(0,o.H)(e,"addN");const t=e.map((e=>this.readSync(e.dataId))),n=r.buffer(e[0].shape,e[0].dtype),s=n.values;for(let n=0;n<e.length;n++){const e=t[n];for(let t=0;t<s.length;t++)s[t]+=e[t]}return n.toTensor()}softmax(e,t){const n=r.util.parseAxisParam([t],e.shape),s=(0,r.max)(e,n),o=r.backend_util.expandShapeToKeepDim(s.shape,n),a=r.sub(e,s.reshape(o)),i=r.exp(a),u=this.sum(i,n).reshape(o);return r.div(i,u)}pow(e,t){return(0,o.H)([e,t],"pow"),this.broadcastedBinaryOp(e,t,e.dtype,((e,t)=>Math.pow(e,t)))}batchMatMul(e,t,n,s){(0,o.H)([e,t],"matMul");const a=n?e.shape[1]:e.shape[2],i=n?e.shape[2]:e.shape[1],u=s?t.shape[1]:t.shape[2],l=e.shape[0],c=this.readSync(e.dataId),d=this.readSync(t.dataId),[h,p,f]=n?[e.strides[0],1,e.strides[1]]:[e.strides[0],e.strides[1],1],[m,g,x]=s?[1,t.strides[1],t.strides[0]]:[t.strides[1],1,t.strides[0]],v=i*u,b=r.buffer([l,i,u],e.dtype),y=b.values,w=this.blockSize;for(let e=0;e<l;e++)for(let t=0;t<i;t+=w)for(let n=0;n<u;n+=w)for(let r=0;r<a;r+=w){const s=Math.min(t+w,i),o=Math.min(n+w,u),l=Math.min(r+w,a);for(let a=t;a<s;a++)for(let t=n;t<o;t++){let n=0;for(let s=r;s<l;s++)n+=c[e*h+a*p+s*f]*d[s*m+t*g+e*x];y[e*v+(a*u+t)]+=n}}return b.toTensor()}fusedBatchMatMul({a:e,b:t,transposeA:n,transposeB:s,bias:o,activation:a,preluActivationWeights:i}){let u=this.batchMatMul(e,t,n,s);return o&&(u=r.add(u,o)),a&&(u=d(this,u,a,i)),u}floorDiv(e,t){return(0,o.H)([e,t],"floorDiv"),this.broadcastedBinaryOp(e,t,"int32",((e,t)=>Math.floor(e/t)))}sum(e,t){(0,o.H)(e,"sum"),r.backend_util.assertAxesAreInnerMostDims("sum",t,e.rank);const[n,s]=r.backend_util.computeOutAndReduceShapes(e.shape,t),a=(0,r.upcastType)(e.dtype,"int32"),i=r.zeros(n,a),u=r.util.sizeFromShape(s),l=this.readSync(i.dataId),c=this.readSync(e.dataId);for(let e=0;e<l.length;++e){const t=e*u;let n=0;for(let e=0;e<u;++e)n+=c[t+e];l[e]=n}return i}prod(e,t){(0,o.H)(e,"sum");const[n,s]=r.backend_util.computeOutAndReduceShapes(e.shape,t),a=(0,r.upcastType)(e.dtype,"int32"),i=r.zeros(n,a),u=r.util.sizeFromShape(s),l=this.readSync(i.dataId),c=this.readSync(e.dataId);for(let e=0;e<l.length;++e){const t=e*u;let n=1;for(let e=0;e<u;++e)n*=c[t+e];l[e]=n}return i}unsortedSegmentSum(e,t,n){(0,o.H)(e,"unsortedSegmentSum");const s=[],a=e.rank-t.rank;for(let e=0;e<a;++e)t=t.expandDims(e+1);for(let o=0;o<n;++o){const n=r.scalar(o,"int32"),a=r.equal(n,t).asType("float32").mul(e).sum(0);s.push(a)}return r.stack(s)}argMin(e,t){(0,o.H)(e,"argMin");const n=[t];r.backend_util.assertAxesAreInnerMostDims("argMin",n,e.rank);const[s,a]=r.backend_util.computeOutAndReduceShapes(e.shape,n),i=r.zeros(s,"int32"),u=r.util.sizeFromShape(a),l=this.readSync(i.dataId),c=this.readSync(e.dataId);for(let e=0;e<l.length;++e){const t=e*u;let n=c[t],r=0;for(let e=0;e<u;++e){const s=c[t+e];s<n&&(n=s,r=e)}l[e]=r}return i}argMax(e,t){(0,o.H)(e,"argMax");const n=[t];r.backend_util.assertAxesAreInnerMostDims("argMax",n,e.rank);const[s,a]=r.backend_util.computeOutAndReduceShapes(e.shape,n),i=r.zeros(s,"int32"),u=r.util.sizeFromShape(a),l=this.readSync(i.dataId),c=this.readSync(e.dataId);for(let e=0;e<l.length;++e){const t=e*u;let n=c[t],r=0;for(let e=0;e<u;++e){const s=c[t+e];s>n&&(n=s,r=e)}l[e]=r}return i}cumsum(e,t,n,s){if((0,o.H)(e,"cumsum"),t!==e.rank-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${e.rank-1} but got axis=`+t);const a=(0,r.upcastType)(e.dtype,"int32"),i=r.zeros(e.shape,a),u=this.readSync(i.dataId),l=this.readSync(e.dataId),c=e.shape[e.rank-1],d=s?(e,t)=>e+c-t-1:(e,t)=>e+t;for(let e=0;e<l.length;e+=c)for(let t=0;t<c;t++){const r=d(e,t);if(0===t)u[r]=n?0:l[r];else{const s=d(e,t-1);u[r]=n?l[s]+u[s]:l[r]+u[s]}}return i}equal(e,t){return(0,o.H)([e,t],"equal"),this.broadcastedBinaryOp(e,t,"bool",((e,t)=>e===t?1:0))}notEqual(e,t){return(0,o.H)([e,t],"notEqual"),this.broadcastedBinaryOp(e,t,"bool",((e,t)=>e!==t?1:0))}less(e,t){return(0,o.H)([e,t],"less"),this.broadcastedBinaryOp(e,t,"bool",((e,t)=>e<t?1:0))}lessEqual(e,t){return(0,o.H)([e,t],"lessEqual"),this.broadcastedBinaryOp(e,t,"bool",((e,t)=>e<=t?1:0))}greater(e,t){return(0,o.H)([e,t],"greater"),this.broadcastedBinaryOp(e,t,"bool",((e,t)=>e>t?1:0))}greaterEqual(e,t){return(0,o.H)([e,t],"greaterEqual"),this.broadcastedBinaryOp(e,t,"bool",((e,t)=>e>=t?1:0))}logicalAnd(e,t){return(0,o.H)([e,t],"logicalAnd"),this.broadcastedBinaryOp(e,t,"bool",((e,t)=>e&&t))}logicalOr(e,t){return(0,o.H)([e,t],"logicalOr"),this.broadcastedBinaryOp(e,t,"bool",((e,t)=>e||t))}select(e,t,n){(0,o.H)([e,t,n],"select");const s=this.readSync(e.dataId),a=this.readSync(t.dataId),i=this.readSync(n.dataId),u=r.zeros(t.shape,(0,r.upcastType)(t.dtype,n.dtype)),l=this.readSync(u.dataId);let c=0;const d=0===e.rank||e.rank>1||1===t.rank?1:r.util.sizeFromShape(t.shape.slice(1));for(let e=0;e<s.length;e++)for(let t=0;t<d;t++)1===s[e]?l[c++]=a[e]:l[c++]=i[e];return u}where(e){(0,o.H)([e],"where");const t=this.readSync(e.dataId);return c(e.shape,t)}topk(e,t,n){(0,o.H)(e,"topk");const r=this.readSync(e.dataId);return l(r,e.shape,e.dtype,t,n)}min(e,t){(0,o.H)(e,"min"),r.backend_util.assertAxesAreInnerMostDims("min",t,e.rank);const[n,s]=r.backend_util.computeOutAndReduceShapes(e.shape,t),a=r.zeros(n,e.dtype),i=r.util.sizeFromShape(s),u=this.readSync(a.dataId),l=this.readSync(e.dataId);for(let e=0;e<u.length;++e){const t=e*i;let n=l[t];for(let e=0;e<i;++e){const r=l[t+e];r<n&&(n=r)}u[e]=n}return a}minimum(e,t){return(0,o.H)([e,t],"minimum"),this.broadcastedBinaryOp(e,t,e.dtype,((e,t)=>Math.min(e,t)))}mod(e,t){return(0,o.H)([e,t],"mod"),this.broadcastedBinaryOp(e,t,e.dtype,((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}))}maximum(e,t){return(0,o.H)([e,t],"maximum"),this.broadcastedBinaryOp(e,t,e.dtype,((e,t)=>Math.max(e,t)))}all(e,t){(0,o.H)(e,"all"),r.backend_util.assertAxesAreInnerMostDims("all",t,e.rank);const[n,s]=r.backend_util.computeOutAndReduceShapes(e.shape,t),a=r.zeros(n,e.dtype),i=r.util.sizeFromShape(s),u=this.readSync(a.dataId),l=this.readSync(e.dataId);for(let e=0;e<u.length;++e){const t=e*i;let n=l[t];for(let e=0;e<i;++e){const r=l[t+e];n=n&&r}u[e]=n}return a}any(e,t){(0,o.H)(e,"any"),r.backend_util.assertAxesAreInnerMostDims("any",t,e.rank);const[n,s]=r.backend_util.computeOutAndReduceShapes(e.shape,t),a=r.zeros(n,e.dtype),i=r.util.sizeFromShape(s),u=this.readSync(a.dataId),l=this.readSync(e.dataId);for(let e=0;e<u.length;++e){const t=e*i;let n=l[t];for(let e=0;e<i;++e){const r=l[t+e];n=n||r}u[e]=n}return a}squaredDifference(e,t){return(0,o.H)([e,t],"squaredDifference"),this.broadcastedBinaryOp(e,t,e.dtype,((e,t)=>{const n=e-t;return n*n}))}linear(e){return e}relu(e){(0,o.H)(e,"relu");const t=r.zeros(e.shape,e.dtype),n=this.readSync(t.dataId),s=this.readSync(e.dataId);for(let e=0;e<s.length;++e)n[e]=Math.max(0,s[e]);return t}relu6(e){(0,o.H)(e,"relu");const t=r.zeros(e.shape,e.dtype),n=this.readSync(t.dataId),s=this.readSync(e.dataId);for(let e=0;e<s.length;++e)n[e]=Math.min(Math.max(0,s[e]),6);return t}prelu(e,t){return(0,o.H)([e,t],"prelu"),this.broadcastedBinaryOp(e,t,e.dtype,((e,t)=>e<0?t*e:e))}eluDer(e,t){(0,o.H)([e,t],"eluDer");const n=new Float32Array(t.size),r=this.readSync(t.dataId),s=this.readSync(e.dataId);for(let e=0;e<r.length;++e){const t=r[e];n[e]=t>=1?s[e]:s[e]*(t+1)}return this.makeOutput(n,t.shape,"float32")}atan2(e,t){return(0,o.H)([e,t],"atan2"),this.broadcastedBinaryOp(e,t,e.dtype,((e,t)=>Math.atan2(e,t)))}fusedConv2d({input:e,filter:t,convInfo:n,bias:s,activation:o,preluActivationWeights:a}){let i=this.conv2d(e,t,n);return s&&(i=r.add(i,s)),o&&(i=d(this,i,o,a)),i}conv2d(e,t,n){(0,o.H)([e,t],"conv2d");const s=n.filterHeight,a=n.filterWidth,i=n.dilationHeight,u=n.dilationWidth,l=n.padInfo.left,c=n.padInfo.top,d="channelsLast"===n.dataFormat,h=r.buffer(n.outShape,e.dtype),p=e.strides[0],f=d?e.strides[1]:e.strides[2],m=d?e.strides[2]:1,g=d?1:e.strides[1],x=h.strides[0],v=d?h.strides[1]:h.strides[2],b=d?h.strides[2]:1,y=d?1:h.strides[1],w=this.readSync(e.dataId),k=this.readSync(t.dataId),I=h.values;for(let e=0;e<n.batchSize;++e){const r=e*p,o=e*x;for(let e=0;e<n.outHeight;++e){const d=o+e*v,h=e*n.strideHeight-c;for(let e=0;e<s;e++){const s=h+e*i;if(s<0||s>=n.inHeight)continue;const o=e*t.strides[0],c=r+s*f;for(let e=0;e<n.outWidth;++e){const r=d+e*b,s=e*n.strideWidth-l;for(let e=0;e<a;e++){const a=s+e*u;if(a<0||a>=n.inWidth)continue;const i=c+a*m;let l=o+e*t.strides[1];for(let e=0;e<n.inChannels;++e){const t=w[i+e*g];for(let e=0;e<n.outChannels;++e)I[r+e*y]+=t*k[l+e];l+=n.outChannels}}}}}}return h.toTensor()}conv3d(e,t,n){const s=n.filterDepth,o=n.filterHeight,a=n.filterWidth,i=n.dilationDepth,u=n.dilationHeight,l=n.dilationWidth,c=n.padInfo.front,d=n.padInfo.left,h=n.padInfo.top,p=r.buffer(n.outShape,e.dtype),f=this.readSync(e.dataId),m=this.readSync(t.dataId),g=p.values;for(let r=0;r<n.batchSize;++r){const x=r*e.strides[0],v=r*p.strides[0];for(let r=0;r<n.outDepth;++r){const b=v+r*p.strides[1],y=r*n.strideDepth-c;for(let r=0;r<s;r++){const s=y+r*i;if(s<0||s>=n.inDepth)continue;const c=r*t.strides[0],v=x+s*e.strides[1];for(let r=0;r<n.outHeight;++r){const s=b+r*p.strides[2],i=r*n.strideHeight-h;for(let r=0;r<o;r++){const o=i+r*u;if(o<0||o>=n.inHeight)continue;const h=c+r*t.strides[1],p=v+o*e.strides[2];for(let e=0;e<n.outWidth;++e){const r=s+e*n.outChannels,o=e*n.strideWidth-d;for(let e=0;e<a;e++){const s=o+e*l;if(s<0||s>=n.inWidth)continue;const a=h+e*t.strides[2],i=p+s*n.inChannels;let u=a;for(let e=0;e<n.inChannels;++e){const t=f[i+e];for(let e=0;e<n.outChannels;++e)g[r+e]+=t*m[u+e];u+=n.outChannels}}}}}}}}return p.toTensor()}conv2dDerInput(e,t,n){(0,o.H)([e,t],"conv2dDerInput");const s=r.buffer(n.inShape,"float32"),a=s.values,i=this.readSync(e.dataId),u=this.readSync(t.dataId),[l,c,d]=t.strides,{batchSize:h,filterHeight:p,filterWidth:f,inChannels:m,inHeight:g,inWidth:x,outChannels:v,outHeight:b,outWidth:y,strideHeight:w,strideWidth:k,dataFormat:I}=n,C=p-1-n.padInfo.top,$=f-1-n.padInfo.left,S="channelsLast"===I,R=s.strides[0],E=S?s.strides[1]:s.strides[2],T=S?s.strides[2]:1,A=S?1:s.strides[1],_=e.strides[0],N=S?e.strides[1]:e.strides[2],F=S?e.strides[2]:1,D=S?1:e.strides[1];for(let e=0;e<h;++e)for(let t=0;t<m;++t)for(let n=0;n<g;++n){const r=n-C,s=Math.max(0,Math.ceil(r/w)),o=Math.min(b,(p+r)/w);for(let h=0;h<x;++h){const m=h-$,g=Math.max(0,Math.ceil(m/k)),x=Math.min(y,(f+m)/k);let b=0;for(let n=s;n<o;++n){const s=n*w-r;for(let r=g;r<x;++r){const o=_*e+N*n+F*r,a=l*(p-1-s)+c*(f-1-(r*k-m))+d*t;for(let e=0;e<v;++e)b+=i[o+D*e]*u[a+e]}}a[R*e+E*n+T*h+A*t]=b}}return s.toTensor()}conv3dDerInput(e,t,n){const s=r.buffer(n.inShape,"float32"),o=s.values,[a,i,u,l]=s.strides,c=this.readSync(e.dataId),[d,h,p,f]=e.strides,m=this.readSync(t.dataId),[g,x,v,b]=t.strides,{batchSize:y,filterDepth:w,filterHeight:k,filterWidth:I,inChannels:C,inDepth:$,inHeight:S,inWidth:R,outChannels:E,outDepth:T,outHeight:A,outWidth:_,strideDepth:N,strideHeight:F,strideWidth:D}=n,B=w-1-n.padInfo.front,O=k-1-n.padInfo.top,M=I-1-n.padInfo.left;for(let e=0;e<y;++e)for(let t=0;t<C;++t)for(let n=0;n<$;++n){const r=n-B,s=Math.max(0,Math.ceil(r/N)),y=Math.min(T,(w+r)/N);for(let C=0;C<S;++C){const $=C-O,S=Math.max(0,Math.ceil($/F)),T=Math.min(A,(k+$)/F);for(let A=0;A<R;++A){const R=A-M,B=Math.max(0,Math.ceil(R/D)),O=Math.min(_,(I+R)/D);let P=0;for(let n=s;n<y;++n){const s=n*N-r;for(let r=S;r<T;++r){const o=r*F-$;for(let a=B;a<O;++a){const i=d*e+h*n+p*r+f*a,u=g*(w-1-s)+x*(k-1-o)+v*(I-1-(a*D-R))+b*t;for(let e=0;e<E;++e)P+=c[i+e]*m[u+e]}}}o[a*e+i*n+u*C+l*A+t]=P}}}return s.toTensor()}conv2dDerFilter(e,t,n){(0,o.H)([e,t],"conv2dDerFilter");const s=n.strideHeight,a=n.strideWidth,i=n.filterHeight,u=n.filterWidth,l="channelsLast"===n.dataFormat,c=r.buffer(n.filterShape,"float32"),d=n.padInfo.left,h=n.padInfo.top,p=this.bufferSync(e),f=this.bufferSync(t);for(let e=0;e<i;++e){const t=Math.max(0,Math.ceil((h-e)/s)),r=Math.min(n.outHeight,(n.inHeight+h-e)/s);for(let o=0;o<u;++o){const i=Math.max(0,Math.ceil((d-o)/a)),u=Math.min(n.outWidth,(n.inWidth+d-o)/a);for(let m=0;m<n.inChannels;++m)for(let g=0;g<n.outChannels;++g){let x=0;for(let c=0;c<n.batchSize;++c)for(let n=t;n<r;++n){const t=e+n*s-h;for(let e=i;e<u;++e){const r=o+e*a-d;x+=l?p.get(c,t,r,m)*f.get(c,n,e,g):p.get(c,m,t,r)*f.get(c,g,n,e)}}c.set(x,e,o,m,g)}}}return c.toTensor()}conv3dDerFilter(e,t,n){const s=n.strideDepth,o=n.strideHeight,a=n.strideWidth,i=n.filterDepth,u=n.filterHeight,l=n.filterWidth,c=r.buffer(n.filterShape,"float32"),d=c.values,[h,p,f,m]=c.strides,g=this.readSync(t.dataId),[x,v,b,y]=t.strides,w=this.readSync(e.dataId),[k,I,C,$]=e.strides,S=n.padInfo.front,R=n.padInfo.left,E=n.padInfo.top;for(let e=0;e<i;++e){const t=Math.max(0,Math.ceil((S-e)/s)),r=Math.min(n.outDepth,(n.inDepth+S-e)/s),i=e*h;for(let c=0;c<u;++c){const u=Math.max(0,Math.ceil((E-c)/o)),h=Math.min(n.outHeight,(n.inHeight+E-c)/o),T=c*p+i;for(let i=0;i<l;++i){const l=Math.max(0,Math.ceil((R-i)/a)),p=Math.min(n.outWidth,(n.inWidth+R-i)/a),A=i*f+T;for(let f=0;f<n.inChannels;++f){const T=f*m+A;for(let m=0;m<n.outChannels;++m){let A=0;for(let d=0;d<n.batchSize;++d){const n=d*k,T=d*x;for(let d=t;d<r;++d){const t=(e+d*s-S)*I+n,r=d*v+T;for(let e=u;e<h;++e){const n=(c+e*o-E)*C+t,s=e*b+r;for(let e=l;e<p;++e){const t=e*y+s;A+=w[(i+e*a-R)*$+n+f]*g[t+m]}}}}d[T+m]=A}}}}}return c.toTensor()}fusedDepthwiseConv2D({input:e,filter:t,convInfo:n,bias:s,activation:o,preluActivationWeights:a}){let i=this.depthwiseConv2D(e,t,n);return s&&(i=r.add(i,s)),o&&(i=d(this,i,o,a)),i}depthwiseConv2D(e,t,n){(0,o.H)([e,t],"depthwiseConv2D");const s=n.filterHeight,a=n.filterWidth,i=n.dilationHeight,u=n.dilationWidth,l=n.padInfo.left,c=n.padInfo.top,d=n.outChannels/n.inChannels,h=r.buffer(n.outShape,e.dtype),p=this.readSync(e.dataId),f=this.readSync(t.dataId),m=h.values;for(let r=0;r<n.batchSize;++r){const o=r*e.strides[0],g=r*h.strides[0];for(let r=0;r<n.outHeight;++r){const x=g+r*h.strides[1],v=r*n.strideHeight-l;for(let r=0;r<s;++r){const s=v+r*i;if(s<0||s>=n.inHeight)continue;const l=r*t.strides[0],g=o+s*e.strides[1];for(let e=0;e<n.outWidth;++e){const r=x+e*h.strides[2],s=e*n.strideWidth-c;for(let e=0;e<a;++e){const o=s+e*u;if(o<0||o>=n.inWidth)continue;const a=l+e*t.strides[1],i=g+o*n.inChannels;let c=r,h=a;for(let e=0;e<n.inChannels;++e){const t=p[i+e];for(let e=0;e<d;++e)m[c+e]+=t*f[h+e];c+=d,h+=d}}}}}}return h.toTensor()}depthwiseConv2DDerInput(e,t,n){(0,o.H)([e,t],"depthwiseConv2DDerInput");const s=r.buffer(n.inShape,"float32"),a=s.values,[i,u,l]=s.strides,c=this.readSync(e.dataId),[d,h,p]=e.strides,f=this.readSync(t.dataId),[m,g,x]=t.strides,{batchSize:v,filterHeight:b,filterWidth:y,inChannels:w,inHeight:k,inWidth:I,outChannels:C,outHeight:$,outWidth:S,strideHeight:R,strideWidth:E}=n,T=b-1-n.padInfo.top,A=y-1-n.padInfo.left,_=C/w;for(let e=0;e<v;++e)for(let t=0;t<w;++t)for(let n=0;n<k;++n){const r=n-T,s=Math.max(0,Math.ceil(r/R)),o=Math.min($,(b+r)/R);for(let v=0;v<I;++v){const w=v-A,k=Math.max(0,Math.ceil(w/E)),I=Math.min(S,(y+w)/E);let C=0;for(let n=s;n<o;++n){const s=n*R-r;for(let r=k;r<I;++r){const o=d*e+h*n+p*r,a=m*(b-1-s)+g*(y-1-(r*E-w))+x*t;for(let e=0;e<_;++e)C+=c[o+(t*_+e)]*f[a+e]}}a[i*e+u*n+l*v+t]=C}}return s.toTensor()}depthwiseConv2DDerFilter(e,t,n){(0,o.H)([e,t],"depthwiseConv2DDerFilter");const s=n.strideHeight,a=n.strideWidth,i=n.filterHeight,u=n.filterWidth,l=r.buffer(n.filterShape,"float32"),c=n.padInfo.left,d=n.padInfo.top,h=n.outChannels/n.inChannels,p=this.bufferSync(e),f=this.bufferSync(t);for(let e=0;e<i;++e){const t=Math.max(0,Math.ceil((d-e)/s)),r=Math.min(n.outHeight,(n.inHeight+d-e)/s);for(let o=0;o<u;++o){const i=Math.max(0,Math.ceil((c-o)/a)),u=Math.min(n.outWidth,(n.inWidth+c-o)/a);for(let m=0;m<n.outChannels;++m){const g=Math.trunc(m/h),x=m%h;let v=0;for(let l=0;l<n.batchSize;++l)for(let n=t;n<r;++n){const t=e+n*s-d;for(let e=i;e<u;++e){const r=o+e*a-c;v+=p.get(l,t,r,g)*f.get(l,n,e,m)}}l.set(v,e,o,g,x)}}}return l.toTensor()}tile(e,t){return(0,o.H)(e,"tile"),u(this.bufferSync(e),t)}gather(e,t,n){(0,o.H)([e,t],"gather");const s=e.shape.slice(),a=this.readSync(t.dataId);s[n]=a.length;const i=r.buffer(s,e.dtype),u=this.bufferSync(e);for(let e=0;e<i.size;++e){const t=i.indexToLoc(e),r=t.slice();r[n]=a[t[n]];const s=u.locToIndex(r);i.values[e]=u.values[s]}return i.toTensor()}batchToSpaceND(e,t,n){(0,o.H)([e],"batchToSpaceND");const s=t.reduce(((e,t)=>e*t)),a=r.backend_util.getReshaped(e.shape,t,s),i=r.backend_util.getPermuted(a.length,t.length),u=r.backend_util.getReshapedPermuted(e.shape,t,s),l=r.backend_util.getSliceBeginCoords(n,t.length),c=r.backend_util.getSliceSize(u,n,t.length);return r.transpose(e.reshape(a),i).reshape(u).slice(l,c)}pool3d(e,t,n){(0,o.H)(e,"pool3d");const s=t.strideDepth,a=t.strideHeight,i=t.strideWidth,u=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,d=t.effectiveFilterDepth,h=t.effectiveFilterHeight,p=t.effectiveFilterWidth,f=t.padInfo.front,m=t.padInfo.top,g=t.padInfo.left,x="max"===n?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=this.readSync(e.dataId),b=r.buffer(t.outShape,e.dtype),y=b.values,w=t.outShape[1]*t.outShape[2]*t.outShape[3]*t.outShape[4],k=t.outShape[2]*t.outShape[3]*t.outShape[4],I=t.outShape[3]*t.outShape[4],C=t.outShape[4];for(let r=0;r<t.batchSize;++r){const o=r*w,b=r*e.strides[0];for(let r=0;r<t.inChannels;++r)for(let w=0;w<t.outDepth;++w){const $=w*s-f;let S=$;for(;S<0;)S+=u;const R=Math.min(t.inDepth,d+$),E=o+w*k;for(let s=0;s<t.outHeight;++s){const o=s*a-m;let d=o;for(;d<0;)d+=l;const f=Math.min(t.inHeight,h+o),w=E+s*I;for(let s=0;s<t.outWidth;++s){const o=s*i-g;let a=o;for(;a<0;)a+=c;const h=Math.min(t.inWidth,p+o),m=w+s*C;let k=x,I=0,$=0;for(let t=S;t<R;t+=u){const s=b+t*e.strides[1];for(let t=d;t<f;t+=l){const o=s+t*e.strides[2];for(let t=a;t<h;t+=c){const s=v[o+t*e.strides[3]+r];if("max"===n&&s>k?k=s:"avg"===n&&(I+=s,$++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}y[m+r]="avg"===n?I/$:k}}}}return b.toTensor()}avgPool3d(e,t){return(0,o.H)(e,"avgPool3d"),this.pool3d(e,t,"avg").toFloat()}avgPool3dBackprop(e,t,n){(0,o.H)([e,t],"avgPool3dBackprop");const s=n.strideDepth,a=n.strideHeight,i=n.strideWidth,u=n.filterDepth,l=n.filterHeight,c=n.filterWidth,d=n.dilationDepth,h=n.dilationHeight,p=n.dilationWidth,f=n.effectiveFilterDepth,m=n.effectiveFilterHeight,g=n.effectiveFilterWidth,x=f-1-n.padInfo.front,v=g-1-n.padInfo.left,b=m-1-n.padInfo.top,y=r.buffer(t.shape,"float32"),w=1/(u*l*c),k=this.bufferSync(e);for(let e=0;e<n.batchSize;++e)for(let t=0;t<n.inChannels;++t)for(let r=0;r<n.inDepth;++r)for(let o=0;o<n.inHeight;++o)for(let u=0;u<n.inWidth;++u){const l=r-x,c=o-b,I=u-v;let C=0;for(let r=0;r<f;r+=d){const o=(l+r)/s;if(!(o<0||o>=n.outDepth||Math.floor(o)!==o))for(let r=0;r<m;r+=h){const s=(c+r)/a;if(!(s<0||s>=n.outHeight||Math.floor(s)!==s))for(let r=0;r<g;r+=p){const a=(I+r)/i;a<0||a>=n.outWidth||Math.floor(a)!==a||(C+=k.get(e,o,s,a,t))}}}y.set(C*w,e,r,o,u,t)}return y.toTensor()}maxPool3d(e,t){return(0,o.H)(e,"maxPool3d"),this.pool3d(e,t,"max").toFloat()}maxPool3dPositions(e,t){const n=r.buffer(t.outShape,"int32"),s=t.strideDepth,o=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,u=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterDepth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,p=t.padInfo.front,f=t.padInfo.top,m=t.padInfo.left,g=this.bufferSync(e);for(let e=0;e<t.batchSize;++e)for(let r=0;r<t.inChannels;++r)for(let x=0;x<t.outDepth;++x){const v=x*s-p;let b=v;for(;b<0;)b+=i;const y=Math.min(t.inDepth,c+v);for(let s=0;s<t.outHeight;++s){const c=s*o-f;let p=c;for(;p<0;)p+=u;const w=Math.min(t.inHeight,d+c);for(let o=0;o<t.outWidth;++o){const f=o*a-m;let k=f;for(;k<0;)k+=l;const I=Math.min(t.inWidth,h+f);let C=Number.NEGATIVE_INFINITY,$=-1;for(let t=b;t<y;t+=i){const n=t-v;for(let s=p;s<w;s+=u){const o=s-c;for(let a=k;a<I;a+=l){const i=a-f,u=g.get(e,t,s,a,r);u>=C&&(C=u,$=n*d*h+o*d+i)}}}n.set($,e,x,s,o,r)}}}return n.toTensor()}maxPool3dBackprop(e,t,n,s){(0,o.H)([t,n],"maxPool3dBackprop");const a=this.maxPool3dPositions(t,s),i=s.strideDepth,u=s.strideHeight,l=s.strideWidth,c=s.dilationDepth,d=s.dilationHeight,h=s.dilationWidth,p=s.effectiveFilterDepth,f=s.effectiveFilterHeight,m=s.effectiveFilterWidth,g=p-1-s.padInfo.front,x=m-1-s.padInfo.left,v=f-1-s.padInfo.top,b=r.buffer(t.shape,"float32"),y=this.bufferSync(a),w=this.bufferSync(e);for(let e=0;e<s.batchSize;++e)for(let t=0;t<s.inChannels;++t)for(let n=0;n<s.inDepth;++n)for(let r=0;r<s.inHeight;++r)for(let o=0;o<s.inWidth;++o){const a=n-g,k=r-v,I=o-x;let C=0;for(let n=0;n<p;n+=c){const r=(a+n)/i;if(!(r<0||r>=s.outDepth||Math.floor(r)!==r))for(let o=0;o<f;o+=d){const a=(k+o)/u;if(!(a<0||a>=s.outHeight||Math.floor(a)!==a))for(let i=0;i<m;i+=h){const u=(I+i)/l;if(u<0||u>=s.outWidth||Math.floor(u)!==u)continue;const c=p*f*m-1-y.get(e,r,a,u,t)===n*f*m+o*m+i?1:0;0!==c&&(C+=w.get(e,r,a,u,t)*c)}}}b.set(C,e,n,r,o,t)}return b.toTensor()}resizeBilinear(e,t,n,s){(0,o.H)(e,"resizeBilinear");const[a,i,u,l]=e.shape,c=this.readSync(e.dataId),d=new Float32Array(r.util.sizeFromShape([a,t,n,l])),h=[s&&t>1?i-1:i,s&&n>1?u-1:u],p=[s&&t>1?t-1:t,s&&n>1?n-1:n];let f=0;const m=h[0]/p[0],g=h[1]/p[1];for(let r=0;r<a;r++)for(let s=0;s<t;s++){const t=m*s,o=Math.floor(t),a=t-o,h=Math.min(i-1,Math.ceil(t)),p=r*e.strides[0]+o*e.strides[1],x=r*e.strides[0]+h*e.strides[1];for(let t=0;t<n;t++){const n=g*t,r=Math.floor(n),s=n-r,o=Math.min(u-1,Math.ceil(n)),i=p+r*e.strides[2],h=x+r*e.strides[2],m=p+o*e.strides[2],v=x+o*e.strides[2];for(let e=0;e<l;e++){const t=c[i+e],n=c[h+e],r=t+(c[m+e]-t)*s,o=r+(n+(c[v+e]-n)*s-r)*a;d[f++]=o}}}return r.tensor(d,[a,t,n,l])}resizeBilinearBackprop(e,t,n){(0,o.H)([e,t],"resizeBilinearBackprop");const[s,a,i,u]=t.shape,[,l,c]=e.shape,d=new Float32Array(s*a*i*u),h=[n&&l>1?a-1:a,n&&c>1?i-1:i],p=[n&&l>1?l-1:l,n&&c>1?c-1:c],f=h[0]/p[0],m=h[1]/p[1],g=this.readSync(e.dataId);let x=0;for(let e=0;e<s;e++){const n=e*t.strides[0];for(let e=0;e<l;e++){const r=e*f,s=Math.floor(r),o=Math.min(Math.ceil(r),a-1),l=n+s*t.strides[1],h=n+o*t.strides[1],p=r-s,v=1-p;for(let e=0;e<c;e++){const n=e*m,r=Math.floor(n),s=Math.min(Math.ceil(n),i-1),o=n-r,a=1-o,c=l+r*t.strides[2],f=l+s*t.strides[2],b=h+r*t.strides[2],y=h+s*t.strides[2],w=v*a,k=v*o,I=p*a,C=p*o;for(let e=0;e<u;e++){const t=g[x++];d[c+e]+=t*w,d[f+e]+=t*k,d[b+e]+=t*I,d[y+e]+=t*C}}}}return r.tensor4d(d,[s,i,a,u],t.dtype)}resizeNearestNeighbor(e,t,n,s){(0,o.H)(e,"resizeNearestNeighbor");const[a,i,u,l]=e.shape,c=this.readSync(e.dataId),d=new Float32Array(a*t*n*l),h=[s&&t>1?i-1:i,s&&n>1?u-1:u],p=[s&&t>1?t-1:t,s&&n>1?n-1:n],f=h[0]/p[0],m=h[1]/p[1];let g=0;for(let r=0;r<a;r++){const o=r*e.strides[0];for(let r=0;r<t;r++){const t=f*r,a=o+Math.min(i-1,s?Math.round(t):Math.floor(t))*e.strides[1];for(let t=0;t<n;t++){const n=m*t,r=a+Math.min(u-1,s?Math.round(n):Math.floor(n))*e.strides[2];for(let e=0;e<l;e++){const t=c[r+e];d[g++]=t}}}}return r.tensor(d,[a,t,n,l],e.dtype)}resizeNearestNeighborBackprop(e,t,n){(0,o.H)([e,t],"resizeNearestNeighborBackprop");const[s,a,i,u]=t.shape,[,l,c]=e.shape,d=new Float32Array(s*a*i*u),h=this.readSync(e.dataId),p=[n&&l>1?a-1:a,n&&c>1?i-1:i],f=[n&&l>1?l-1:l,n&&c>1?c-1:c],m=p[0]/f[0],g=p[1]/f[1],x=1/m,v=1/g,b=2*Math.ceil(x)+2,y=2*Math.ceil(v)+2;for(let r=0;r<s;r++){const s=r*t.strides[0];for(let r=0;r<a;r++){const o=s+r*t.strides[1],p=Math.floor(r*x),f=Math.floor(p-b/2);for(let p=0;p<i;p++){const x=o+p*t.strides[2],w=Math.floor(p*v),k=Math.floor(w-y/2);for(let t=0;t<u;t++){let o=0;for(let u=0;u<b;u++){const d=u+f;if(d<0||d>=l)continue;const x=s+d*e.strides[1],v=d*m;if(r===Math.min(a-1,n?Math.round(v):Math.floor(v)))for(let r=0;r<y;r++){const s=r+k;if(s<0||s>=c)continue;const a=x+s*e.strides[2],u=s*g;p===Math.min(i-1,n?Math.round(u):Math.floor(u))&&(o+=h[a+t])}}d[x+t]=o}}}}return r.tensor4d(d,t.shape,t.dtype)}localResponseNormalization4D(e,t,n,s,a){(0,o.H)(e,"localResponseNormalization4D");const i=e.shape[3],u=i-1,l=this.readSync(e.dataId),c=e.size,d=new Float32Array(c);function h(e){const n=e%i;let r=e-n+Math.max(0,n-t);const s=e-n+Math.min(n+t,u);let o=0;for(;r<=s;r++){const e=l[r];o+=e*e}return o}for(let e=0;e<c;e++){const t=h(e),r=l[e]*Math.pow(n+s*t,-a);d[e]=r}return r.tensor4d(d,e.shape)}LRNGrad(e,t,n,s,a,i,u){(0,o.H)(e,"LRNGrad");const l=e.shape[3],c=this.readSync(e.dataId),d=this.readSync(t.dataId),h=this.readSync(n.dataId),p=new Float32Array(e.size),f=e.size;for(let e=0;e<f;e++){const t=e%l,n=e-t+Math.max(0,t-s),r=e-t+Math.min(l,t+s+1);let o=0;for(let e=n;e<r;e++)o+=Math.pow(d[e],2);o=i*o+a;for(let t=n;t<r;t++){let n=-2*i*u*d[t]*h[e]/o;e===t&&(n+=Math.pow(o,-u)),n*=c[e],p[t]+=n}}return r.tensor4d(p,e.shape)}multinomial(e,t,n,a){(0,o.H)(e,"multinomial");const i=t?e:r.softmax(e),u=i.shape[0],l=i.shape[1],c=r.zeros([u,n],"int32"),d=this.readSync(c.dataId),h=this.readSync(i.dataId);for(let e=0;e<u;++e){const t=e*l,r=new Float32Array(l-1);r[0]=h[t];for(let e=1;e<r.length;++e)r[e]=r[e-1]+h[t+e];const o=s.alea(a.toString()),i=e*n;for(let e=0;e<n;++e){const t=o();d[i+e]=r.length;for(let n=0;n<r.length;n++)if(t<r[n]){d[i+e]=n;break}}}return c}oneHot(e,t,n,s){(0,o.H)(e,"oneHot");const a=new Float32Array(e.size*t);a.fill(s);const i=this.readSync(e.dataId);for(let r=0;r<e.size;++r)i[r]>=0&&i[r]<t&&(a[r*t+i[r]]=n);return r.tensor2d(a,[e.size,t],"int32")}nonMaxSuppression(e,t,n,r,s){(0,o.H)(e,"nonMaxSuppression");const i=this.readSync(e.dataId),u=this.readSync(t.dataId);return a(i,u,n,r,s)}depthToSpace(e,t,n){r.util.assert("NHWC"===n,(()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+n)),r.util.assert(t>1,(()=>"blockSize should be > 1 for depthToSpace, but was: "+t));const s=e.shape[0],o=e.shape[1],a=e.shape[2],i=e.shape[3],u=o*t,l=a*t,c=i/(t*t),d=this.readSync(e.dataId),h=new Float32Array(s*u*l*c);let p=0;for(let e=0;e<s;++e)for(let n=0;n<u;++n){const r=Math.floor(n/t),s=n%t;for(let n=0;n<l;++n){const u=Math.floor(n/t),l=(s*t+n%t)*c;for(let t=0;t<c;++t){const n=t+l+i*(u+a*(r+o*e));h[p++]=d[n]}}}return r.tensor4d(h,[s,u,l,c])}broadcastedBinaryOp(e,t,n,s){const o=r.backend_util.assertAndGetBroadcastShape(e.shape,t.shape),a=r.buffer(o,n),i=this.readSync(e.dataId),u=this.readSync(t.dataId),l=r.backend_util.getBroadcastDims(e.shape,o),c=r.backend_util.getBroadcastDims(t.shape,o),d=a.values;if(l.length+c.length===0)for(let e=0;e<d.length;++e)d[e]=s(i[e%i.length],u[e%u.length]);else{const n=this.bufferSync(e),r=this.bufferSync(t);for(let o=0;o<d.length;++o){const h=a.indexToLoc(o),p=h.slice(-e.rank);l.forEach((e=>p[e]=0));const f=n.locToIndex(p),m=h.slice(-t.rank);c.forEach((e=>m[e]=0));const g=r.locToIndex(m);d[o]=s(i[f],u[g])}}return a.toTensor()}split(e,t,n){return i(e,t,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}cropAndResize(e,t,n,s,o,a){const[i,u,l,c]=e.shape,d=t.shape[0],[h,p]=s,f=r.buffer([d,h,p,c],"float32"),m=this.readSync(t.dataId),g=this.readSync(n.dataId),x=this.readSync(e.dataId),v=e.strides,b=f.strides;for(let e=0;e<d;e++){const t=4*e,n=m[t],r=m[t+1],s=m[t+2],d=m[t+3],y=g[e];if(y>=i)continue;const w=h>1?(s-n)*(u-1)/(h-1):0,k=p>1?(d-r)*(l-1)/(p-1):0;for(let t=0;t<h;t++){const i=h>1?n*(u-1)+t*w:.5*(n+s)*(u-1);if(i<0||i>u-1)for(let n=0;n<p;n++)for(let r=0;r<c;r++){const s=r+n*b[2]+t*b[1]+e*b[0];f.values[s]=a}else if("bilinear"===o){const n=Math.floor(i),s=Math.ceil(i),o=i-n;for(let i=0;i<p;i++){const u=p>1?r*(l-1)+i*k:.5*(r+d)*(l-1);if(u<0||u>l-1){for(let n=0;n<c;n++){const r=n+i*b[2]+t*b[1]+e*b[0];f.values[r]=a}continue}const h=Math.floor(u),m=Math.ceil(u),g=u-h;for(let r=0;r<c;r++){let a=r+h*v[2]+n*v[1]+y*v[0];const u=x[a];a=r+m*v[2]+n*v[1]+y*v[0];const l=x[a];a=r+h*v[2]+s*v[1]+y*v[0];const c=x[a];a=r+m*v[2]+s*v[1]+y*v[0];const d=u+(l-u)*g,p=c+(x[a]-c)*g;a=r+i*b[2]+t*b[1]+e*b[0],f.values[a]=d+(p-d)*o}}}else for(let n=0;n<p;++n){const s=p>1?r*(l-1)+n*k:.5*(r+d)*(l-1);if(s<0||s>l-1){for(let r=0;r<c;r++){const s=r+n*b[2]+t*b[1]+e*b[0];f.values[s]=a}continue}const o=Math.round(s),u=Math.round(i);for(let r=0;r<c;r++){const s=r+o*v[2]+u*v[1]+y*v[0],a=r+n*b[2]+t*b[1]+e*b[0];f.values[a]=x[s]}}}}return f.toTensor()}sparseToDense(e,t,n,s){const{sliceRank:o,numUpdates:a,sliceSize:i,strides:u,outputSize:l}=r.backend_util.calculateShapes(t,e,n);return this.scatter(e,t,n,l,i,a,o,u,s,!1)}gatherND(e,t){const n=t.shape,s=n[n.length-1],[o,a,i,u]=r.backend_util.prepareAndValidate(e,t);if(0===a)return r.tensor([],o,e.dtype);const l=new r.TensorBuffer([a,i],e.dtype),c=this.readSync(t.dataId),d=this.readSync(e.dataId);for(let t=0;t<a;t++){const n=[];let r=0;for(let e=0;e<s;e++){const o=c[t*s+e];r+=o*u[e],n.push(o)}if(r<0||r>=e.size/i)throw new Error(`Invalid indices: ${n} does not index into ${e.shape}`);for(let e=0;e<i;e++)l.values[t*i+e]=d[r*i+e]}return l.toTensor().reshape(o)}scatterND(e,t,n){const{sliceRank:s,numUpdates:o,sliceSize:a,strides:i,outputSize:u}=r.backend_util.calculateShapes(t,e,n),l=r.scalar(0);return this.scatter(e,t,n,u,a,o,s,i,l,!0)}fill(e,t,n){n=n||r.util.inferDtype(t);const s=r.util.getArrayFromDType(n,r.util.sizeFromShape(e));return s.fill(t),(0,r.engine)().makeTensor(s,e,n,this)}onesLike(e){if("string"===e.dtype)throw new Error("onesLike is not supported for string tensors");return this.fill(e.shape,1,e.dtype)}zerosLike(e){const t=r.util.getArrayFromDType(e.dtype,r.util.sizeFromShape(e.shape));return this.makeOutput(t,e.shape,e.dtype)}linspace(e,t,n){return r.backend_util.linspaceImpl(e,t,n)}scatter(e,t,n,s,o,a,i,u,l,c){const d=[s/o,o],h=this.readSync(e.dataId),p=this.readSync(t.dataId);if(0===s)return r.tensor([],n,t.dtype);const f=new r.TensorBuffer(d,t.dtype);f.values.fill(this.readSync(l.dataId)[0]);for(let e=0;e<a;e++){const r=[];let a=0;for(let t=0;t<i;t++){const n=h[e*i+t];r.push(n),a+=n*u[t]}if(a<0||a>=s/o)throw new Error(`Invalid indices: ${r} does not index into ${n}`);for(let n=0;n<o;n++)c?f.values[a*o+n]+=p[e*o+n]:f.values[a*o+n]=0===t.rank?p[0]:p[e*o+n]}return f.toTensor().reshape(n)}}var p=n(45226);const f="2.6.0";(0,r.registerBackend)("cpu",(()=>new h),1);var m=n(60224),g=n(76738);const x=(0,g.A)(r.Acos,(e=>Math.acos(e))),v={kernelName:r.Acos,backendName:"cpu",kernelFunc:x},b=(0,g.A)(r.Acosh,(e=>Math.acosh(e))),y={kernelName:r.Acosh,backendName:"cpu",kernelFunc:b};var w=n(32779);const k=(0,g.A)(r.Asin,(e=>Math.asin(e))),I={kernelName:r.Asin,backendName:"cpu",kernelFunc:k},C=(0,g.A)(r.Asinh,(e=>Math.asinh(e))),$={kernelName:r.Asinh,backendName:"cpu",kernelFunc:C},S=(0,g.A)(r.Atan,(e=>Math.atan(e))),R={kernelName:r.Atan,backendName:"cpu",kernelFunc:S},E=(0,g.A)(r.Atanh,(e=>Math.atanh(e))),T={kernelName:r.Atanh,backendName:"cpu",kernelFunc:E};function A(e,t,n,s,o,a){const i=o.strideHeight,u=o.strideWidth,l=o.dilationHeight,c=o.dilationWidth,d=o.effectiveFilterHeight,h=o.effectiveFilterWidth,p=o.padInfo.top,f=o.padInfo.left,m="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=(0,r.buffer)(o.outShape,n),x=g.values,v=o.outShape[1]*o.outShape[2]*o.outShape[3],b=o.outShape[2]*o.outShape[3],y=o.outShape[3];for(let t=0;t<o.batchSize;++t){const n=t*v,r=t*s[0];for(let t=0;t<o.inChannels;++t)for(let g=0;g<o.outHeight;++g){const v=g*i-p,w=Math.max(0,v),k=Math.min(o.inHeight,d+v),I=n+g*b;for(let n=0;n<o.outWidth;++n){const i=n*u-f,d=Math.max(0,i),p=Math.min(o.inWidth,h+i);let g=m,v=0,b=0;for(let n=w;n<k;n+=l){const o=r+n*s[1];for(let n=d;n<p;n+=c){const r=e[o+n*s[2]+t];"max"===a&&r>g?g=r:"avg"===a&&(v+=r,b++)}if(isNaN(g))break}x[I+n*y+t]="avg"===a?v/b:g}}}return g}function _(e,t,n,s,o=!1,a=!1){const i=(0,r.buffer)(s.outShape,"int32"),u=s.strideHeight,l=s.strideWidth,c=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterHeight,p=s.effectiveFilterWidth,f=s.padInfo.top,m=s.padInfo.left,g=(0,r.buffer)(t,n,e);for(let e=0;e<s.batchSize;++e)for(let t=0;t<s.inChannels;++t)for(let n=0;n<s.outHeight;++n){const r=n*u-f;let x=r;for(;x<0;)x+=c;const v=Math.min(s.inHeight,h+r);for(let u=0;u<s.outWidth;++u){const h=u*l-m;let f=h;for(;f<0;)f+=d;const b=Math.min(s.inWidth,p+h);let y=Number.NEGATIVE_INFINITY,w=-1;for(let n=x;n<v;n+=c){const i=n-r;for(let r=f;r<b;r+=d){const u=r-h,l=g.get(e,n,r,t);l>y&&(y=l,w=o?a?((e*s.inHeight+n)*s.inWidth+r)*s.inChannels+t:(n*s.inWidth+r)*s.inChannels+t:i*p+u)}}i.set(w,e,n,u,t)}}return i}var N=n(41775);const F={kernelName:r.AvgPool,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:a}=t;(0,o.H)(a,"avgPool");const{filterSize:i,strides:u,pad:l,dimRoundingMode:c}=s;r.util.assert(r.backend_util.eitherStridesOrDilationsAreOne(u,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${u} and dilations '1'`));const d=r.backend_util.computePool2DInfo(a.shape,i,u,1,l,c);let h;if(1===d.filterWidth&&1===d.filterHeight&&r.util.arraysEqual(d.inShape,d.outShape))h=(0,N.y)({inputs:{x:a},backend:n});else{const e=n.data.get(a.dataId).values,t=r.util.computeStrides(a.shape),s=A(e,a.shape,a.dtype,t,d,"avg");h=n.makeTensorInfo(d.outShape,a.dtype,s.values)}return h}},D={kernelName:r.AvgPoolBackprop,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:a,input:i}=t,u=i;(0,o.H)([a,i],"avgPoolBackprop");const{filterSize:l,strides:c,pad:d}=s,h=r.backend_util.computePool2DInfo(u.shape,l,c,1,d),p=h.strideHeight,f=h.strideWidth,m=h.filterHeight,g=h.filterWidth,x=h.dilationHeight,v=h.dilationWidth,b=h.effectiveFilterHeight,y=h.effectiveFilterWidth,w=y-1-h.padInfo.left,k=b-1-h.padInfo.top,I=(0,r.buffer)(u.shape,"float32"),C=1/(m*g),$=n.data.get(a.dataId).values,S=(0,r.buffer)(a.shape,"float32",$);for(let e=0;e<h.batchSize;++e)for(let t=0;t<h.inChannels;++t)for(let n=0;n<h.inHeight;++n)for(let r=0;r<h.inWidth;++r){const s=n-k,o=r-w;let a=0;for(let n=0;n<b;n+=x){const r=(s+n)/p;if(!(r<0||r>=h.outHeight||Math.floor(r)!==r))for(let n=0;n<y;n+=v){const s=(o+n)/f;s<0||s>=h.outWidth||Math.floor(s)!==s||(a+=S.get(e,r,s,t))}}I.set(a*C,e,n,r,t)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}},B={kernelName:r.FusedBatchNorm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:a,scale:i,offset:u,mean:l,variance:c}=t;r.util.assert(l.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),r.util.assert(null==u||l.shape.length===u.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),r.util.assert(null==i||l.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),(0,o.H)([a,l,c,i,u],"batchNorm");let{varianceEpsilon:d}=s;null==d&&(d=.001);const h=n.data.get(a.dataId).values,p=n.data.get(l.dataId).values,f=n.data.get(c.dataId).values,m=i?n.data.get(i.dataId).values:new Float32Array([1]),g=u?n.data.get(u.dataId).values:new Float32Array([0]),x=new Float32Array(h.length),v=g.length,b=m.length,y=f.length,w=p.length;let k=0,I=0,C=0,$=0;for(let e=0;e<h.length;++e)x[e]=g[k++]+(h[e]-p[I++])*m[C++]/Math.sqrt(f[$++]+d),k>=v&&(k=0),I>=w&&(I=0),C>=b&&(C=0),$>=y&&($=0);return n.makeTensorInfo(a.shape,a.dtype,x)}};var O=n(29258),M=n(34769);const P=(0,g.A)(r.ClipByValue,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),L={kernelName:r.ClipByValue,backendName:"cpu",kernelFunc:P};var V=n(26961);function W(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,o=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,o)}const z={kernelName:r.Imag,backendName:"cpu",kernelFunc:W};var U=n(82186);function H(e){const{inputs:t,backend:n,attrs:s}=e,{x:o}=t,{shape:a}=s,i=r.util.sizeFromShape(o.shape),u=r.util.inferFromImplicitShape(a,i),l=r.util.sizeFromShape(u);r.util.assert(i===l,(()=>`The new shape (${u}) has ${l} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(o.dataId);const c=n.data.get(o.dataId);if(null!=c.complexTensorInfos){const e=c.complexTensorInfos.real,t=c.complexTensorInfos.imag;e.shape=u,t.shape=u}return{dataId:o.dataId,shape:u,dtype:o.dtype}}const G={kernelName:r.Reshape,backendName:"cpu",kernelFunc:H};function X(e){const{inputs:t,backend:n,attrs:s}=e,{axis:o}=s,a=r.util.parseAxisParam(o,t[0].shape)[0];let i=r.backend_util.computeOutShape(t.map((e=>e.shape)),a);if(0===r.util.sizeFromShape(i))return n.makeTensorInfo(i,t[0].dtype,[]);const u=t.filter((e=>r.util.sizeFromShape(e.shape)>0));if(1===u.length)return u[0];const l=u.map((e=>e.shape));if(r.backend_util.assertParamsConsistent(l,a),"complex64"===u[0].dtype){const e=u.map((e=>(0,U.k)({inputs:{input:e},backend:n}))),t=u.map((e=>W({inputs:{input:e},backend:n}))),r=X({inputs:e,backend:n,attrs:{axis:o}}),s=X({inputs:t,backend:n,attrs:{axis:o}}),a=(0,V.P)({inputs:{real:r,imag:s},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),a}const c=u.map((e=>{const t=r.util.sizeFromShape(e.shape.slice(a));return H({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})}));i=r.backend_util.computeOutShape(c.map((e=>e.shape)),1);const d=r.util.getTypedArrayFromDType(u[0].dtype,r.util.sizeFromShape(i));if(1===c[0].shape[0]){let e=0;c.forEach((t=>{const s=n.data.get(t.dataId).values,o=r.util.sizeFromShape(t.shape);d.set(s,e),e+=o}))}else{let e=0;c.forEach((t=>{const r=n.data.get(t.dataId).values;let s=0;for(let n=0;n<t.shape[0];++n){const o=n*i[1]+e;for(let e=0;e<t.shape[1];++e)d[o+e]=r[s++]}e+=t.shape[1]}))}const h=r.backend_util.computeOutShape(u.map((e=>e.shape)),a),p=n.makeTensorInfo(h,t[0].dtype,d);return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}const q={kernelName:r.Concat,backendName:"cpu",kernelFunc:X},K=(0,g.A)(r.Cos,(e=>Math.cos(e))),j={kernelName:r.Cos,backendName:"cpu",kernelFunc:K},Y=(0,g.A)(r.Cosh,(e=>Math.cosh(e))),Q={kernelName:r.Cosh,backendName:"cpu",kernelFunc:Y},J={kernelName:r.Dilation2D,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:o}=e,{strides:a,pad:i,dilations:u}=n,l=t,c=l.data.get(s.dataId).values,d=s.shape.length,h=l.data.get(o.dataId).values,p=o.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:x,outHeight:v,outWidth:b,padInfo:y,strideHeight:w,strideWidth:k,filterHeight:I,filterWidth:C,dilationHeight:$,dilationWidth:S,outShape:R}=r.backend_util.computeDilation2DInfo(s.shape,o.shape,a,i,"NHWC",u),E=r.util.sizeFromShape(R),T=R.length,A=r.util.getArrayFromDType(s.dtype,E);for(let e=0;e<f;++e)for(let t=0;t<v;++t){const n=t*w-y.top;for(let a=0;a<b;++a){const i=a*k-y.left;for(let u=0;u<x;++u){let l=Number.MIN_SAFE_INTEGER;for(let t=0;t<I;++t){const a=n+t*$;if(a>=0&&a<m)for(let n=0;n<C;++n){const f=i+n*S;if(f>=0&&f<g){const i=r.util.locToIndex([e,a,f,u],d,r.util.computeStrides(s.shape)),m=r.util.locToIndex([t,n,u],p,r.util.computeStrides(o.shape)),g=c[i]+h[m];g>l&&(l=g)}}}A[r.util.locToIndex([e,t,a,u],T,r.util.computeStrides(R))]=l}}}return{dataId:l.write(r.util.toTypedArray(A,s.dtype),R,s.dtype),shape:R,dtype:s.dtype}}},Z={kernelName:r.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:o,dy:a}=e,{strides:i,pad:u,dilations:l}=n,c=t,d=r.util.toNestedArray(s.shape,c.data.get(s.dataId).values),h=r.util.toNestedArray(o.shape,c.data.get(o.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:x,outWidth:v,padInfo:b,strideHeight:y,strideWidth:w,filterHeight:k,filterWidth:I,dilationHeight:C,dilationWidth:$,outShape:S}=r.backend_util.computeDilation2DInfo(s.shape,o.shape,i,u,"NHWC",l);r.util.assert(a.rank===S.length,(()=>`Error in ${r.Dilation2DBackpropFilter}, dy must have the same rank as output ${S.length}, but got `+a.rank));const R=r.util.toNestedArray(S,c.data.get(a.dataId).values),E=r.util.makeZerosNestedTypedArray(o.shape,o.dtype);for(let e=0;e<p;++e)for(let t=0;t<x;++t){const n=t*y-b.top;for(let r=0;r<v;++r){const s=r*w-b.left;for(let o=0;o<g;++o){let a=Number.MIN_SAFE_INTEGER,i=0,u=0;for(let t=0;t<k;++t){const r=n+t*C;if(r>=0&&r<f)for(let n=0;n<I;++n){const l=s+n*$;if(l>=0&&l<m){const s=d[e][r][l][o]+h[t][n][o];s>a&&(a=s,i=t,u=n)}}}E[i][u][o]+=R[e][t][r][o]}}}return{dataId:c.write(r.util.toTypedArray(E,s.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}},ee={kernelName:r.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:o,dy:a}=e,{strides:i,pad:u,dilations:l}=n,c=t,d=r.util.toNestedArray(s.shape,c.data.get(s.dataId).values),h=r.util.toNestedArray(o.shape,c.data.get(o.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:x,outWidth:v,padInfo:b,strideHeight:y,strideWidth:w,filterHeight:k,filterWidth:I,dilationHeight:C,dilationWidth:$,outShape:S}=r.backend_util.computeDilation2DInfo(s.shape,o.shape,i,u,"NHWC",l);r.util.assert(a.rank===S.length,(()=>`Error in ${r.Dilation2DBackpropInput}, dy must have the same rank as output ${S.length}, but got `+a.rank));const R=r.util.toNestedArray(S,c.data.get(a.dataId).values),E=r.util.makeZerosNestedTypedArray(s.shape,s.dtype);for(let e=0;e<p;++e)for(let t=0;t<x;++t){const n=t*y-b.top;for(let r=0;r<v;++r){const s=r*w-b.left;for(let o=0;o<g;++o){let a=Number.MIN_SAFE_INTEGER,i=n<0?0:n,u=s<0?0:s;for(let t=0;t<k;++t){const r=n+t*C;if(r>=0&&r<f)for(let n=0;n<I;++n){const l=s+n*$;if(l>=0&&l<m){const s=d[e][r][l][o]+h[t][n][o];s>a&&(a=s,i=r,u=l)}}}E[e][i][u][o]+=R[e][t][r][o]}}}return{dataId:c.write(r.util.toTypedArray(E,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};var te=n(33533),ne=n(90546);const re=(0,te.b)(((e,t)=>e/t)),se=(0,ne.j)(r.Div,re),oe={kernelName:r.Div,backendName:"cpu",kernelFunc:se},ae=(0,g.A)(r.Elu,(e=>e>=0?e:Math.exp(e)-1)),ie={kernelName:r.Elu,backendName:"cpu",kernelFunc:ae},ue=r.backend_util.ERF_P,le=r.backend_util.ERF_A1,ce=r.backend_util.ERF_A2,de=r.backend_util.ERF_A3,he=r.backend_util.ERF_A4,pe=r.backend_util.ERF_A5,fe=(0,g.A)(r.Erf,(e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+ue*n);return t*(1-((((pe*r+he)*r+de)*r+ce)*r+le)*r*Math.exp(-n*n))})),me={kernelName:r.Erf,backendName:"cpu",kernelFunc:fe};var ge=n(31211),xe=n(30969),ve=n(1917),be=n(82578),ye=n(71649);function we(e,t,n){const s=e.shape,o=s[0],a=s[1],i=n.data.get(e.dataId),u=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,c=[o,a],d=r.util.sizeFromShape(c),h=r.util.getTypedArrayFromDType("float32",d),p=r.util.getTypedArrayFromDType("float32",d);for(let e=0;e<o;e++){const s=(0,be.tP)({inputs:{x:u},backend:n,attrs:{begin:[e,0],size:[1,a]}}),o=(0,be.tP)({inputs:{x:l},backend:n,attrs:{begin:[e,0],size:[1,a]}}),i=(0,V.P)({inputs:{real:s,imag:o},backend:n}),{real:c,imag:d}=ke(i,t,n),f=r.backend_util.mergeRealAndImagArrays(c,d);for(let t=0;t<a;t++){const n=r.backend_util.getComplexWithIndex(f,t);h[e*a+t]=n.real,p[e*a+t]=n.imag}n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i)}const f=n.makeTensorInfo(c,"float32",h),m=n.makeTensorInfo(c,"float32",p),g=(0,V.P)({inputs:{real:f,imag:m},backend:n});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}function ke(e,t,n){const s=r.util.sizeFromShape(e.shape),o=n.data.get(e.dataId),a=n.data.get(o.complexTensorInfos.real.dataId).values,i=n.data.get(o.complexTensorInfos.imag.dataId).values;if(0==((u=s)&u-1)){const o=Ie(a,i,s,t,n),u=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(u,"float32",o.real),t=n.makeTensorInfo(u,"float32",o.imag),a=n.makeTensorInfo([],"float32",r.util.createScalarValue(s,"float32")),i=(0,N.y)({inputs:{x:a},backend:n}),l=oe.kernelFunc({inputs:{a:e,b:a},backend:n}),c=oe.kernelFunc({inputs:{a:t,b:i},backend:n}),d=n.data.get(l.dataId).values,h=n.data.get(c.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),{real:d,imag:h}}return o}{const e=function(e,t,n){const s=new Float32Array(2*t);for(let o=0;o<t;o++){let a=0,i=0;for(let s=0;s<t;s++){const u=r.backend_util.exponent(o*s,t,n),l=r.backend_util.getComplexWithIndex(e,s);a+=l.real*u.real-l.imag*u.imag,i+=l.real*u.imag+l.imag*u.real}n&&(a/=t,i/=t),r.backend_util.assignToTypedArray(s,a,i,o)}return s}(r.backend_util.mergeRealAndImagArrays(a,i),s,t);return r.backend_util.splitRealAndImagArrays(e)}var u}function Ie(e,t,n,s,o){if(1===n)return{real:e,imag:t};const a=r.backend_util.mergeRealAndImagArrays(e,t),i=n/2,u=r.backend_util.complexWithEvenIndex(a),l=u.real,c=u.imag,d=[l.length],h=o.makeTensorInfo(d,"float32",l),p=o.makeTensorInfo(d,"float32",c),f=(0,V.P)({inputs:{real:h,imag:p},backend:o}),m=r.backend_util.complexWithOddIndex(a),g=m.real,x=m.imag,v=[g.length],b=o.makeTensorInfo(v,"float32",g),y=o.makeTensorInfo(v,"float32",x),k=(0,V.P)({inputs:{real:b,imag:y},backend:o}),I=Ie(l,c,i,s,o),C=I.real,$=I.imag,S=[C.length],R=o.makeTensorInfo(S,"float32",C),E=o.makeTensorInfo(S,"float32",$),T=(0,V.P)({inputs:{real:R,imag:E},backend:o}),A=Ie(g,x,i,s,o),_=A.real,N=A.imag,F=[_.length],D=o.makeTensorInfo(F,"float32",_),B=o.makeTensorInfo(F,"float32",N),O=(0,V.P)({inputs:{real:D,imag:B},backend:o}),M=r.backend_util.exponents(n,s),P=[M.real.length],L=o.makeTensorInfo(P,"float32",M.real),z=o.makeTensorInfo(P,"float32",M.imag),H=(0,V.P)({inputs:{real:L,imag:z},backend:o}),G=(0,ve.Jp)({inputs:{a:H,b:O},backend:o}),q=(0,w.IH)({inputs:{a:T,b:G},backend:o}),K=(0,ye.lu)({inputs:{a:T,b:G},backend:o}),j=(0,U.k)({inputs:{input:q},backend:o}),Y=(0,U.k)({inputs:{input:K},backend:o}),Q=W({inputs:{input:q},backend:o}),J=W({inputs:{input:K},backend:o}),Z=X({inputs:[j,Y],backend:o,attrs:{axis:0}}),ee=X({inputs:[Q,J],backend:o,attrs:{axis:0}}),te=o.data.get(Z.dataId).values,ne=o.data.get(ee.dataId).values;return o.disposeIntermediateTensorInfo(h),o.disposeIntermediateTensorInfo(p),o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(b),o.disposeIntermediateTensorInfo(y),o.disposeIntermediateTensorInfo(k),o.disposeIntermediateTensorInfo(R),o.disposeIntermediateTensorInfo(E),o.disposeIntermediateTensorInfo(T),o.disposeIntermediateTensorInfo(D),o.disposeIntermediateTensorInfo(B),o.disposeIntermediateTensorInfo(O),o.disposeIntermediateTensorInfo(L),o.disposeIntermediateTensorInfo(z),o.disposeIntermediateTensorInfo(H),o.disposeIntermediateTensorInfo(G),o.disposeIntermediateTensorInfo(q),o.disposeIntermediateTensorInfo(K),o.disposeIntermediateTensorInfo(j),o.disposeIntermediateTensorInfo(Q),o.disposeIntermediateTensorInfo(Y),o.disposeIntermediateTensorInfo(J),o.disposeIntermediateTensorInfo(Z),o.disposeIntermediateTensorInfo(ee),{real:te,imag:ne}}const Ce={kernelName:r.FFT,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:s}=t,o=r.util.sizeFromShape(s.shape),a=s.shape[s.shape.length-1],i=H({inputs:{x:s},backend:n,attrs:{shape:[o/a,a]}}),u=we(i,!1,n),l=H({inputs:{x:u},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),l}},$e={kernelName:r.FlipLeftRight,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:s}=e,o=n,a=r.util.getTypedArrayFromDType(s.dtype,r.util.sizeFromShape(s.shape)),[i,u,l,c]=s.shape,d=o.data.get(s.dataId).values;for(let e=0;e<i;e++){const t=e*l*u*c;for(let e=0;e<u;e++){const n=e*(l*c);for(let r=0;r<l;r++){const s=r*c;for(let o=0;o<c;o++){const u=[i,e,r,o][2],h=Math.round(l-u),p=t+n+s+o;let f=d[p];h>=0&&h<l&&(f=d[t+n+h*c+o]),a[p]=f}}}}return{dataId:o.write(a,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};var Se=n(76574);const Re={kernelName:r.IFFT,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:s}=t,o=r.util.sizeFromShape(s.shape),a=s.shape[s.shape.length-1],i=H({inputs:{x:s},backend:n,attrs:{shape:[o/a,a]}}),u=we(i,!0,n),l=H({inputs:{x:u},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),l}},Ee=(0,g.A)(r.IsFinite,(e=>Number.isFinite(e)?1:0),"bool"),Te={kernelName:r.IsFinite,backendName:"cpu",kernelFunc:Ee},Ae=(0,g.A)(r.IsInf,(e=>Math.abs(e)===1/0?1:0),"bool"),_e={kernelName:r.IsInf,backendName:"cpu",kernelFunc:Ae},Ne=(0,g.A)(r.IsNan,(e=>Number.isNaN(e)?1:0),"bool"),Fe={kernelName:r.IsNan,backendName:"cpu",kernelFunc:Ne};var De=n(55223);const Be=(0,g.A)(r.Log1p,(e=>Math.log1p(e))),Oe={kernelName:r.Log1p,backendName:"cpu",kernelFunc:Be},Me=(0,g.A)(r.LogicalNot,(e=>e?0:1),"bool"),Pe={kernelName:r.LogicalNot,backendName:"cpu",kernelFunc:Me};var Le=n(55126),Ve=n(77107);const We={kernelName:r.Max,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:s}=e,{reductionIndices:a,keepDims:i}=t,u=n;let l=s.shape;const c=l.length,d=r.util.parseAxisParam(a,l);let h=d;const p=r.backend_util.getAxesPermutation(h,c);let f=u.data.get(s.dataId).values;if(null!=p){const e=new Array(c);for(let t=0;t<e.length;t++)e[t]=l[p[t]];f=(0,Ve.H)(f,l,s.dtype,p,e),h=r.backend_util.getInnerMostAxes(h.length,c),l=e}(0,o.H)(s,"max"),r.backend_util.assertAxesAreInnerMostDims("max",h,c);const[m,g]=r.backend_util.computeOutAndReduceShapes(l,h),x=r.util.sizeFromShape(g),v=(0,Le.B)(f,x,m,s.dtype),b=u.write(v,m,s.dtype);let y=m;return i&&(y=r.backend_util.expandShapeToKeepDim(m,d)),{dataId:b,shape:y,dtype:s.dtype}}},ze={kernelName:r.MaxPool,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:a}=t;(0,o.H)(a,"maxPool");const{filterSize:i,strides:u,pad:l,dimRoundingMode:c}=s;r.util.assert(r.backend_util.eitherStridesOrDilationsAreOne(u,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${u} and dilations '1'`));const d=r.backend_util.computePool2DInfo(a.shape,i,u,1,l,c);let h;if(1===d.filterWidth&&1===d.filterHeight&&r.util.arraysEqual(d.inShape,d.outShape))h=(0,N.y)({inputs:{x:a},backend:n});else{const e=n.data.get(a.dataId).values,t=r.util.computeStrides(a.shape),s=A(e,a.shape,a.dtype,t,d,"max");h=n.makeTensorInfo(d.outShape,a.dtype,s.values)}return h}},Ue={kernelName:r.MaxPoolBackprop,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:a,input:i,output:u}=t,l=i;(0,o.H)([i,u],"maxPoolBackprop");const{filterSize:c,strides:d,pad:h,dimRoundingMode:p}=s,f=r.backend_util.computePool2DInfo(l.shape,c,d,1,h,p),m=n.data.get(l.dataId).values,g=(0,r.buffer)(f.outShape,l.dtype,_(m,l.shape,l.dtype,f).values),x=f.strideHeight,v=f.strideWidth,b=f.dilationHeight,y=f.dilationWidth,w=f.effectiveFilterHeight,k=f.effectiveFilterWidth,I=k-1-f.padInfo.left,C=w-1-f.padInfo.top,$=(0,r.buffer)(l.shape,"float32"),S=n.data.get(a.dataId).values,R=(0,r.buffer)(a.shape,"float32",S);for(let e=0;e<f.batchSize;++e)for(let t=0;t<f.inChannels;++t)for(let n=0;n<f.inHeight;++n)for(let r=0;r<f.inWidth;++r){const s=n-C,o=r-I;let a=0;for(let n=0;n<w;n+=b){const r=(s+n)/x;if(!(r<0||r>=f.outHeight||Math.floor(r)!==r))for(let s=0;s<k;s+=y){const i=(o+s)/v;if(i<0||i>=f.outWidth||Math.floor(i)!==i)continue;const u=w*k-1-g.get(e,r,i,t)===n*k+s?1:0;0!==u&&(a+=R.get(e,r,i,t)*u)}}$.set(a,e,n,r,t)}return n.makeTensorInfo($.shape,$.dtype,$.values)}},He={kernelName:r.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:s}=e,{filterSize:a,strides:i,pad:u,includeBatchInIndex:l}=t,c=n;(0,o.H)(s,"MaxPoolWithArgmax");const d=c.data.get(s.dataId).values,h=r.backend_util.computePool2DInfo(s.shape,a,i,[1,1],u),[p,f]=function(e,t,n,s,o){const a=A(e,0,n,r.util.computeStrides(t),o,"max"),i=_(e,t,n,o,!0,s);return[a.values,i.values]}(d,s.shape,s.dtype,l,h),m=c.write(p,h.outShape,s.dtype),g=c.write(f,h.outShape,s.dtype);return[{dataId:m,shape:h.outShape,dtype:s.dtype},{dataId:g,shape:h.outShape,dtype:"int32"}]}},Ge=r.kernel_impls.nonMaxSuppressionV4Impl,Xe={kernelName:r.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{boxes:r,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:l}=n,c=t;(0,o.H)(r,"NonMaxSuppressionPadded");const d=c.data.get(r.dataId).values,h=c.data.get(s.dataId).values,{selectedIndices:p,validOutputs:f}=Ge(d,h,a,i,u,l);return[p,f]}},qe=r.kernel_impls.nonMaxSuppressionV5Impl,Ke={kernelName:r.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{boxes:r,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=n,c=t;(0,o.H)(r,"NonMaxSuppressionWithScore");const d=c.data.get(r.dataId).values,h=c.data.get(s.dataId).values,p=a,f=i,m=u,g=l,{selectedIndices:x,selectedScores:v}=qe(d,h,p,f,m,g);return[x,v]}},je=(0,te.b)(((e,t)=>e!==t?1:0)),Ye=(0,ne.j)(r.NotEqual,je,null,"bool"),Qe={kernelName:r.NotEqual,backendName:"cpu",kernelFunc:Ye},Je={kernelName:r.PadV2,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:a}=t,{paddings:i,constantValue:u}=s;(0,o.H)(a,"pad");const l=i.map(((e,t)=>e[0]+a.shape[t]+e[1])),c=i.map((e=>e[0])),d=n.data.get(a.dataId).values,h=r.util.sizeFromShape(a.shape),p=a.shape.length,f=r.util.computeStrides(a.shape),m=r.util.sizeFromShape(l),g=l.length,x=r.util.computeStrides(l),v=r.util.getTypedArrayFromDType(a.dtype,m);0!==u&&v.fill(u);for(let e=0;e<h;e++){const t=r.util.indexToLoc(e,p,f).map(((e,t)=>e+c[t]));v[r.util.locToIndex(t,g,x)]=d[e]}return{dataId:n.write(v,l,a.dtype),shape:l,dtype:a.dtype}}},Ze=(0,g.A)(r.Reciprocal,(e=>1/e)),et={kernelName:r.Reciprocal,backendName:"cpu",kernelFunc:Ze},tt={kernelName:r.RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:s}=e,{radians:o,fillValue:a,center:i}=t,u=n,l=r.util.getTypedArrayFromDType(s.dtype,r.util.sizeFromShape(s.shape)),[c,d,h,p]=s.shape,[f,m]=r.backend_util.getImageCenter(i,d,h),g=Math.sin(o),x=Math.cos(o),v=u.data.get(s.dataId).values;for(let e=0;e<c;e++){const t=e*h*d*p;for(let e=0;e<d;e++){const n=e*(h*p);for(let r=0;r<h;r++){const s=r*p;for(let o=0;o<p;o++){const i=[c,e,r,o],u=i[2],b=i[1];let y=(u-f)*x-(b-m)*g,w=(u-f)*g+(b-m)*x;y=Math.round(y+f),w=Math.round(w+m);let k=a;"number"!=typeof a&&(k=3===o?255:a[o]),y>=0&&y<h&&w>=0&&w<d&&(k=v[t+w*(h*p)+y*p+o]),l[t+n+s+o]=k}}}}return{dataId:u.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},nt=(0,g.A)(r.Round,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1})),rt={kernelName:r.Round,backendName:"cpu",kernelFunc:nt};var st=n(7742);const ot=r.backend_util.SELU_SCALEALPHA,at=r.backend_util.SELU_SCALE,it=(0,g.A)(r.Selu,(e=>e>=0?at*e:ot*(Math.exp(e)-1))),ut={kernelName:r.Selu,backendName:"cpu",kernelFunc:it},lt=(0,g.A)(r.Sigmoid,(e=>1/(1+Math.exp(-e)))),ct={kernelName:r.Sigmoid,backendName:"cpu",kernelFunc:lt},dt=(0,g.A)(r.Sign,(e=>e<0?-1:e>0?1:0)),ht={kernelName:r.Sign,backendName:"cpu",kernelFunc:dt},pt=(0,g.A)(r.Sin,(e=>Math.sin(e))),ft={kernelName:r.Sin,backendName:"cpu",kernelFunc:pt},mt=(0,g.A)(r.Sinh,(e=>Math.sinh(e))),gt={kernelName:r.Sinh,backendName:"cpu",kernelFunc:mt},xt=Math.log(1.1920928955078125e-7)+2,vt=(0,g.A)(r.Softplus,(e=>{const t=e>-xt,n=e<xt,r=Math.exp(e);let s;return s=n?r:t?e:Math.log(1+r),s})),bt={kernelName:r.Softplus,backendName:"cpu",kernelFunc:vt};function yt(e){const{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;(0,o.H)(s,"transpose");const i=s.shape.length,u=new Array(i);for(let e=0;e<u.length;e++)u[e]=s.shape[a[e]];const l=r.data.get(s.dataId).values,c=(0,Ve.H)(l,s.shape,s.dtype,a,u);return{dataId:r.write(c,u,s.dtype),shape:u,dtype:s.dtype}}const wt={kernelName:r.Transpose,backendName:"cpu",kernelFunc:yt},kt={kernelName:r.SpaceToBatchND,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:a}=t,{blockShape:i,paddings:u}=s;(0,o.H)([a],"spaceToBatchND");const l=r.util.sizeFromShape(i),c=[[0,0]];c.push(...u);for(let e=1+i.length;e<a.shape.length;++e)c.push([0,0]);const d=Je.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:c,constantValue:0}}),h=r.backend_util.getReshaped(d.shape,i,l,!1),p=r.backend_util.getPermuted(h.length,i.length,!1),f=r.backend_util.getReshapedPermuted(d.shape,i,l,!1),m=H({inputs:{x:d},backend:n,attrs:{shape:h}}),g=yt({inputs:{x:m},backend:n,attrs:{perm:p}}),x=H({inputs:{x:g},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),x}},It=(0,g.A)(r.Sqrt,(e=>Math.sqrt(e))),Ct={kernelName:r.Sqrt,backendName:"cpu",kernelFunc:It},$t={kernelName:r.Square,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t;(0,o.H)(n,"square");const s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let e=0;e<s.length;++e){const t=s[e];a[e]=t*t}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},St=(0,te.b)(((e,t)=>{const n=e-t;return n*n})),Rt=(0,ne.j)(r.SquaredDifference,St),Et={kernelName:r.SquaredDifference,backendName:"cpu",kernelFunc:Rt},Tt=(0,g.A)(r.Step,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),At={kernelName:r.Step,backendName:"cpu",kernelFunc:Tt},_t=(0,g.A)(r.Tan,(e=>Math.tan(e))),Nt={kernelName:r.Tan,backendName:"cpu",kernelFunc:_t},Ft=(0,g.A)(r.Tanh,(e=>Math.tanh(e))),Dt={kernelName:r.Tanh,backendName:"cpu",kernelFunc:Ft};var Bt=n(75638);const Ot={kernelName:r.Unique,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;(0,o.H)(a,"unique");const i=r.data.get(a.dataId).values,{outputValues:u,outputShape:l,indices:c}=(0,Bt.S)(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,u),r.makeTensorInfo([c.length],"int32",c)]}},Mt=[m.fC,v,y,w.j4,I,$,R,T,F,D,B,O.M,M.y2,L,V.z,q,j,Q,J,ee,Z,oe,ie,me,ge.SX,xe.Vu,Ce,$e,Se.Ao,N.I,Re,z,Te,_e,Fe,De.xM,Oe,Pe,ze,Ue,He,We,ve.f$,Xe,Ke,Qe,Je,U.O,et,G,tt,rt,st.FY,ut,ct,ht,ft,gt,be.C6,bt,kt,Ct,$t,Et,At,ye.GR,Nt,Dt,wt,Ot];for(const e of Mt)(0,r.registerKernel)(e)},60224:(e,t,n)=>{"use strict";n.d(t,{bk:()=>s,fC:()=>o});var r=n(6639);function s(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const o={kernelName:r.Abs,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;let o=new Float32Array(r.util.sizeFromShape(t.shape));if("complex64"!==t.dtype)o=s(n.data.get(t.dataId).values);else{const e=n.data.get(t.dataId),r=e.complexTensorInfos.real,s=e.complexTensorInfos.imag,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values;for(let e=0;e<a.length;e++){const t=a[e],n=i[e];o[e]=Math.hypot(t,n)}}return n.makeOutput(o,t.shape,"float32")}}},32779:(e,t,n)=>{"use strict";n.d(t,{EH:()=>a,IH:()=>u,j4:()=>l});var r=n(6639),s=n(33533),o=n(90546);const a=(0,s.b)(((e,t)=>e+t)),i=(0,o.H)(((e,t,n,r)=>({real:e+n,imag:t+r}))),u=(0,o.j)(r.Add,a,i),l={kernelName:r.Add,backendName:"cpu",kernelFunc:u}},29258:(e,t,n)=>{"use strict";n.d(t,{p:()=>u,M:()=>l});var r=n(6639),s=n(33533),o=n(26961),a=n(41775),i=n(82186);function u(e){const{inputs:t,backend:n,attrs:l}=e,{x:c}=t,{dtype:d}=l;if("complex64"===d){if("complex64"===c.dtype)return(0,a.y)({inputs:{x:c},backend:n});const e=r.zeros(c.shape),t=u({inputs:{x:c},backend:n,attrs:{dtype:"float32"}}),s=(0,o.P)({inputs:{real:t,imag:e},backend:n});return e.dispose(),n.disposeIntermediateTensorInfo(t),s}if("complex64"===c.dtype){const e=(0,i.k)({inputs:{input:c},backend:n}),t=u({inputs:{x:e},backend:n,attrs:{dtype:d}});return n.disposeIntermediateTensorInfo(e),t}if(!r.util.hasEncodingLoss(c.dtype,d)){const e=(0,a.y)({inputs:{x:c},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:d}}if("int32"===d){const e=n.data.get(c.dataId).values,t=Int32Array.from(e);return n.makeTensorInfo(c.shape,"int32",t)}if("bool"===d){const e=n.data.get(c.dataId).values,t=r.util.toTypedArray([0],c.dtype),[o,a]=(0,s.b)(((e,t)=>e!==t?1:0))(c.shape,[],e,t,"bool");return n.makeTensorInfo(a,"bool",o)}throw new Error(`Error in Cast: failed to cast ${c.dtype} to ${d}`)}const l={kernelName:r.Cast,backendName:"cpu",kernelFunc:u}},34769:(e,t,n)=>{"use strict";n.d(t,{__:()=>a,y2:()=>u});var r=n(6639),s=n(18029),o=n(76738);const a=(0,s.a)((e=>Math.ceil(e))),i=(0,o.O)(r.Ceil,a),u={kernelName:r.Ceil,backendName:"cpu",kernelFunc:i}},26961:(e,t,n)=>{"use strict";function r(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,o=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values,i=n.makeTensorInfo(r.shape,"complex64");return n.data.get(i.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",o),imag:n.makeTensorInfo(s.shape,"float32",a)},i}n.d(t,{P:()=>r,z:()=>s});const s={kernelName:n(6639).Complex,backendName:"cpu",kernelFunc:r}},31211:(e,t,n)=>{"use strict";n.d(t,{Ro:()=>a,SX:()=>u});var r=n(6639),s=n(18029),o=n(76738);const a=(0,s.a)((e=>Math.exp(e))),i=(0,o.O)(r.Exp,a),u={kernelName:r.Exp,backendName:"cpu",kernelFunc:i}},30969:(e,t,n)=>{"use strict";n.d(t,{OF:()=>a,Vu:()=>u});var r=n(6639),s=n(18029),o=n(76738);const a=(0,s.a)((e=>Math.expm1(e))),i=(0,o.O)(r.Expm1,a),u={kernelName:r.Expm1,backendName:"cpu",kernelFunc:i}},76574:(e,t,n)=>{"use strict";n.d(t,{r6:()=>a,Ao:()=>u});var r=n(6639),s=n(18029),o=n(76738);const a=(0,s.a)((e=>Math.floor(e))),i=(0,o.O)(r.Floor,a),u={kernelName:r.Floor,backendName:"cpu",kernelFunc:i}},41775:(e,t,n)=>{"use strict";function r(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}n.d(t,{y:()=>r,I:()=>s});const s={kernelName:n(6639).Identity,backendName:"cpu",kernelFunc:r}},55223:(e,t,n)=>{"use strict";n.d(t,{vX:()=>a,xM:()=>u});var r=n(6639),s=n(18029),o=n(76738);const a=(0,s.a)((e=>Math.log(e))),i=(0,o.O)(r.Log,a),u={kernelName:r.Log,backendName:"cpu",kernelFunc:i}},55126:(e,t,n)=>{"use strict";n.d(t,{B:()=>s});var r=n(6639);function s(e,t,n,s){const o=r.util.getTypedArrayFromDType(s,r.util.sizeFromShape(n));for(let n=0;n<o.length;++n){const r=n*t;let s=e[r];for(let n=0;n<t;++n){const t=e[r+n];t>s&&(s=t)}o[n]=s}return o}},1917:(e,t,n)=>{"use strict";n.d(t,{$3:()=>a,Jp:()=>u,f$:()=>l});var r=n(6639),s=n(33533),o=n(90546);const a=(0,s.b)(((e,t)=>e*t)),i=(0,o.H)(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),u=(0,o.j)(r.Multiply,a,i),l={kernelName:r.Multiply,backendName:"cpu",kernelFunc:u}},82186:(e,t,n)=>{"use strict";function r(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,o=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,o)}n.d(t,{k:()=>r,O:()=>s});const s={kernelName:n(6639).Real,backendName:"cpu",kernelFunc:r}},7742:(e,t,n)=>{"use strict";n.d(t,{zd:()=>a,FY:()=>u});var r=n(6639),s=n(18029),o=n(76738);const a=(0,s.a)((e=>1/Math.sqrt(e))),i=(0,o.O)(r.Rsqrt,a),u={kernelName:r.Rsqrt,backendName:"cpu",kernelFunc:i}},82578:(e,t,n)=>{"use strict";n.d(t,{rT:()=>o,tP:()=>a,C6:()=>i});var r=n(6639),s=n(18166);function o(e,t,n,s,o){const a=r.slice_util.isSliceContinous(s,t,n),i=r.util.sizeFromShape(n),u=r.util.computeStrides(s);if(a){const n=r.slice_util.computeFlatOffset(t,u);return e.subarray(n,n+i)}const l=r.util.getTypedArrayFromDType(o,i);for(let o=0;o<i;++o){const a=n.length,i=r.util.computeStrides(n),c=r.util.indexToLoc(o,a,i).map(((e,n)=>e+t[n])),d=r.util.locToIndex(c,s.length,u);l[o]=e[d]}return l}function a(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t,{begin:u,size:l}=a;(0,s.H)(i,"slice");const[c,d]=r.slice_util.parseSliceParams(i,u,l);r.slice_util.assertParamsValid(i,c,d);const h=o(n.data.get(i.dataId).values,c,d,i.shape,i.dtype);return n.makeTensorInfo(d,i.dtype,h)}const i={kernelName:r.Slice,backendName:"cpu",kernelFunc:a}},71649:(e,t,n)=>{"use strict";n.d(t,{VY:()=>a,lu:()=>u,GR:()=>l});var r=n(6639),s=n(33533),o=n(90546);const a=(0,s.b)(((e,t)=>e-t)),i=(0,o.H)(((e,t,n,r)=>({real:e-n,imag:t-r}))),u=(0,o.j)(r.Sub,a,i),l={kernelName:r.Sub,backendName:"cpu",kernelFunc:u}},77107:(e,t,n)=>{"use strict";n.d(t,{H:()=>s});var r=n(6639);function s(e,t,n,s,o){const a=t.length,i=r.util.sizeFromShape(t),u=r.util.computeStrides(t),l=r.util.computeStrides(o),c=r.util.getTypedArrayFromDType(n,r.util.sizeFromShape(o));for(let t=0;t<i;++t){const n=r.util.indexToLoc(t,a,u),o=new Array(n.length);for(let e=0;e<o.length;e++)o[e]=n[s[e]];c[r.util.locToIndex(o,a,l)]=e[t]}return c}},75638:(e,t,n)=>{"use strict";n.d(t,{S:()=>s});var r=n(6639);function s(e,t,n,s){const o=r.util.parseAxisParam(t,n)[0],a=[1,n[0],1];for(let e=0;e<o;e++)a[0]*=n[e];a[1]=n[o];for(let e=o+1;e<n.length;e++)a[2]*=n[e];const i={},u=new Int32Array(n[o]),l=new r.TensorBuffer(a,s,e),c=[],d=1===a[0]&&1===a[2];for(let t=0;t<n[o];t++){let n;if(d)n=e[t].toString();else{const e=[];for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)e.push(l.get(n,t,r));n=e.join(",")}if(void 0!==i[n])u[t]=i[n];else{const e=Object.keys(i).length;i[n]=e,u[t]=e,c.push(t)}}const h=a.slice();h[1]=Object.keys(i).length;const p=new r.TensorBuffer(h,s);c.forEach(((e,t)=>{for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)p.set(l.get(n,e,r),n,t,r)}));const f=n.slice();return f[o]=h[1],{outputValues:p.values,outputShape:f,indices:u}}},45226:(e,t,n)=>{"use strict";n.r(t),n.d(t,{simpleAbsImpl:()=>r.bk,addImpl:()=>s.EH,ceilImpl:()=>o.__,expImpl:()=>a.Ro,expm1Impl:()=>i.OF,floorImpl:()=>u.r6,logImpl:()=>l.vX,maxImpl:()=>c.B,multiplyImpl:()=>d.$3,rsqrtImpl:()=>h.zd,sliceImpl:()=>p.rT,subImpl:()=>f.VY,transposeImpl:()=>m.H,uniqueImpl:()=>g.S});var r=n(60224),s=n(32779),o=n(34769),a=n(31211),i=n(30969),u=n(76574),l=n(55223),c=n(55126),d=n(1917),h=n(7742),p=n(82578),f=n(71649),m=n(77107),g=n(75638)},33533:(e,t,n)=>{"use strict";n.d(t,{b:()=>s});var r=n(6639);function s(e){return(t,n,s,o,a)=>{const i=r.backend_util.assertAndGetBroadcastShape(t,n),u=i.length,l=r.util.computeStrides(i),c=r.util.sizeFromShape(i),d=r.util.getTypedArrayFromDType(a,c),h=t.length,p=n.length,f=r.util.computeStrides(t),m=r.util.computeStrides(n),g=r.backend_util.getBroadcastDims(t,i),x=r.backend_util.getBroadcastDims(n,i);if(g.length+x.length===0)for(let t=0;t<d.length;++t)d[t]=e(s[t%s.length],o[t%o.length]);else for(let t=0;t<d.length;++t){const n=r.util.indexToLoc(t,u,l),a=n.slice(-h);g.forEach((e=>a[e]=0));const i=r.util.locToIndex(a,h,f),c=n.slice(-p);x.forEach((e=>c[e]=0));const v=r.util.locToIndex(c,p,m);d[t]=e(s[i],o[v])}return[d,i]}}},90546:(e,t,n)=>{"use strict";n.d(t,{j:()=>i,H:()=>u});var r=n(6639),s=n(18166),o=n(29258),a=n(26961);function i(e,t,n,r){return null==n?({inputs:n,backend:o})=>{const{a,b:i}=n,u=o;(0,s.H)([a,i],e);const l=u.data.get(a.dataId).values,c=u.data.get(i.dataId).values,d=r||a.dtype,[h,p]=t(a.shape,i.shape,l,c,d);return u.makeTensorInfo(p,d,h)}:({inputs:e,backend:s})=>{const{a:i,b:u}=e,l=s;if("complex64"===i.dtype||"complex64"===u.dtype){const e=(0,o.p)({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),t=l.data.get(e.dataId),r=t.complexTensorInfos.real,s=t.complexTensorInfos.imag,c=l.data.get(r.dataId).values,d=l.data.get(s.dataId).values,h=(0,o.p)({inputs:{x:u},backend:l,attrs:{dtype:"complex64"}}),p=l.data.get(h.dataId),f=p.complexTensorInfos.real,m=p.complexTensorInfos.imag,g=l.data.get(f.dataId).values,x=l.data.get(m.dataId).values,[v,b,y]=n(i.shape,u.shape,c,d,g,x),w=l.makeTensorInfo(y,"float32",v),k=l.makeTensorInfo(y,"float32",b),I=(0,a.P)({inputs:{real:w,imag:k},backend:l});return l.disposeIntermediateTensorInfo(e),l.disposeIntermediateTensorInfo(h),l.disposeIntermediateTensorInfo(w),l.disposeIntermediateTensorInfo(k),I}{const e=l.data.get(i.dataId).values,n=l.data.get(u.dataId).values,s=r||i.dtype,[o,a]=t(i.shape,u.shape,e,n,s);return l.makeTensorInfo(a,s,o)}}}function u(e){return(t,n,s,o,a,i)=>{const u=r.backend_util.assertAndGetBroadcastShape(t,n),l=r.util.sizeFromShape(u),c=u.length,d=r.util.computeStrides(u),h=r.util.getTypedArrayFromDType("float32",l),p=r.util.getTypedArrayFromDType("float32",l),f=r.backend_util.getBroadcastDims(t,u),m=r.backend_util.getBroadcastDims(n,u),g=r.backend_util.mergeRealAndImagArrays(s,o),x=r.backend_util.mergeRealAndImagArrays(a,i),v=t.length,b=r.util.computeStrides(t),y=n.length,w=r.util.computeStrides(n);if(f.length+m.length===0)for(let t=0;t<h.length;t++){const n=t%g.length,r=t%x.length,s=e(g[2*n],g[2*n+1],x[2*r],x[2*r+1]);h[t]=s.real,p[t]=s.imag}else for(let t=0;t<h.length;t++){const n=r.util.indexToLoc(t,c,d),s=n.slice(-v);f.forEach((e=>s[e]=0));const o=r.util.locToIndex(s,v,b),a=n.slice(-y);m.forEach((e=>a[e]=0));const i=r.util.locToIndex(a,y,w),u=e(g[2*o],g[2*o+1],x[2*i],x[2*i+1]);h[t]=u.real,p[t]=u.imag}return[h,p,u]}}},18029:(e,t,n)=>{"use strict";n.d(t,{a:()=>s});var r=n(6639);function s(e){return(t,n,s)=>{const o=r.util.getTypedArrayFromDType(n,t.length);for(let n=0;n<t.length;++n)o[n]=e(t[n],s);return o}}},76738:(e,t,n)=>{"use strict";n.d(t,{A:()=>o,O:()=>a});var r=n(6639),s=n(18166);function o(e,t,n){return({inputs:o,attrs:a,backend:i})=>{const{x:u}=o;if((0,s.H)(u,e),"string"===u.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const l=i,c=l.data.get(u.dataId).values,d=r.util.sizeFromShape(u.shape),h=n||u.dtype,p=r.util.getArrayFromDType(h,d);for(let e=0;e<d;++e)p[e]=t(c[e],a);return l.makeTensorInfo(u.shape,h,p)}}function a(e,t,n){return({inputs:r,attrs:o,backend:a})=>{const{x:i}=r;if((0,s.H)(i,e),"string"===i.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const u=a,l=u.data.get(i.dataId).values,c=n||i.dtype,d=t(l,c,o);return u.makeTensorInfo(i.shape,c,d)}}},33935:(e,t,n)=>{"use strict";n.r(t),n.d(t,{GPGPUContext:()=>un,MathBackendWebGL:()=>gr,forceHalfFloat:()=>vr,gpgpu_util:()=>s,setWebGLContext:()=>u,version_webgl:()=>xr,webgl:()=>br,webgl_util:()=>r});var r={};n.r(r),n.d(r,{assertNotComplex:()=>de,bindCanvasToFramebuffer:()=>L,bindColorTextureToFramebuffer:()=>V,bindTextureToProgramUniformSampler:()=>P,bindTextureUnit:()=>D,bindVertexBufferToProgramAttribute:()=>F,callAndCheck:()=>x,canBeRepresented:()=>v,createFragmentShader:()=>k,createFramebuffer:()=>N,createProgram:()=>C,createStaticIndexBuffer:()=>E,createStaticVertexBuffer:()=>R,createTexture:()=>A,createVertexShader:()=>w,getBatchDim:()=>X,getExtensionOrThrow:()=>y,getFramebufferErrorMessage:()=>U,getMaxTexturesInShader:()=>re,getNumChannels:()=>T,getProgramUniformLocation:()=>M,getProgramUniformLocationOrThrow:()=>O,getRowsCols:()=>q,getShapeAs3D:()=>K,getTextureShapeFromLogicalShape:()=>j,getWebGLDisjointQueryTimerVersion:()=>se,getWebGLErrorMessage:()=>b,getWebGLMaxTextureSize:()=>ee,hasExtension:()=>oe,isCapableOfRenderingToFloatTexture:()=>ie,isDownloadFloatTextureEnabled:()=>ue,isReshapeFree:()=>Q,isWebGLFenceEnabled:()=>ce,isWebGLVersionEnabled:()=>ae,linkProgram:()=>$,resetMaxTextureSize:()=>te,resetMaxTexturesInShader:()=>ne,unbindColorTextureFromFramebuffer:()=>W,unbindTextureUnit:()=>B,validateFramebuffer:()=>z,validateProgram:()=>S,validateTextureSize:()=>_});var s={};n.r(s),n.d(s,{bindVertexProgramAttributeStreams:()=>Zt,createBufferFromOutputTexture:()=>nn,createFloat16MatrixTexture:()=>Xt,createFloat16PackedMatrixTexture:()=>Jt,createFloat32MatrixTexture:()=>Ht,createIndexBuffer:()=>Wt,createPackedMatrixTexture:()=>Yt,createUnsignedBytesMatrixTexture:()=>Kt,createVertexBuffer:()=>Vt,createVertexShader:()=>Lt,downloadByteEncodedFloatMatrixFromOutputTexture:()=>sn,downloadFloat32MatrixFromBuffer:()=>rn,downloadMatrixFromPackedOutputTexture:()=>an,downloadPackedMatrixFromBuffer:()=>on,getInternalFormatForFloat16MatrixTexture:()=>Gt,getInternalFormatForFloat16PackedMatrixTexture:()=>Qt,getInternalFormatForFloat32MatrixTexture:()=>Ut,getInternalFormatForPackedMatrixTexture:()=>jt,getInternalFormatForUnsignedBytesMatrixTexture:()=>qt,uploadDenseMatrixToTexture:()=>en,uploadPixelDataToTexture:()=>tn});var o=n(6639);const a={},i={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function u(e,t){a[e]=t}function l(e){if(!(e in a)){const t=function(e){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e);return t.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete a[e]}),!1),1===e?t.getContext("webgl",i)||t.getContext("experimental-webgl",i):t.getContext("webgl2",i)}(e);if(null===t)return console.log("Could not get context for WebGL version",e),null;a[e]=t}const t=a[e];return t.isContextLost()?(delete a[e],l(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),a[e])}var c,d,h;function p(e,t){return[t,e]}function f(e){const t=o.util.sizeFromShape(e),n=Math.ceil(t/4);return o.util.sizeToSquarishShape(n)}function m(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function g(e,t){const n=e;let r,s,a,i,u,l,c,d,h,p;return 2===(0,o.env)().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,u=n.RED,c=4,d=1,h=n.HALF_FLOAT,p=n.FLOAT):(r=e.RGBA,s=e.RGBA,a=e.RGBA,i=n.RGBA,u=e.RGBA,c=4,d=4,h=null!=t?t.HALF_FLOAT_OES:null,p=e.FLOAT),l=e.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:u,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:d,textureTypeHalfFloat:h,textureTypeFloat:p}}function x(e,t){const n=t();return(0,o.env)().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+b(e,t))}(e),n}function v(e){return!!((0,o.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function b(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+t}}function y(e,t){return H(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function w(e,t){const n=H(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(x(e,(()=>e.shaderSource(n,t))),x(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function k(e,t){const n=H(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(x(e,(()=>e.shaderSource(n,t))),x(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw function(e,t){const n=I.exec(t);if(null==n)return console.log("Couldn't parse line number in error: "+t),void console.log(e);const r=+n[1],s=e.split("\n"),a=s.length.toString().length+2,i=s.map(((e,t)=>o.util.rightPad((t+1).toString(),a)+e));let u=0;for(let e=0;e<i.length;e++)u=Math.max(i[e].length,u);const l=i.slice(0,r-1),c=i.slice(r-1,r),d=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log("%c "+o.util.rightPad(c[0],u),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join("\n"))}(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(c||(c={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(d||(d={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(h||(h={}));const I=/ERROR: [0-9]+:([0-9]+):/g;function C(e){return H(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function $(e,t){if(x(e,(()=>e.linkProgram(t))),!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function S(e,t){if(x(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function R(e,t){const n=H(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return x(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),x(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function E(e,t){const n=H(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return x(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),x(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function T(){return 2===(0,o.env)().getNumber("WEBGL_VERSION")?1:4}function A(e){return H(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function _(e,t){const n=(0,o.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}function N(e){return H(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function F(e,t,n,r,s,o,a){const i=e.getAttribLocation(t,n);return-1!==i&&(x(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),x(e,(()=>e.vertexAttribPointer(i,s,e.FLOAT,!1,o,a))),x(e,(()=>e.enableVertexAttribArray(i))),!0)}function D(e,t,n){G(e,n),x(e,(()=>e.activeTexture(e.TEXTURE0+n))),x(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function B(e,t){G(e,t),x(e,(()=>e.activeTexture(e.TEXTURE0+t))),x(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function O(e,t,n){return H(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}function M(e,t,n){return e.getUniformLocation(t,n)}function P(e,t,n,r){x(e,(()=>D(e,t,r))),x(e,(()=>e.uniform1i(n,r)))}function L(e){x(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),x(e,(()=>e.viewport(0,0,e.canvas.width,e.canvas.height))),x(e,(()=>e.scissor(0,0,e.canvas.width,e.canvas.height)))}function V(e,t,n){x(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),x(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function W(e,t){x(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),x(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function z(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+U(e,t))}function U(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+t}}function H(e,t,n){const r=x(e,(()=>t()));if(null==r)throw new Error(n);return r}function G(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)}function X(e,t=2){return o.util.sizeFromShape(e.slice(0,e.length-t))}function q(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function K(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[X(e),...q(e)]),t}function j(e,t=!1){let n=(0,o.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t&&(n*=2,1===(e=e.map(((t,n)=>n>=e.length-2?o.util.nearestLargerEven(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=o.util.squeezeShape(e);e=t.newShape}let r=o.util.sizeFromShape(e);if(e.length<=1&&r<=n)return[1,r];if(2===e.length&&e[0]<=n&&e[1]<=n)return e;if(3===e.length&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){const t=X(e);let n=2,s=2;return e.length&&([n,s]=q(e)),r=t*(n/2)*(s/2),o.util.sizeToSquarishShape(r).map((e=>2*e))}return o.util.sizeToSquarishShape(r)}function Y(e){return e%2==0}function Q(e,t){if(e=e.slice(-2),t=t.slice(-2),o.util.arraysEqual(e,t))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r)return!0;if(Y(n)&&Y(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&Y(e[0])&&Y(t[0])}let J,Z;function ee(e){if(null==J){const t=l(e);J=t.getParameter(t.MAX_TEXTURE_SIZE)}return J}function te(){J=null}function ne(){Z=null}function re(e){if(null==Z){const t=l(e);Z=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Z)}function se(e){if(0===e)return 0;let t;const n=l(e);return t=oe(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:oe(n,"EXT_disjoint_timer_query")?1:0,t}function oe(e,t){return null!=e.getExtension(t)}function ae(e){try{if(null!=l(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function ie(e){if(0===e)return!1;const t=l(e);if(1===e){if(!oe(t,"OES_texture_float"))return!1}else if(!oe(t,"EXT_color_buffer_float"))return!1;return le(t)}function ue(e){if(0===e)return!1;const t=l(e);if(1!==e){if(oe(t,"EXT_color_buffer_float"))return le(t);const e="EXT_color_buffer_half_float";if(oe(t,e)){const n=t.getExtension(e);return function(e,t){const n=g(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(s),o}(t,n)}return!1}return!!oe(t,"OES_texture_float")&&(!!oe(t,"WEBGL_color_buffer_float")&&le(t))}function le(e){const t=g(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),s}function ce(e){return 2===e&&null!=l(e).fenceSync}function de(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&o.util.assert("complex64"!==e.dtype,(()=>t+" does not support complex64 tensors in the WebGL backend."))}))}const he=(0,o.env)();he.registerFlag("HAS_WEBGL",(()=>he.getNumber("WEBGL_VERSION")>0)),he.registerFlag("WEBGL_VERSION",(()=>ae(2)?2:ae(1)?1:0)),he.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),he.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===he.get("WEBGL_VERSION"))),he.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),he.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),he.registerFlag("WEBGL_PACK",(()=>he.getBool("HAS_WEBGL"))),he.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>he.getBool("WEBGL_PACK"))),he.registerFlag("WEBGL_PACK_CLIP",(()=>he.getBool("WEBGL_PACK"))),he.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>!1)),he.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>he.getBool("WEBGL_PACK"))),he.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>he.getBool("WEBGL_PACK"))),he.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>he.getBool("WEBGL_PACK"))),he.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>he.getBool("WEBGL_PACK"))),he.registerFlag("WEBGL_PACK_REDUCE",(()=>he.getBool("WEBGL_PACK"))),he.registerFlag("WEBGL_LAZILY_UNPACK",(()=>he.getBool("WEBGL_PACK"))),he.registerFlag("WEBGL_CONV_IM2COL",(()=>he.getBool("WEBGL_PACK"))),he.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>ee(he.getNumber("WEBGL_VERSION")))),he.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>re(he.getNumber("WEBGL_VERSION")))),he.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=he.getNumber("WEBGL_VERSION");return 0===e?0:se(e)})),he.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>he.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!o.device_util.isMobile())),he.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>ie(he.getNumber("WEBGL_VERSION")))),he.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!he.getBool("WEBGL_FORCE_F16_TEXTURES")&&he.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),he.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>ue(he.getNumber("WEBGL_VERSION")))),he.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>ce(he.getNumber("WEBGL_VERSION")))),he.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>he.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),he.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)}));var pe=n(45226);const{simpleAbsImpl:fe,addImpl:me,ceilImpl:ge,expImpl:xe,expm1Impl:ve,floorImpl:be,logImpl:ye,maxImpl:we,multiplyImpl:ke,rsqrtImpl:Ie,sliceImpl:Ce,subImpl:$e,transposeImpl:Se,uniqueImpl:Re}=pe;class Ee{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>"T"+t));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>"v"+e)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class Te{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>"T"+t));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>"v"+e)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}class Ae{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:o}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,o];const a="max"===t?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${i};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${a} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}function _e(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function Ne(e,t){return 1===t?[e]:_e(e,t)}function Fe(){let e,t,n,r,s,a,i,u,l,c;return 2===(0,o.env)().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",u="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",u="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:u,defineSpecialInf:l,defineRound:c}}function De(e,t,n="index"){const r=o.util.computeStrides(t);return r.map(((t,s)=>`int ${e[s]} = ${n} / ${t}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${t}`:`index -= ${e[s]} * ${t}`};`)).join("")}function Be(e){const t=o.util.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}const Oe="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:Me}=o.backend_util;function Pe(e,t,n,r){const s=[];e.forEach((e=>{const t=o.util.sizeFromShape(e.shapeInfo.logicalShape);e.shapeInfo.isUniform?s.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(s.push(`uniform sampler2D ${e.name};`),s.push(`uniform int offset${e.name};`))}));const a=s.join("\n"),i=e.map((e=>function(e,t,n=!1){let r="";r+=n?Ve(e):Le(e);const s=e.shapeInfo.logicalShape,a=t.logicalShape;return s.length<=a.length&&(r+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,u=Me(e.shapeInfo.logicalShape,t.logicalShape),l=qe(i),c=i-a;let d;const h=["x","y","z","w","u","v"];d=0===a?"":i<2&&u.length>=1?"coords = 0;":u.map((e=>`coords.${h[e+c]} = 0;`)).join("\n");let p="";p=i<2&&a>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>"coords."+h[t+c])).join(", ");let f="return outputValue;";const m=1===o.util.sizeFromShape(e.shapeInfo.logicalShape),g=1===o.util.sizeFromShape(t.logicalShape);if(1!==a||m||g){if(m&&!g)f=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(u.length){const e=a-2,t=a-1;u.indexOf(e)>-1&&u.indexOf(t)>-1?f="return vec4(outputValue.x);":u.indexOf(e)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":u.indexOf(t)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${d}\n      vec4 outputValue = get${r}(${p});\n      ${f}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,i=e.shapeInfo.texShape,u=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&u===l&&null==e.shapeInfo.flatOffset&&o.util.arraysEqual(i,a))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const c=qe(l),d=Me(e.shapeInfo.logicalShape,t.logicalShape),h=l-u;let p;const f=["x","y","z","w","u","v"];p=0===u?"":l<2&&d.length>=1?"coords = 0;":d.map((e=>`coords.${f[e+h]} = 0;`)).join("\n");let m="";return m=l<2&&u>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>"coords."+f[t+h])).join(", "),`\n    float ${s}() {\n      ${c} coords = getOutputCoords();\n      ${p}\n      return get${r}(${m});\n    }\n  `}(e,t)),r}(e,t,r))).join("\n"),u=t.texShape,l=Fe(),c=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(l);let d,h,p=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${We}\n    ${ze}\n    ${Ue}\n  `}(l);return t.isPacked?(d=function(e,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===n[0]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,t);case 2:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(o.util.arraysEqual(e,t))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const r=Math.ceil(e[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),s=r*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t);default:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),s=r*Math.ceil(e[e.length-2]/2);let o=s,a="",i="b, r, c";for(let t=2;t<e.length-1;t++)o*=e[e.length-t-1],a=`\n      int b${t} = index / ${o};\n      index -= b${t} * ${o};\n    `+a,i=`b${t}, `+i;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${e.length}(${i});\n    }\n  `}(e,t)}}(t.logicalShape,u),h=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(l)):(d=function(e,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return 1===(n=t)[0]?`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `;case 2:return function(e,t){return o.util.arraysEqual(e,t)?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=De(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(e,t);case 4:return function(e,t){const n=De(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t);case 5:return function(e,t){const n=De(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=De(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(e.length+"-D output sampling is not yet supported")}var n}(t.logicalShape,u),h=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(l)),r&&(p+=He),[p,c,h,a,d,i,n].join("\n")}function Le(e){const t=e.shapeInfo.logicalShape;switch(t.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${n}() {return ${t};}`;const[r,s]=e.shapeInfo.texShape;if(1===r&&1===s)return`\n      float ${n}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const[o,a]=e.shapeInfo.texShape;return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${o}, ${a}, ${Ge(t)});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${Xe(e)}\n      }\n    `;const r=e.shapeInfo.texShape,s=r[0],o=r[1];if(1===o&&1===s)return`\n      float ${n}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const a=Ge(t);return 1===o?`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `:1===s?`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${o}, index + ${a});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape;if(null!=s&&o.util.arraysEqual(t,s)){const e=s[0];return`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${e}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `}const{newShape:a,keptDims:i}=o.util.squeezeShape(t),u=a;if(u.length<t.length){const t=["row","col"];return`\n      ${Le(Ke(e,u))}\n      float ${r}(int row, int col) {\n        return ${r}(${je(t,i)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));\n        ${Xe(e)}\n      }\n    `;const l=s[0],c=s[1],d=Ge(n);return 1===c?`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:1===l?`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${t[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${l}, ${c}, index);\n    return sampleTexture(${n}, uv);\n  }\n`}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[1]*t[2],a=t[2],{newShape:i,keptDims:u}=o.util.squeezeShape(t),l=i;if(l.length<t.length){const t=["row","col","depth"];return`\n        ${Le(Ke(e,l))}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${je(t,u)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${a}, 1)));\n        ${Xe(e)}\n      }\n    `;const c=e.shapeInfo.texShape,d=c[0],h=c[1],p=e.shapeInfo.flatOffset;if(h===s&&null==p)return`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${n}, uv);\n        }\n      `;if(h===a&&null==p)return`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${a} + depth + ${Ge(n)};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${n}, uv);\n      }\n  `}(e);case 4:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[3],a=t[2]*s,i=t[1]*a,{newShape:u,keptDims:l}=o.util.squeezeShape(t);if(u.length<t.length){const t=["row","col","depth","depth2"];return`\n      ${Le(Ke(e,u))}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${je(t,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${i}, ${a}, ${s}, 1)));\n        ${Xe(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===i&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===s&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${t[1]*t[2]}, ${t[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${a} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${p}, index + ${Ge(n)});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,i=t[2]*a,u=t[1]*i,{newShape:l,keptDims:c}=o.util.squeezeShape(t);if(l.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${Le(Ke(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${je(t,c)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${u}, ${i}, ${a}, ${s})) +\n          depth3;\n        ${Xe(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===u&&null==d)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===s&&null==d)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${i} + depth * ${a} +\n          depth2 * ${s} + depth3 + ${Ge(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=o.util.squeezeShape(t);if(s.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Le(Ke(e,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${je(t,a)});\n      }\n    `}const i=t[5],u=t[4]*i,l=t[3]*u,c=t[2]*l,d=t[1]*c;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${d}, ${c}, ${l}, ${u})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${Xe(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,f=p[0],m=p[1];if(m===d&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${l}, ${u}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(m===i&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${d} + col * ${c} + depth * ${l} +\n          depth2 * ${u} + depth3 * ${i} + depth4 + ${Ge(n)};\n      vec2 uv = uvFromFlat(${f}, ${m}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(t.length+"-D input sampling is not yet supported")}}function Ve(e){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${Fe().texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e.shapeInfo.texShape,s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],o=Fe();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${s[0]}, ${s[1]}, index);\n      return ${o.texture2D}(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=s[0],i=s[1],u=Fe();if(null!=s&&o.util.arraysEqual(t,s))return`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${a}.0);\n\n        return ${u.texture2D}(${n}, uv);\n      }\n    `;const l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(t[1]/2)}, ${l[0]}, ${l[1]}, row, col);\n      return ${u.texture2D}(${n}, uv);\n    }\n  `}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===t[0]){const n=[1,2],s=["b","row","col"];return`\n        ${Ve(Ke(e,t.slice(1)))}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${je(s,n)});\n        }\n      `}const a=o[0],i=o[1],u=Math.ceil(t[2]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${a}, ${i}, ${u*Math.ceil(t[1]/2)}, ${u}, b, row, col);\n      return ${Fe().texture2D}(${n}, uv);\n    }\n  `}(e);default:return function(e){const t=e.shapeInfo.logicalShape,n=t.length,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],i=a[0],u=a[1],l=Math.ceil(t[n-1]/2);let c=l*Math.ceil(t[n-2]/2),d="int b, int row, int col",h=`b * ${c} + (row / 2) * ${l} + (col / 2)`;for(let e=2;e<n-1;e++)d=`int b${e}, `+d,c*=t[n-e-1],h=`b${e} * ${c} + `+h;return`\n    vec4 ${s}(${d}) {\n      int index = ${h};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${i});\n      return ${Fe().texture2D}(${r}, uv);\n    }\n  `}(e)}}const We="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",ze="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Ue="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",He="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Ge(e){return"offset"+e}function Xe(e){const t=e.name,n=o.util.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function qe(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function Ke(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function je(e,t){return t.map((t=>e[t])).join(", ")}class Ye{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,o.util.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,u=i.length,l=qe(u),c=Ne("coords",u);let d,h;if(1===a){h=u+1;const e=qe(h);d=`\n        ${e} sourceLocR = ${e}(${c.join()}, 0);\n        ++${c[u-1]};\n        ${e} sourceLocG = ${e}(${c.join()}, 0);\n        ++${c[u-2]};\n        ${e} sourceLocA = ${e}(${c.join()}, 0);\n        --${c[u-1]};\n        ${e} sourceLocB = ${e}(${c.join()}, 0);\n        --${c[u-2]};`}else h=u,d=`\n        ${l} sourceLocR = coords;\n        ++${c[u-1]};\n        ${l} sourceLocG = coords;\n        ++${c[u-2]};\n        ${l} sourceLocA = coords;\n        --${c[u-1]};\n        ${l} sourceLocB = coords;\n        --${c[u-2]};`;const p=["x","y","z","w","u","v"].slice(0,h),f="."+p[h-1],m=p.map((e=>"int "+e)),g=Ne("sourceLocR",h-1).concat("inIdx.r"),x=Ne("sourceLocG",h-1).concat("inIdx.g"),v=Ne("sourceLocB",h-1).concat("inIdx.b"),b=Ne("sourceLocA",h-1).concat("inIdx.a"),y="max"===n?"greaterThan":"lessThan",w=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${x.join()}),\n                             getBestIndicesAChannel(${v.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,k=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${x.join()}) : 0.,\n            hasNextRow ? getAChannel(${v.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,I=r?"":`\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${p.join()}),\n                                          vec2(${p.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${p.join()}),\n                               vec2(${p.slice(-2).join()}));\n      }\n      ${I}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${c[u-1]} < ${i[u-1]-1};\n        bool hasNextRow = ${c[u-2]} < ${i[u-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},\n          sourceLocB${f}, sourceLocA${f}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${k};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${k};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${y}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}class Qe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,i=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=i-1-e.padInfo.top,c=u-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n            wR += ${o}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${a}) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Je{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,o=e.strideHeight,a=e.strideWidth,i=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${i}) {\n          float dyD = float(dyDCorner + wD) / ${s}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${u}) {\n            float dyR = float(dyRCorner + wR) / ${o}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${l}) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ze{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=o.backend_util.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const et="return a + b;",tt="return a - b;",nt="return a * b;",rt="return (a < 0.) ? b * a : a;";class st{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=o.backend_util.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const ot="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";class at{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o.backend_util.assertAndGetBroadcastShape(t,n);const s=this.outputShape.length;let a="";if(r)if(0===s||1===o.util.sizeFromShape(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(a=`\n          ${qe(s)} coords = getOutputCoords();\n        `,1===s)a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=Ne("coords",s);a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}class it{constructor(e){this.variableNames=["A"],this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(e,t){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}class ut{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(e,t){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}class lt{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}class ct{constructor(e){this.outputShape=[],this.outputShape=o.backend_util.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>"T"+t));const t=new Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++)t[n]=t[n-1]+e[n][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const r=t[e-1];n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${r}));`)}const r=t.length,s=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class dt{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=o.backend_util.computeOutShape(e,t);const n=this.outputShape,r=n.length,s=qe(r),a=Ne("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>"T"+t));const u=new Array(e.length-1);u[0]=e[0][t];for(let n=1;n<u.length;n++)u[n]=u[n-1]+e[n][t];const l=i[t],c=i.slice(-2),d=i.join();let h=`if (${l} < ${u[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${c.join()}));\n        }`;for(let e=1;e<u.length;e++){const t=u[e-1];h+=`\n        if (${l} < ${u[e]}  && ${l} >= ${u[e-1]}) {\n          return getChannel(\n            getT${e}(${ht(i,l,t)}),\n            vec2(${ht(c,l,t)}));\n        }`}const p=u.length,f=u[u.length-1];h+=`\n        return getChannel(\n          getT${p}(${ht(i,l,f)}),\n          vec2(${ht(c,l,f)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${h}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[r-1]} = ${a[r-1]} + 1;\n        if (${a[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[r-2]} = ${a[r-2]} + 1;\n        if (${a[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[r-1]} = ${a[r-1]} - 1;\n        if (${a[r-2]} < ${n[r-2]} &&\n            ${a[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `}}function ht(e,t,n){const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}class pt{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,o="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${o}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ft{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,o="channelsLast"===e.dataFormat,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,u=o?1:2,l=o?2:3,c=o?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${u}], coords[${l}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${o}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class mt{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,o=e.padInfo.top,a=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${s};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${o};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${a};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class gt{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,o=e.strideHeight,a=e.strideWidth,i=t-1-e.padInfo.front,u=n-1-e.padInfo.top,l=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${i}, ${u}, ${l});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${s}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${o}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class xt{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${o} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class vt{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,o=t-1-e.padInfo.top,a=n-1-e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${i}; dm++) {\n              int d2 = d1 * ${i} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class bt{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const s=e.padInfo.top,o=e.padInfo.left,a=e.strideHeight,i=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,h=4*Math.floor(e.inChannels/4),p=e.inChannels%4,f="channelsLast"===e.dataFormat,m=f?1:2,g=f?2:3,x=f?3:1;let v="",b="";n&&(v=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,b="result = activation(result);");const y=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${a}, ${i});\n      const ivec2 pads = ivec2(${s}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${x}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${m}], coords[${g}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${c}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${l};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${h}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${f}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===p}) {\n\n              if (${f}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${h}) *\n                    getW(wR, wC, ${h}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${h}, xR, xC) *\n                    getW(wR, wC, ${h}, d2);\n              }\n\n            } else if (${2===p}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2)\n              );\n\n              if (${f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===p}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2),\n                getW(wR, wC, ${h} + 2, d2)\n              );\n\n              if (${f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1),\n                  getX(batch, xR, xC, ${h} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC),\n                  getX(batch, ${h} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${y}\n        ${b}\n        setOutput(result);\n      }\n    `}}class yt{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,o=e.strideHeight,a=e.strideWidth,i=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${o}, ${a});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${i};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class wt{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const s=e.inHeight,o=e.inWidth,a=e.padInfo.top,i=e.padInfo.left,u=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,d=e.dilationWidth,h=e.filterHeight,p=e.filterWidth,f=e.outChannels/e.inChannels;let m="",g="";n&&(m=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,g="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${m}\n\n      const ivec2 strides = ivec2(${u}, ${l});\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${f};\n        int q = d2 - d1 * ${f};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${c};\n\n          if (xR < 0 || xR >= ${s}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${o}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${x}\n        ${g}\n        setOutput(result);\n      }\n    `}}class kt{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.outShape;const s=e.inHeight,a=e.inWidth,i=e.padInfo.top,u=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,d=e.dilationHeight,h=e.dilationWidth,p=e.filterHeight,f=e.filterWidth,m=f;let g="int xR; int xC; int xCOffset;";for(let e=0;e<p;e++)for(let t=0;t<f;t++)g+=`\n          vec4 xTexelR${e}C${2*t} = vec4(0.);\n          vec4 wR${e}C${t} = vec4(0.);\n          vec4 xR${e}C${t} = vec4(0.);`;for(let e=0;e<p;e++)for(let t=0;t<m;t++){const n=2*t;if(g+=`\n          xR = xRCorner + ${e*d};\n          xC = xCCorner + ${n*h};\n        `,1===c){if(n<f&&(g+=u%2==1?`\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${s} && xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${e}C${n} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${a}) {\n                    xTexelR${e}C${n}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${e}C${n} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${s} && xCOffset >= 0 && xCOffset < ${a}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${a}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${e}C${n} = vec4(previous.zw, xTexelR${e}C${n}.xy);\n                } else {\n                  xR${e}C${n} = vec4(0, 0, xTexelR${e}C${n}.xy);\n                }\n              `:`\n                if(xR >= 0 && xR < ${s} && xC >= 0 && xC < ${a}) {\n                  xTexelR${e}C${n} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${e}C${n} = vec4(0.);\n                }\n\n                xR${e}C${n} = xTexelR${e}C${n};\n              `,n+1<f)){const t=u%2==0?o.util.nearestLargerEven(h):h;h%2==0&&u%2==1||h%2!=0&&u%2!=1?(g+=`\n                  xCOffset = xC + ${u%2} + ${t};\n\n                  if(xR >= 0 && xR < ${s} &&\n                    xCOffset >= 0 && xCOffset < ${a}) {\n                    xTexelR${e}C${n+2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `,h>1&&(g+=`\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${s} &&\n                      xCOffset >= 0 && xCOffset < ${a}) {\n                      xTexelR${e}C${n} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${e}C${n} = vec4(0.);\n                    }\n                  `),g+=`\n                  xR${e}C${n+1} = vec4(\n                    xTexelR${e}C${n}.zw, xTexelR${e}C${n+2}.xy);\n                `):g+=`\n                  xCOffset = xC + ${t};\n\n                  if(xR >= 0 && xR < ${s} &&\n                    xCOffset >= 0 && xCOffset < ${a}) {\n                    xTexelR${e}C${n+2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${e}C${n+1} = xTexelR${e}C${n+2};\n                `}}else n<f&&(g+=`\n              if(xR >= 0 && xR < ${s}) {\n            `,u%2==1?(g+=`\n                xCOffset = xC + 1 - ${c};\n                if(xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${e}C${n} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${e}C${n} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${a}) {\n                  xTexelR${e}C${n+2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${e}C${n+2} = vec4(0.);\n                }\n\n                xR${e}C${n} = vec4(\n                  xTexelR${e}C${n}.zw, xTexelR${e}C${n+2}.zw);\n              `,n+1<f&&(g+=`\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${c};\n                  if(xCOffset >= 0 && xCOffset < ${a}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${e}C${n+1} = vec4(xTexelR${e}C${n+2}.xy, final.xy);\n                `)):(g+=`\n                if(xC >= 0 && xC < ${a}) {\n                  xTexelR${e}C${n} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${e}C${n} = vec4(0.);\n                }\n\n                xCOffset = xC + ${c};\n                if(xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${e}C${n+2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${e}C${n+2} = vec4(0.);\n                }\n\n                xR${e}C${n} = vec4(\n                  xTexelR${e}C${n}.xy, xTexelR${e}C${n+2}.xy);\n              `,n+1<f&&(g+=`\n                  xR${e}C${n+1} = vec4(\n                    xTexelR${e}C${n}.zw, xTexelR${e}C${n+2}.zw);\n                `)),g+="}");n<f&&(g+=`\n            vec4 wTexelR${e}C${n} = getW(${e}, ${n}, d1, q);\n            wR${e}C${n} = vec4(wTexelR${e}C${n}.xz, wTexelR${e}C${n}.xz);\n          `,n+1<f&&(g+=`\n              vec4 wTexelR${e}C${n+1} = getW(${e}, ${n+1}, d1, q);\n              wR${e}C${n+1} =\n                vec4(wTexelR${e}C${n+1}.xz, wTexelR${e}C${n+1}.xz);`))}for(let e=0;e<p;e++)for(let t=0;t<f;t++)g+=`dotProd += xR${e}C${t} * wR${e}C${t};`;let x="",v="";n&&(x=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,v="result = activation(result);");const b=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${l}, ${c});\n      const ivec2 pads = ivec2(${i}, ${u});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${g}\n\n        vec4 result = dotProd;\n        ${b}\n        ${v}\n        setOutput(result);\n      }\n    `}}class It{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,i,u]=e,[l]=t,[c,d]=n;this.outputShape=[l,c,d,u];const h="bilinear"===r?1:0,[p,f]=[a-1+".0",i-1+".0"],[m,g,x]=c>1?[""+(a-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0","0.5 * (y1+y2) * "+p],[v,b,y]=d>1?[""+(i-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0","0.5 * (x1+x2) * "+f];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${v});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${o}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${b};\n\n        float in_y = ${x};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${y};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}class Ct{constructor(e,t,n){this.variableNames=["x"],this.outputShape=e;const r=e.length,s=t?"0.0":`getX(${$t(r,"coords")})`,o=e[e.length-1];let a="",i="";t?(a=n?"end != "+(o-1):"end != 0",i=n?"end + 1":"end - 1"):(a=n?"end + pow2 < "+o:"end >= pow2",i=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${qe(r)} coords = getOutputCoords();\n        int end = ${St(r,"coords")};\n        float val = ${s};\n        int pow2 = int(pow(2.0, index));\n        if (${a}) {\n          int idx = ${i};\n          ${St(r,"coords")} = idx;\n          val += getX(${$t(r,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.index&&(this.index=t.getUniformLocation(n,"index")),t.gl.uniform1f(this.index,e)}}}function $t(e,t){if(1===e)return""+t;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function St(e,t){if(1===e)return""+t;if(2===e)return t+".y";if(3===e)return t+".z";if(4===e)return t+".w";throw Error(`Cumulative sum for rank ${e} is not yet supported`)}class Rt{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=c.DENSE;const t=f(e),n=Fe();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${De(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class Et{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=c.DENSE;const t=f(e),n=Fe();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${De(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class Tt{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}class At{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}class _t{constructor(e){this.variableNames=["A"],this.outTexUsage=d.DOWNLOAD;const t=Fe();this.outputShape=e,this.userCode=`\n      ${Oe}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class Nt{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=d.DOWNLOAD;const t=Fe();this.outputShape=e,this.userCode=`\n      ${Oe}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}class Ft{constructor(e,t,n=!1){this.variableNames=["A"];const r=Fe(),[s,o]=t;this.outputShape=e;let a="result";n&&(a="floor(result * 255. + 0.5)"),this.userCode=`\n      ${Be(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${o};\n        int c = imod(flatIndex, ${o});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${o}.0, ${s}.0);\n        vec4 values = ${r.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${r.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}}class Dt{constructor(e,t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const r=Fe(),[s,o]=t;this.outputShape=e;let a="",i="result";n&&(i="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let n=0;n<=1;n++){const i=2*t+n;a+=`\n          localCoords = coords;\n          if(localCoords[2] + ${n} < ${e[2]}) {\n            localCoords[2] += ${n};\n            if(localCoords[1] + ${t} < ${e[1]}) {\n              localCoords[1] += ${t};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${o};\n              c = imod(flatIndex, ${o});\n              uv = (vec2(c, r) + halfCR) / vec2(${o}.0, ${s}.0);\n              values = ${r.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${i}] = values[0];\n              } else if(offset == 1) {\n                result[${i}] = values[1];\n              } else if(offset == 2) {\n                result[${i}] = values[2];\n              } else {\n                result[${i}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${Be(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${a}\n\n        ${r.output} = ${i};\n      }\n    `}}class Bt{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const s=n?"2.0 * "+Math.PI:"-2.0 * "+Math.PI,o=n?r+".0":"1.0";this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${e}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}class Ot{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}class Mt{constructor(e,t,n){this.variableNames=["A","indices"];const r=e.slice();r[n]=t,this.outputShape=r,this.rank=r.length;const s=qe(this.rank),o=function(e,t){const n=e.length;if(n>4)throw Error(`Gather for rank ${n} is not yet supported`);if(1===n)return"int(getIndices(resRC))";const r=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let n=0;n<e.length;n++)n===t?s.push(`int(getIndices(${r[n]}))`):s.push(""+r[n]);return s.join()}(e,n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}class Pt{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;const r=qe(t.length),s=qe(n.length),o=this.sliceDim>1?"strides[j]":"strides";this.userCode=`\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${o};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}function Lt(e){const t=Fe();return w(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function Vt(e){return R(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function Wt(e){return E(e,new Uint16Array([0,1,2,2,1,3]))}function zt(e,t,n,r,s,o){_(t,n);const a=A(e),i=e.TEXTURE_2D;return x(e,(()=>e.bindTexture(i,a))),x(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),x(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),x(e,(()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST))),x(e,(()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST))),x(e,(()=>e.texImage2D(i,0,r,t,n,0,s,o,null))),x(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),a}function Ut(e){return e.internalFormatFloat}function Ht(e,t,n,r){const[s,o]=p(t,n);return zt(e,s,o,Ut(r),r.textureFormatFloat,e.FLOAT)}function Gt(e){return e.internalFormatHalfFloat}function Xt(e,t,n,r){const[s,o]=p(t,n);return zt(e,s,o,Gt(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function qt(e){return e.downloadTextureFormat}function Kt(e,t,n,r){const[s,o]=p(t,n);return zt(e,s,o,qt(r),e.RGBA,e.UNSIGNED_BYTE)}function jt(e){return e.internalFormatPackedFloat}function Yt(e,t,n,r){const[s,o]=m(t,n);return zt(e,s,o,jt(r),e.RGBA,e.FLOAT)}function Qt(e){return e.internalFormatPackedHalfFloat}function Jt(e,t,n,r){const[s,o]=m(t,n);return zt(e,s,o,Qt(r),e.RGBA,r.textureTypeHalfFloat)}function Zt(e,t,n){return x(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),F(e,t,"clipSpacePos",n,3,20,0)&&F(e,t,"uv",n,2,20,12)}function en(e,t,n,r,s,o){let a,i,u;x(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),s instanceof Uint8Array?(a=new Uint8Array(n*r*4),i=e.UNSIGNED_BYTE,u=e.RGBA):(a=new Float32Array(n*r*4),i=e.FLOAT,u=o.internalFormatPackedFloat),a.set(s),x(e,(()=>e.texImage2D(e.TEXTURE_2D,0,u,n,r,0,e.RGBA,i,a))),x(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function tn(e,t,n){x(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?x(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):x(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),x(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function nn(e,t,n,r){const s=e.createBuffer();x(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s)));const o=16*t*n;return x(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ))),x(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),x(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),s}function rn(e,t,n){const r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function sn(e,t,n,r){const[s,o]=p(t,n),a=new Uint8Array(t*n*4);return x(e,(()=>e.readPixels(0,0,s,o,r.downloadTextureFormat,e.UNSIGNED_BYTE,a))),new Float32Array(a.buffer)}function on(e,t,n,r,s,o,a,i){const u=e,l=new Float32Array(function(e,t){const[n,r]=m(e,t);return n*r*4}(o,a));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function an(e,t,n){const r=new Float32Array(t*n*4);return x(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}class un{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=(0,o.env)().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,u(t,e)):this.gl=l(t);let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(1===(0,o.env)().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=y(this.gl,e),oe(this.gl,t))this.textureHalfFloatExtension=y(this.gl,t);else if((0,o.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),oe(this.gl,r))this.colorBufferHalfFloatExtension=y(this.gl,r);else if((0,o.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",oe(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!oe(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=Vt(this.gl),this.indexBuffer=Wt(this.gl),this.framebuffer=N(this.gl),this.textureConfig=g(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,o.env)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;x(e,(()=>e.finish())),x(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),x(e,(()=>e.deleteFramebuffer(this.framebuffer))),x(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),x(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),x(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),Ht(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),Xt(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),Kt(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),tn(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),en(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),Jt(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),Yt(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(W(this.gl,this.framebuffer),this.outputTexture=null),x(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>sn(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,s,o){return on(this.gl,e,0,0,0,s,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return rn(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=nn(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if((0,o.env)().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(s,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=s}else(0,o.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,(0,o.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>an(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl,n=k(t,e),r=Lt(t),s=C(t);return x(t,(()=>t.attachShader(s,r))),x(t,(()=>t.attachShader(s,n))),$(t,s),this.debug&&S(t,s),this.vertexAttrsAreBound||(this.setProgram(s),this.vertexAttrsAreBound=Zt(t,this.program,this.vertexBuffer)),s}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&x(this.gl,(()=>this.gl.deleteProgram(e)))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&S(this.gl,this.program),x(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?O(this.gl,e,t):M(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),x(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),P(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,s]=m(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&S(this.gl,this.program),z(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),x(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),x(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=y(this.gl,2===(0,o.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,o.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===(0,o.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await o.util.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,(0,o.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,(0,o.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||o.util.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),V(this.gl,e,this.framebuffer),this.debug&&z(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(V(this.gl,this.outputTexture,this.framebuffer),this.debug&&z(this.gl)):W(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;V(r,e,this.framebuffer),this.debug&&z(r),this.outputTexture=e,x(r,(()=>r.viewport(0,0,t,n))),x(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),x(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}function ln(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const r=e.logicalShape,s=t[n],a=s.shape;if(!o.util.arraysEqual(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(e.isUniform&&s.isUniform)return;const i=e.texShape,u=s.isUniform?null:s.texData.texShape;if(!o.util.arraysEqual(i,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${u} must match`)}))}class cn{constructor(e,t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;const{filterWidth:r,inChannels:s,strideWidth:o,strideHeight:a,padInfo:i,outWidth:u,dilationWidth:l,dilationHeight:c,dataFormat:d}=n,{left:h,top:p}=i,f=s*r,m=Fe(),g="channelsLast"===d,x=g?0:1,v=g?1:2;let b="";for(let n=0;n<=1;n++)for(let r=0;r<=1;r++)b+=`\n          blockIndex = rc.y + ${r};\n          pos = rc.x + ${n};\n\n          if(blockIndex < ${e[1]} && pos < ${e[0]}) {\n            offsetY = int(blockIndex / (${u})) * ${a} - ${p};\n            d0 = offsetY + ${c} * (pos / ${f});\n\n            if(d0 < ${t[x]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${u}.) * ${o}. - ${h}.);\n              d1 = offsetX + ${l} * (int(mod(float(pos), ${f}.) / ${s}.));\n\n              if(d1 < ${t[v]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${s}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*n+r}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*n+r}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${b}\n\n        ${m.output} = result;\n      }\n    `}}class dn{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];const o=t,a=e[3]-1;let i;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;i=.5===s?`inversesqrt(${u})`:1===s?`1.0/(${u})`:`exp(log(${u}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${o}; j <= ${o}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${i};\n        setOutput(val);\n      }\n    `}}class hn{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}class pn{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,a=e[3]-1;let i;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;i=.5===s?`inversesqrt(${u})`:1===s?`1.0/(${u})`:`exp(log(${u}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${o};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${o}; j <= ${o}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${i};\n        setOutput(result);\n      }\n    `}}class fn{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,o=e.effectiveFilterWidth,a=s-1-e.padInfo.top,i=o-1-e.padInfo.left,u=s*o-1;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${o} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class mn{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,o=e.dilationHeight,a=e.dilationWidth,i=e.effectiveFilterDepth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=i-1-e.padInfo.front,d=u-1-e.padInfo.top,h=l-1-e.padInfo.left,p=i*u*l-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${i};\n           wD += ${s}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${o}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${l};\n                wC += ${a}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${l} +\n                  wR * ${l} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class gn{constructor(e,t,n=!1,r=!1,s=!1,o=null,a=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;const i=n?e[1]:e[2],u=Math.ceil(i/2),l=n?"i * 2, rc.y":"rc.y, i * 2",c=r?"rc.z, i * 2":"i * 2, rc.z",d=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let p="",f="";o&&(p=a?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${o}\n        }`:`vec4 activation(vec4 x) {\n          ${o}\n        }`,f="result = activation(result);");const m=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${p}\n\n      const float sharedDimension = ${u}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${u}; i++) {\n          vec4 a = getMatrixA(rc.x, ${l});\n          vec4 b = getMatrixB(rc.x, ${c});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${h[0]});\n          result += (${d[1]} * ${h[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${m}\n\n        ${f}\n\n        setOutput(result);\n      }\n    `}}class xn{constructor(e,t,n){this.variableNames=["probs"],this.outputShape=[e,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.seedLoc&&(this.seedLoc=t.getUniformLocation(n,"seed")),t.gl.uniform1f(this.seedLoc,e)}}}class vn{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}class bn{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;const t=e.length;if(0===t)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=Ne("rc",t),r=qe(t),s=function(e,t,n){if(1===e)return"rc > "+t[0];let r="";for(let s=e-2;s<e;s++)r+=`${n[s]} >= ${t[s]}`,s<e-1&&(r+="||");return r}(t,e,n),o=function(e,t,n,r){if(1===e)return"";const s=r.slice(-2);return`\n    int r = ${s[0]};\n    int c = ${s[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${t};\n    bool rEdge = rp1 >= ${n};\n  `}(t,e[e.length-1],e[e.length-2],n),a=function(e,t){const n=e.length,r=function(e,t){const n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let n=2;n<e;n++)o=t[t.length-1-n]+","+o;n.push(o)}return n}(n,t);return 1===n?`getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${r[0]}),\n          cEdge ? 0. : getA(${r[1]}),\n          rEdge ? 0. : getA(${r[2]}),\n          rEdge || cEdge ? 0. : getA(${r[3]})`}(e,n);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${o}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}}class yn{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=qe(r),o=t.map((e=>e[0])).join(","),a=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${o});\n      ${s} end = ${s}(${a});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(${n}));\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${i}));\n        }\n      }\n    `:`\n        int start = ${o};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(${n}));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class wn{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=qe(r),o=t.map((e=>e[0])).join(","),a=t.map(((t,n)=>t[0]+e[n])).join(","),i=Ne("rc",r),u=Ne("source",r),l=`${i[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${u.slice(-2).join()})`,d=[s+" rc = outputLoc;",`${i[r-1]} += 1;\n       if(${l}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${i[r-2]} += 1;\n       if(${i[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${i[r-1]} += 1;\n         if(${l}) {`],h=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let e=0,t=1===r?2:4;e<t;e++)p+=`\n        ${d[e]}\n        if (${h}) {\n          result[${e}] = float(${n});\n        } else {\n          ${s} source = rc - start;\n          result[${e}] = getChannel(getX(${u.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${o});\n      const ${s} end = ${s}(${a});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}class kn{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideHeight,i=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let x="0.0";if(f||(x="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${i});\n        const ivec2 pads = ivec2(${h}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?m:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(v="avgValue / count");const b=4*Math.floor(o/4),y=o%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${i});\n      const ivec2 pads = ivec2(${h}, ${p});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${b}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${b};\n          if (${1===y}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===y}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===y}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${v});\n      }\n    `}}class In{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideDepth,i=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,x=e.padInfo.left;this.outputShape=e.outShape;const v="avg"===t;let b="0.0";if(v||(b="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${i}, ${u});\n        const ivec3 pads = ivec3(${m}, ${g}, ${x});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let y=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(y="avgValue / count");const w=4*Math.floor(o/4),k=o%4,I=`\n      if (${v}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${i}, ${u});\n      const ivec3 pads = ivec3(${m}, ${g}, ${x});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${I}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${I}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${I}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${I}\n            }\n          }\n          setOutput(${y});\n        }\n      }\n    `}}class Cn{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:o}=e;this.outputShape=[r,o];let a="0.0",i="";"prod"===t?a="1.0":"min"===t?(a="1.0 / 1e-20",i="min"):"max"===t&&(a="-1.0 / 1e-20",i="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?u="sumValue":"prod"===t?u="prodValue":"all"===t?u="allValue":"any"===t&&(u="anyValue");const l=4*Math.floor(n/4),c=n%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${i}(values, minMaxValue);\n      }\n    `,h="vec4";"all"===t?(a="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(a="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";s%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${u});\n      }\n    `}}class $n{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;let n="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}var r;this.userCode=`\n      ${r=t,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${De(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${Be(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${e[1]};\n        int cols = ${e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class Sn{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t.shape;const[,r,s]=t.shape,[,o,a]=e.shape,i=[n&&o>1?r-1:r,n&&a>1?s-1:s],u=[n&&o>1?o-1:o,n&&a>1?a-1:a],l=i[0]/u[0],c=i[1]/u[1],d=1/l,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}class Rn{constructor(e,t,n,r){this.variableNames=["A"],this.outputShape=[];const[s,o,a,i]=e;this.outputShape=[s,t,n,i];const u=[r&&t>1?o-1:o,r&&n>1?a-1:a],l=[r&&t>1?t-1:t,r&&n>1?n-1:n];this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${a}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class En{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,a,i]=e;this.outputShape=[s,t,n,i];const u=[r&&t>1?o-1:o,r&&n>1?a-1:a],l=[r&&t>1?t-1:t,r&&n>1?n-1:n];this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]},\n          ${u[1]/l[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${a}.0,\n                                     ${a}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${i-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}class Tn{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t.shape;const[,r,s]=t.shape,[,o,a]=e.shape,i=[n&&o>1?r-1:r,n&&a>1?s-1:s],u=[n&&o>1?o-1:o,n&&a>1?a-1:a],l=i[0]/u[0],c=i[1]/u[1],d=1/l,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${i[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${i[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}class An{constructor(e,t,n,r){this.variableNames=["A"],this.outputShape=[];const[s,o,a,i]=e;this.outputShape=[s,t,n,i];const u=[r&&t>1?o-1:o,r&&n>1?a-1:a],l=[r&&t>1?t-1:t,r&&n>1?n-1:n],c=r?"0.5":"0.0";this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${a}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${c})));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class _n{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),s=qe(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class Nn{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=Ne("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,o=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,a=qe(n);function i(n){const r=e.map(((r,s)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:""+r[n]}(s,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return i(e)}(r.slice())};\n          if(${s}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",i(e)}(r.slice())};\n          }\n          if(${o}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",i(e)}(r.slice())};\n            if(${s}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",i(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}class Fn{constructor(e,t,n,r,s,o,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const i=qe(s.length),u=qe(o.length);let l="";1===n?l="i":2===n&&(l="i, j");const c=`getIndices(${l})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const h=`getUpdates(${d})`,p=t>1?"strides[j]":"strides";this.userCode=`\n        ${i} strides = ${i}(${s});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${p};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${h};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}class Dn{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,s=e.inSize,o=e.numSegments,a=o*Math.ceil(s/n);this.outputShape=[r,a];const i=4*Math.floor(n/4),u=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let c="";s%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let d="";s%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${o})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${o})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${l}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${l}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class Bn{constructor(e,t,n){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)s="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],a=[];for(let r=0;r<t.length;r++)a.push(""+n[r]),r<e&&o.push(""+n[r]);r=o.join(),s=a.join()}const o=qe(n);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}class On{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=qe(this.rank),n=`uniform int start[${this.rank}];`,r=function(e){if(1===e)return"sourceLoc";if(e<=6)return Mn.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let s;s=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${Mn[t]} = start[${t}] + coords.${Mn[t]};`)).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}const Mn=["x","y","z","w","u","v"];class Pn{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length;const t=qe(this.rank),n=Ne("coords",this.rank),r=Ne("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${s})`,a=`\n      result.x = ${o};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${o};\n        --${r[this.rank-1]};\n      }\n    `,i=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${o};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${o};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${a}\n        ${i}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}class Ln{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=qe(n.length),o=qe(n.length);let a="";if(1===r)a="coords * strides + begin";else{let e=0;a=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${s} begin = ${s}(${e});\n      ${s} strides = ${s}(${t});\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}class Vn{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const r=zn(t,n),s=Un(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const o=Wn(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const e=this.freeTextures[s].shift();return this.usedTextures[s].push(e),e}let a;return r===h.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===h.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===h.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===h.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===h.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const s=zn(n,r),a=Un(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);const i=Wn(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),u=(0,o.env)().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==u&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const l=this.usedTextures[a],c=l.indexOf(e);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(c,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: "+this._numBytesAllocated),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Wn(e,t,n,r,s){const o=function(e,t){switch(e){case h.PACKED_2X2_FLOAT32:return jt(t);case h.PACKED_2X2_FLOAT16:return Qt(t);case h.UNPACKED_FLOAT32:return Ut(t);case h.UNPACKED_FLOAT16:return Gt(t);case h.PACKED_4X1_UNSIGNED_BYTE:return qt(t);default:throw new Error("Unknown physical texture type "+e)}}(t,r);let a;if(s){const[t,n]=m(e[0],e[1]);a=t*n}else{const[t,n]=p(e[0],e[1]);a=t*n}return a*function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;throw new Error("Unknown internal format "+t)}(n,o)}function zn(e,t){if(e===d.UPLOAD)return h.PACKED_2X2_FLOAT32;if(e===d.RENDER||null==e)return function(e){return(0,o.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?h.PACKED_2X2_FLOAT32:h.UNPACKED_FLOAT32:e?h.PACKED_2X2_FLOAT16:h.UNPACKED_FLOAT16}(t);if(e===d.DOWNLOAD||e===d.PIXELS)return h.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+e)}function Un(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class Hn{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;const r=qe(this.rank),s=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let t=0;t<e.length;t++)r.push(`imod(${n[t]}, ${e[t]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}class Gn{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const Xn="return abs(x);",qn="if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",Kn="if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",jn="return (x >= 0.0) ? x : (exp(x) - 1.0);",Yn=`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${o.backend_util.SELU_SCALEALPHA};\n  float scale = ${o.backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`,Qn="return -x;",Jn="return ceil(x);",Zn="return floor(x);",er="return exp(x);",tr="return exp(x) - 1.0;",nr=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${o.backend_util.ERF_P};\n  float a1 = ${o.backend_util.ERF_A1};\n  float a2 = ${o.backend_util.ERF_A2};\n  float a3 = ${o.backend_util.ERF_A3};\n  float a4 = ${o.backend_util.ERF_A4};\n  float a5 = ${o.backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`,rr="return x;",sr="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",or="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",ar="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n";class ir{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class ur{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;const t=e.length,n=Ne("rc",t),r=qe(t),s=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),o=n.slice(-2),a=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const{segment_util:lr}=o.backend_util,cr=o.kernel_impls.split,dr=o.kernel_impls.tile,hr=o.kernel_impls.topkImpl,pr=o.kernel_impls.whereImpl,fr={};function mr(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?sr:qn;if("elu"===e)return t?ar:jn;if("relu6"===e)return t?or:Kn;if("prelu"===e)return t?ot:rt;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class gr extends o.KernelBackend{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.warnedAboutMemory=!1,this.warnedAboutCPUBackend=!1,this.pendingDeletes=0,this.disposed=!1,!(0,o.env)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==e){const e=l((0,o.env)().getNumber("WEBGL_VERSION"));this.binaryCache=((t=(0,o.env)().getNumber("WEBGL_VERSION"))in fr||(fr[t]={}),fr[t]),this.gpgpu=new un(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;var t;this.textureManager=new Vn(this.gpgpu),this.numMBBeforeWarning=null==(0,o.env)().global.screen?1024:(0,o.env)().global.screen.height*(0,o.env)().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new o.DataStorage(this,(0,o.engine)())}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(e,t,n){if(((0,o.env)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,o.env)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:d.UPLOAD,refCount:1}),r}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,t,n,r){if((0,o.env)().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:d.UPLOAD,refCount:1})}disposeIntermediateTensorInfo(e){const t=e.dataId;if(this.texData.has(t)){const e=this.texData.get(t);e.refCount--,e.refCount<1&&this.disposeData(t)}}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensors:s,slice:a,shape:i,isPacked:u}=t;if(null!=a){let t;t=u?new ir(i,rr):new Gn(i,rr);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const l=null!=this.activeTimers;let c,d;if(l&&(c=o.util.now()),"complex64"===r){const e=s.real.dataSync(),t=s.imag.dataSync();d=o.backend_util.mergeRealAndImagArrays(e,t)}else d=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=o.util.now()-c),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:s,dtype:a,complexTensors:i,isPacked:u}=t;if(null!=s){let t;t=u?new ir(r,rr):new Gn(r,rr);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:a}],a),s=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if(!(0,o.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===(0,o.env)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,c,d=null;if("complex64"!==a&&(0,o.env)().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);d=this.gpgpu.createBufferFromTexture(t.texture,...f(r))}if(this.pendingRead.set(e,[]),"complex64"!==a&&await this.gpgpu.createAndWaitForFence(),"complex64"===a){const e=await Promise.all([i.real.data(),i.imag.data()]),t=e[0],n=e[1];c=o.backend_util.mergeRealAndImagArrays(t,n)}else if(null==d)c=this.getValuesFromTexture(e);else{const e=o.util.sizeFromShape(r);c=this.gpgpu.downloadFloat32MatrixFromBuffer(d,e)}null!=l&&this.disposeIntermediateTensorInfo(l);const h=this.convertAndCacheOnCPU(e,c),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach((e=>e(h))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e),this.pendingDeletes--),h}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!v(n)){if((0,o.env)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),s=o.util.sizeFromShape(t);if((0,o.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),o=this.gpgpu.downloadMatrixFromPackedTexture(r.texture,...f(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),o}const a=(0,o.env)().getBool("WEBGL_PACK")&&!0===r,i=a?K(t):t,u=a?new Nt(i):new _t(i),l=this.runWebGLProgram(u,[{shape:i,dtype:n,dataId:e}],"float32"),c=this.texData.get(l.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture,c.texShape[0],c.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),d}async time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const s=o.util.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),a=o.util.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if((0,o.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(s);i.kernelMs=o.util.sum(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:a[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,o.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:o.util.now(),endMs:null}}endTimer(e){return(0,o.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=o.util.now(),e)}async getQueryTime(e){if((0,o.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){if(this.pendingDisposal.has(e))return;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),void this.pendingDeletes++;if(!this.texData.has(e))return;this.releaseGPUData(e);const{complexTensors:t}=this.texData.get(e);null!=t&&(t.real.dispose(),t.imag.dispose()),this.texData.delete(e)}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:s,isPacked:o,slice:a}=this.texData.get(e),i=a&&a.origDataId||e,u=this.dataRefCount.get(i);u>1?this.dataRefCount.set(i,u-1):(this.dataRefCount.delete(i),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,s,o)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}getCPUBackend(){return(0,o.env)().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=(0,o.engine)().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(e,t=128){const n=this.getCPUBackend();return this.warnedAboutCPUBackend||null!=n||(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),null!=n&&e.every((e=>null==this.texData.get(e.dataId).texture&&o.util.sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}complex(e,t){const n=this.makeOutput(e.shape,"complex64");return this.texData.get(n.dataId).complexTensors={real:(0,o.engine)().keep(e.clone()),imag:(0,o.engine)().keep(t.clone())},n}real(e){return this.texData.get(e.dataId).complexTensors.real.clone()}imag(e){return this.texData.get(e.dataId).complexTensors.imag.clone()}slice(e,t,n){if(this.shouldExecuteOnCPU([e])){const r=Ce(this.texData.get(e.dataId).values,t,n,e.shape,e.dtype);return this.makeOutput(n,e.dtype,r)}if(0===o.util.sizeFromShape(n))return(0,o.tensor)([],n,e.dtype);const{isPacked:r}=this.texData.get(e.dataId),s=o.slice_util.isSliceContinous(e.shape,t,n);if(r||!s){const r=(0,o.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Pn(n):new On(n),s=r.getCustomSetupFunc(t);return this.compileAndRun(r,[e],null,s)}return this.uploadToGPU(e.dataId),this.shallowSlice(e,t,n)}shallowSlice(e,t,n){const r=this.texData.get(e.dataId),s=this.makeOutput(n,e.dtype),a=this.texData.get(s.dataId);Object.assign(a,r),a.shape=n,a.dtype=e.dtype;let i=o.slice_util.computeFlatOffset(t,e.strides);r.slice&&(i+=r.slice.flatOffset),a.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||e.dataId};const u=this.dataRefCount.get(a.slice.origDataId)||1;return this.dataRefCount.set(a.slice.origDataId,u+1),s}stridedSlice(e,t,n,r){const s=this.tryRunOnCpuOrThrow([e],(()=>this.cpuBackend.stridedSlice(e,t,n,r)));if(s)return s;const a=o.slice_util.computeOutShape(t,n,r);if(a.some((e=>0===e)))return(0,o.tensor)([],a);const i=new Ln(t,r,a);return this.compileAndRun(i,[e])}reverse(e,t){const n=(0,o.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Nn(e.shape,t):new _n(e.shape,t);return this.compileAndRun(n,[e])}concat(e,t){if("complex64"===e[0].dtype){const n=e.map((e=>(0,o.real)(e))),r=e.map((e=>(0,o.imag)(e)));return(0,o.complex)(this.concat(n,t),this.concat(r,t))}if(1===e.length)return e[0];if(e.length>(0,o.env)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const n=Math.floor(e.length/2),r=this.concat(e.slice(0,n),t),s=this.concat(e.slice(n),t);return this.concat([r,s],t)}if((0,o.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].rank>1){const n=new dt(e.map((e=>e.shape)),t);return this.compileAndRun(n,e)}const n=o.backend_util.computeOutShape(e.map((e=>e.shape)),t),r=e.map((e=>e.as2D(-1,o.util.sizeFromShape(e.shape.slice(t))))),s=new ct(r.map((e=>e.shape)));return this.compileAndRun(s,r).reshape(n)}neg(e){const t=this.tryRunOnCpuOrThrow([e],(()=>this.cpuBackend.neg(e)));if(t)return t;if((0,o.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Qn,e.dtype);const n=new Gn(e.shape,Qn);return this.compileAndRun(n,[e])}batchMatMul(e,t,n,r){const s=n?e.shape[2]:e.shape[1],a=r?t.shape[1]:t.shape[2],i=n?e.shape[1]:e.shape[2],[u,,]=e.shape;if((1===s||1===a)&&i>1e3){n&&(e=(0,o.transpose)(e,[0,2,1])),r&&(t=(0,o.transpose)(t,[0,2,1]));const s=1===a?e:e.as3D(u,i,1),l=1===a?2:1,c=1===a?t.as3D(u,1,i):t;return this.multiply(s,c).sum(l,!0)}const l=(0,o.upcastType)(e.dtype,t.dtype),c=new gn(e.shape,[u,s,a],n,r);return this.compileAndRun(c,[e,t],l)}fusedBatchMatMul({a:e,b:t,transposeA:n,transposeB:r,bias:s,activation:a,preluActivationWeights:i}){const u=n?e.shape[2]:e.shape[1],l=r?t.shape[1]:t.shape[2],[c,,]=e.shape,d=(0,o.upcastType)(e.dtype,t.dtype),h=null!=s,p=null!=i,f=a?mr(a,!0):null,m=new gn(e.shape,[c,u,l],n,r,h,f,p),g=[e,t];return s&&g.push(s),i&&g.push(i),this.compileAndRun(m,g,d)}multiply(e,t){if("complex64"===e.dtype){const n=this.texData.get(e.dataId),r=this.texData.get(t.dataId),s=new Ze("return areal * breal - aimag * bimag;",e.shape,t.shape),o=new Ze("return areal * bimag + aimag * breal;",e.shape,t.shape),a=[this.makeComplexComponentTensorInfo(e,n.complexTensors.real),this.makeComplexComponentTensorInfo(e,n.complexTensors.imag),this.makeComplexComponentTensorInfo(t,r.complexTensors.real),this.makeComplexComponentTensorInfo(t,r.complexTensors.imag)],i=this.compileAndRun(s,a),u=this.compileAndRun(o,a),l=this.complex(i,u);return i.dispose(),u.dispose(),l}const n=(0,o.upcastType)(e.dtype,t.dtype);if(this.shouldExecuteOnCPU([e,t])){const r=this.texData.get(e.dataId),s=this.texData.get(t.dataId),[o,a]=ke(e.shape,t.shape,r.values,s.values,n);return this.makeOutput(a,n,o)}if((0,o.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,nt,e.dtype);const r=new st(nt,e.shape,t.shape);return this.compileAndRun(r,[e,t],e.dtype)}localResponseNormalization4D(e,t,n,r,s){const a=(0,o.env)().getBool("WEBGL_PACK_NORMALIZATION")?new pn(e.shape,t,n,r,s):new dn(e.shape,t,n,r,s);return this.compileAndRun(a,[e])}LRNGrad(e,t,n,r,s,o,a){const i=new hn(t.shape,r,s,o,a);return this.compileAndRun(i,[t,n,e])}tile(e,t){if("string"===e.dtype){const n=this.readSync(e.dataId).map((e=>o.util.decodeString(e))),r=(0,o.buffer)(e.shape,e.dtype,n);return dr(r,t)}const n=new Hn(e.shape,t);return this.compileAndRun(n,[e])}pad(e,t,n){const r=(0,o.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new wn(e.shape,t,n):new yn(e.shape,t,n);return this.compileAndRun(r,[e])}gather(e,t,n){const r=this.tryRunOnCpuOrThrow([e,t],(()=>this.cpuBackend.gather(e,t,n)));if(r)return r;const s=new Mt(e.shape,t.size,n);return this.compileAndRun(s,[e,t])}batchToSpaceND(e,t,n){o.util.assert(e.rank<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const r=t.reduce(((e,t)=>e*t)),s=o.backend_util.getReshaped(e.shape,t,r),a=o.backend_util.getPermuted(s.length,t.length),i=o.backend_util.getReshapedPermuted(e.shape,t,r),u=o.backend_util.getSliceBeginCoords(n,t.length),l=o.backend_util.getSliceSize(i,n,t.length);return(0,o.transpose)(e.reshape(s),a).reshape(i).slice(u,l)}spaceToBatchND(e,t,n){o.util.assert(e.rank<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const r=t.reduce(((e,t)=>e*t)),s=[[0,0]];s.push(...n);for(let n=1+t.length;n<e.shape.length;++n)s.push([0,0]);const a=e.pad(s),i=o.backend_util.getReshaped(a.shape,t,r,!1),u=o.backend_util.getPermuted(i.length,t.length,!1),l=o.backend_util.getReshapedPermuted(a.shape,t,r,!1),c=(0,o.transpose)(a.reshape(i),u);return(0,o.reshape)(c,l)}reduce(e,t,n){const r=e.shape[0],s=e.shape[1],a=o.backend_util.computeOptimalWindowSize(s),i=Math.ceil(s/a),u=new Cn({windowSize:a,inSize:s,batchSize:r,outSize:i},t),l=this.compileAndRun(u,[e],n);return 1===l.shape[1]?l:this.reduce(l,t,n)}argReduce(e,t,n=null){let r=e.shape[0],s=e.shape[1];null!=n&&(r=n.shape[0],s=n.shape[1]);const a=o.backend_util.computeOptimalWindowSize(s),i={windowSize:a,inSize:s,batchSize:r,outSize:Math.ceil(s/a)},u=new Ae(i,t,null==n),l=[e];null!=n&&l.push(n);const c=this.compileAndRun(u,l,"int32");return 1===c.shape[1]?c:this.argReduce(e,t,c)}argReducePacked(e,t,n=null){const r=null!=n?n.shape:e.shape,s=r[r.length-1],a=o.backend_util.computeOptimalWindowSize(s),i=new Ye(r,a,t,null==n),u=null==n?[e]:[e,n],l=this.compileAndRun(i,u,"int32");return l.rank===e.rank?this.argReducePacked(e,t,l):l}sum(e,t){o.backend_util.assertAxesAreInnerMostDims("sum",t,e.rank);const[n,r]=o.backend_util.computeOutAndReduceShapes(e.shape,t),s=o.util.sizeFromShape(r),a=e.as2D(-1,s),i=o.sumOutType(e.dtype);return this.reduce(a,"sum",i).reshape(n)}prod(e,t){const n=this.tryRunOnCpuOrThrow([e],(()=>this.cpuBackend.prod(e,t)));if(n)return n;const[r,s]=o.backend_util.computeOutAndReduceShapes(e.shape,t),a=o.util.sizeFromShape(s),i=e.as2D(-1,a),u=o.sumOutType(e.dtype);return this.reduce(i,"prod",u).reshape(r)}unsortedSegmentSum(e,t,n){let r=0;const s=o.backend_util.getAxesPermutation([r],e.rank);let a=e;null!=s&&(a=(0,o.transpose)(e,s),r=o.backend_util.getInnerMostAxes(1,e.rank)[0]);const i=lr.computeOutShape(a.shape,r,n),u=o.util.sizeFromShape([a.shape[r]]),l=a.as2D(-1,u),c=o.sumOutType(e.dtype);let d=this.segOpCompute(l,"unsortedSegmentSum",t,c,n).reshape(i);return null!=s&&(d=(0,o.transpose)(d,o.backend_util.getUndoAxesPermutation(s))),d}segOpCompute(e,t,n,r,s){const a=e.shape[0],i=e.shape[1],u=lr.segOpComputeOptimalWindowSize(i,s),l=new Dn({windowSize:u,inSize:i,batchSize:a,numSegments:s},t),c=this.compileAndRun(l,[e,n],r);return c.shape[1]===s?c:(n=(0,o.range)(0,s).tile([i/u]),this.segOpCompute(c,t,n,r,s))}argMinMaxReduce(e,t,n){const r=[t];if(o.backend_util.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),r,e.rank),!(0,o.env)().getBool("WEBGL_PACK_REDUCE")||e.rank<=2){const[t,s]=o.backend_util.computeOutAndReduceShapes(e.shape,r),a=o.util.sizeFromShape(s),i=e.as2D(-1,a);return this.argReduce(i,n).reshape(t)}return this.argReducePacked(e,n)}argMin(e,t){return this.argMinMaxReduce(e,t,"min")}argMax(e,t){return this.argMinMaxReduce(e,t,"max")}cumsum(e,t,n,r){if(t!==e.rank-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${e.rank-1} but got axis=`+t);const s=e.shape[t];let o=e;for(let t=0;t<=Math.ceil(Math.log2(s))-1;t++){const n=new Ct(e.shape,!1,r),s=n.getCustomSetupFunc(t),a=o;o=this.compileAndRun(n,[o],o.dtype,s),a.dispose()}if(n){const t=new Ct(e.shape,n,r),s=o;o=this.compileAndRun(t,[o]),s.dispose()}return o}equal(e,t){if((0,o.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,"\n  return vec4(equal(a, b));\n","bool");const n=new st("return float(a == b);",e.shape,t.shape);return this.compileAndRun(n,[e,t],"bool")}notEqual(e,t){if((0,o.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,"\n  return vec4(notEqual(a, b));\n","bool");const n=new st("return float(a != b);",e.shape,t.shape);return this.compileAndRun(n,[e,t],"bool")}less(e,t){const n=this.tryRunOnCpuOrThrow([e,t],(()=>this.cpuBackend.less(e,t)));if(n)return n;if((0,o.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,"\n  return vec4(lessThan(a, b));\n","bool");const r=new st("return float(a < b);",e.shape,t.shape);return this.compileAndRun(r,[e,t],"bool")}lessEqual(e,t){if((0,o.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,"\n  return vec4(lessThanEqual(a, b));\n","bool");const n=new st("return float(a <= b);",e.shape,t.shape);return this.compileAndRun(n,[e,t],"bool")}greater(e,t){const n=this.tryRunOnCpuOrThrow([e,t],(()=>this.cpuBackend.greater(e,t)));if(n)return n;if((0,o.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,"\n  return vec4(greaterThan(a, b));\n","bool");const r=new st("return float(a > b);",e.shape,t.shape);return this.compileAndRun(r,[e,t],"bool")}greaterEqual(e,t){if((0,o.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,"\n  return vec4(greaterThanEqual(a, b));\n","bool");const n=new st("return float(a >= b);",e.shape,t.shape);return this.compileAndRun(n,[e,t],"bool")}logicalNot(e){const t=new Gn(e.shape,"return float(!(x >= 1.0));");return this.compileAndRun(t,[e])}logicalAnd(e,t){if((0,o.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n","bool");const n=new st("return float(a >= 1.0 && b >= 1.0);",e.shape,t.shape);return this.compileAndRun(n,[e,t],"bool")}logicalOr(e,t){if((0,o.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n","bool");const n=new st("return float(a >= 1.0 || b >= 1.0);",e.shape,t.shape);return this.compileAndRun(n,[e,t],"bool")}select(e,t,n){const r=new Bn(e.rank,t.shape,t.rank);return this.compileAndRun(r,[e,t,n],(0,o.upcastType)(t.dtype,n.dtype))}where(e){o.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return pr(e.shape,t)}topk(e,t,n){const r=e.dataSync();return hr(r,e.shape,e.dtype,t,n)}min(e,t){o.backend_util.assertAxesAreInnerMostDims("min",t,e.rank);const[n,r]=o.backend_util.computeOutAndReduceShapes(e.shape,t),s=o.util.sizeFromShape(r),a=e.as2D(-1,s);return this.reduce(a,"min",a.dtype).reshape(n)}minimum(e,t){const n=this.tryRunOnCpuOrThrow([e,t],(()=>this.cpuBackend.minimum(e,t)));if(n)return n;const r=(0,o.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new at("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",e.shape,t.shape):new st("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",e.shape,t.shape);return this.compileAndRun(r,[e,t])}mod(e,t){const n=(0,o.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new at("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",e.shape,t.shape):new st("if (b == 0.0) return NAN;\n  return mod(a, b);",e.shape,t.shape);return this.compileAndRun(n,[e,t])}maximum(e,t){const n=this.tryRunOnCpuOrThrow([e,t],(()=>this.cpuBackend.maximum(e,t)));if(n)return n;const r=(0,o.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new at("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",e.shape,t.shape):new st("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",e.shape,t.shape);return this.compileAndRun(r,[e,t])}all(e,t){o.backend_util.assertAxesAreInnerMostDims("all",t,e.rank);const[n,r]=o.backend_util.computeOutAndReduceShapes(e.shape,t),s=o.util.sizeFromShape(r),a=e.as2D(-1,s);return this.reduce(a,"all",a.dtype).reshape(n)}any(e,t){o.backend_util.assertAxesAreInnerMostDims("any",t,e.rank);const[n,r]=o.backend_util.computeOutAndReduceShapes(e.shape,t),s=o.util.sizeFromShape(r),a=e.as2D(-1,s);return this.reduce(a,"any",a.dtype).reshape(n)}floorDiv(e,t){const n="int32";if((0,o.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",n);const r=new st("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",e.shape,t.shape);return this.compileAndRun(r,[e,t],n)}add(e,t){if("complex64"===e.dtype&&"complex64"===t.dtype)return this.complexSeparableBinaryOp(e,t,et);const n=(0,o.upcastType)(e.dtype,t.dtype);if(this.shouldExecuteOnCPU([e,t])){const r=this.texData.get(e.dataId),s=this.texData.get(t.dataId),[o,a]=me(e.shape,t.shape,r.values,s.values,n);return this.makeOutput(a,n,o)}if((0,o.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,et,n);const r=new st(et,e.shape,t.shape);return this.compileAndRun(r,[e,t],n)}packedUnaryOp(e,t,n){const r=new ir(e.shape,t);return this.compileAndRun(r,[e],n)}packedBinaryOp(e,t,n,r,s=!1){const o=new at(n,e.shape,t.shape,s);return this.compileAndRun(o,[e,t],r)}complexSeparableBinaryOp(e,t,n){const r=this.texData.get(e.dataId),s=this.texData.get(t.dataId),[a,i]=[[r.complexTensors.real,s.complexTensors.real],[r.complexTensors.imag,s.complexTensors.imag]].map((r=>{const[s,a]=r,i=this.makeComplexComponentTensorInfo(e,s),u=this.makeComplexComponentTensorInfo(t,a),l=new st(n,e.shape,t.shape);return this.compileAndRun(l,[i,u],(0,o.upcastType)(s.dtype,a.dtype))})),u=this.complex(a,i);return a.dispose(),i.dispose(),u}makeComplexComponentTensorInfo(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}addN(e){if(1===e.length)return e[0];if(e.length>(0,o.env)().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(e.length/2),n=this.addN(e.slice(0,t)),r=this.addN(e.slice(t));return this.addN([n,r])}const t=e.map((e=>e.dtype)).reduce(((e,t)=>(0,o.upcastType)(e,t))),n=e.map((e=>e.shape)),r=(0,o.env)().getBool("WEBGL_PACK")?new Te(e[0].shape,n):new Ee(e[0].shape,n);return this.compileAndRun(r,e,t)}subtract(e,t){if("complex64"===e.dtype&&"complex64"===t.dtype)return this.complexSeparableBinaryOp(e,t,tt);const n=(0,o.upcastType)(e.dtype,t.dtype);if(this.shouldExecuteOnCPU([e,t])){const r=this.texData.get(e.dataId),s=this.texData.get(t.dataId),[o,a]=$e(e.shape,t.shape,r.values,s.values,n);return this.makeOutput(a,n,o)}if((0,o.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,tt,e.dtype);const r=new st(tt,e.shape,t.shape);return this.compileAndRun(r,[e,t],n)}pow(e,t){const n=(0,o.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new at("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",e.shape,t.shape):new st("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",e.shape,t.shape),r=(0,o.upcastType)(e.dtype,t.dtype);return this.compileAndRun(n,[e,t],r)}ceil(e){if(this.shouldExecuteOnCPU([e])){const t=ge(this.texData.get(e.dataId).values,e.dtype);return this.makeOutput(e.shape,e.dtype,t)}if((0,o.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Jn,e.dtype);const t=new Gn(e.shape,Jn);return this.compileAndRun(t,[e])}floor(e){if(this.shouldExecuteOnCPU([e])){const t=be(this.texData.get(e.dataId).values,e.dtype);return this.makeOutput(e.shape,e.dtype,t)}if((0,o.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Zn,e.dtype);const t=new Gn(e.shape,Zn);return this.compileAndRun(t,[e])}sign(e){const t=new Gn(e.shape,"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");return this.compileAndRun(t,[e])}isNaN(e){const t=new Gn(e.shape,"return float(isnan(x));");return this.compileAndRun(t,[e],"bool")}isInf(e){const t=new Gn(e.shape,"return float(isinf(x));");return this.compileAndRun(t,[e],"bool")}isFinite(e){const t=new Gn(e.shape,"return float(!isnan(x) && !isinf(x));");return this.compileAndRun(t,[e],"bool")}round(e){const t=new Gn(e.shape,"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");return this.compileAndRun(t,[e])}exp(e){if(this.shouldExecuteOnCPU([e])){const t=xe(this.texData.get(e.dataId).values,e.dtype);return this.makeOutput(e.shape,e.dtype,t)}if((0,o.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,er,e.dtype);const t=new Gn(e.shape,er);return this.compileAndRun(t,[e])}expm1(e){if(this.shouldExecuteOnCPU([e])){const t=ve(this.texData.get(e.dataId).values,e.dtype);return this.makeOutput(e.shape,e.dtype,t)}if((0,o.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,tr,e.dtype);const t=new Gn(e.shape,tr);return this.compileAndRun(t,[e])}softmax(e,t){const n=o.util.parseAxisParam([t],e.shape),r=(0,o.max)(e,n),s=o.backend_util.expandShapeToKeepDim(r.shape,n),a=this.subtract(e,r.reshape(s)),i=this.exp(a),u=this.sum(i,n).reshape(s);return(0,o.div)(i,u)}log(e){if(this.shouldExecuteOnCPU([e])){const t=ye(this.texData.get(e.dataId).values,e.dtype);return this.makeOutput(e.shape,e.dtype,t)}if((0,o.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",e.dtype);const t=new Gn(e.shape,"if (x < 0.0) return NAN;\n  return log(x);");return this.compileAndRun(t,[e])}log1p(e){const t=new Gn(e.shape,"return log(1.0 + x);");return this.compileAndRun(t,[e])}sqrt(e){const t=new Gn(e.shape,"return sqrt(x);");return this.compileAndRun(t,[e])}rsqrt(e){if(this.shouldExecuteOnCPU([e])){const t=Ie(this.texData.get(e.dataId).values,e.dtype);return this.makeOutput(e.shape,e.dtype,t)}const t=new Gn(e.shape,"return inversesqrt(x);");return this.compileAndRun(t,[e])}reciprocal(e){const t=new Gn(e.shape,"return 1.0 / x;");return this.compileAndRun(t,[e])}relu(e){let t;return t=(0,o.env)().getBool("WEBGL_PACK")?new ir(e.shape,sr):new Gn(e.shape,qn),this.compileAndRun(t,[e])}relu6(e){let t;return t=(0,o.env)().getBool("WEBGL_PACK")?new ir(e.shape,or):new Gn(e.shape,Kn),this.compileAndRun(t,[e])}prelu(e,t){const n=(0,o.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new at(ot,e.shape,t.shape):new st(rt,e.shape,t.shape);return this.compileAndRun(n,[e,t])}elu(e){if((0,o.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,ar,e.dtype);const t=new Gn(e.shape,jn);return this.compileAndRun(t,[e])}eluDer(e,t){const n=(0,o.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new at("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",e.shape,t.shape):new st("return (b >= 1.0) ? a : a * (b + 1.0);",e.shape,t.shape);return this.compileAndRun(n,[e,t])}selu(e){const t=new Gn(e.shape,Yn);return this.compileAndRun(t,[e])}int(e){const t=new Gn(e.shape,"return float(int(x));");return this.compileAndRun(t,[e],"int32")}clip(e,t,n){let r;r=(0,o.env)().getBool("WEBGL_PACK_CLIP")?new ut(e.shape):new it(e.shape);const s=r.getCustomSetupFunc(t,n);return this.compileAndRun(r,[e],null,s)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=fe(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if((0,o.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Xn,e.dtype);const t=new Gn(e.shape,Xn);return this.compileAndRun(t,[e])}complexAbs(e){const t=this.texData.get(e.dataId),n=new lt(e.shape),r=[this.makeComplexComponentTensorInfo(e,t.complexTensors.real),this.makeComplexComponentTensorInfo(e,t.complexTensors.imag)];return this.compileAndRun(n,r)}sigmoid(e){const t=new Gn(e.shape,"return 1.0 / (1.0 + exp(-1.0 * x));");return this.compileAndRun(t,[e])}softplus(e){const t=new Gn(e.shape,"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");return this.compileAndRun(t,[e])}asin(e){const t=new Gn(e.shape,"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n");return this.compileAndRun(t,[e])}acos(e){const t=new Gn(e.shape,"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n");return this.compileAndRun(t,[e])}atan(e){const t=new Gn(e.shape,"if (isnan(x)) return x;\n  return atan(x);\n");return this.compileAndRun(t,[e])}sinh(e){const t=new Gn(e.shape,"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");return this.compileAndRun(t,[e])}cosh(e){const t=new Gn(e.shape,"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");return this.compileAndRun(t,[e])}tanh(e){const t=new Gn(e.shape,"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");return this.compileAndRun(t,[e])}asinh(e){const t=new Gn(e.shape,"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));");return this.compileAndRun(t,[e])}acosh(e){const t=new Gn(e.shape,"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));");return this.compileAndRun(t,[e])}atanh(e){const t=new Gn(e.shape,"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;");return this.compileAndRun(t,[e])}erf(e){const t=new Gn(e.shape,nr);return this.compileAndRun(t,[e])}step(e,t){const n=new Gn(e.shape,function(e=0){return`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${e});\n  `}(t));return this.compileAndRun(n,[e])}conv2dByMatMul(e,t,n,r,s,a){const i=e.shape,u=this.texData.get(e.dataId),l=n.inChannels,c=i[0]*i[1]*i[2],d=n.outChannels,h="channelsLast"===n.dataFormat,p=(1===c||1===d)&&l>1e3,f=i[2]%2!=0&&!!u.isPacked;if(p||!(0,o.env)().getBool("WEBGL_LAZILY_UNPACK")||!(0,o.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!f){const u=h?i[0]*i[1]*i[2]:i[0]*i[2]*i[3],l=(0,o.reshape)(e,[1,u,n.inChannels]),c=(0,o.reshape)(t,[1,n.inChannels,n.outChannels]),d=this.fusedBatchMatMul({a:l,b:c,transposeA:!1,transposeB:!1,bias:r,activation:s,preluActivationWeights:a});return(0,o.reshape)(d,n.outShape)}const m=h?i[0]*i[1]*(i[2]+1):i[0]*i[2]*(i[3]+1),g={dataId:e.dataId,shape:[1,m,n.inChannels],dtype:e.dtype},x=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,o.util.assert(Q(u.shape,g.shape),(()=>`packed reshape ${u.shape} to ${g.shape} isn't free`));const v=(0,o.reshape)(t,[1,n.inChannels,n.outChannels]),b=this.fusedBatchMatMul({a:g,b:v,transposeA:!1,transposeB:!1,bias:r,activation:s,preluActivationWeights:a}),y=this.texData.get(b.dataId);return o.util.assert(y.isPacked,(()=>"batchMatMul result is expected to be packed")),u.shape=x,y.shape=n.outShape,(0,o.engine)().makeTensorFromDataId(b.dataId,n.outShape,b.dtype)}conv2dWithIm2Row(e,t,n,r,s,o){const{filterWidth:a,filterHeight:i,inChannels:u,outWidth:l,outHeight:c,dataFormat:d}=n,h="channelsLast"===d,p=a*i*u,f=c*l,m=[p,f],g=e.squeeze([0]),x=t.reshape([1,p,-1]),v=new cn(m,g.shape,n),b=this.compileAndRun(v,[g]).reshape([1,m[0],m[1]]),y=null!=r,w=null!=o,k=s?mr(s,!0):null,I=new gn(b.shape,[1,f,n.outChannels],!0,!1,y,k,w),C=[b,x];r&&C.push(r),w&&C.push(o);const $=this.compileAndRun(I,C);return h?$.reshape([1,c,l,n.outChannels]):$.reshape([1,n.outChannels,c,l])}fusedConv2d({input:e,filter:t,convInfo:n,bias:r,activation:s,preluActivationWeights:a}){if(1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))return this.conv2dByMatMul(e,t,n,r,s,a);if((0,o.env)().getBool("WEBGL_CONV_IM2COL")&&1===e.shape[0])return this.conv2dWithIm2Row(e,t,n,r,s,a);const i=null!=r,u=null!=a,l=s?mr(s,!1):null,c=new bt(n,i,l,u),d=[e,t];return r&&d.push(r),a&&d.push(a),this.compileAndRun(c,d)}conv2d(e,t,n){if(1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))return this.conv2dByMatMul(e,t,n);if((0,o.env)().getBool("WEBGL_CONV_IM2COL")&&1===e.shape[0])return this.conv2dWithIm2Row(e,t,n);const r=new bt(n);return this.compileAndRun(r,[e,t])}conv2dDerInput(e,t,n){const r=new ft(n);return this.compileAndRun(r,[e,t])}conv2dDerFilter(e,t,n){const r=new pt(n);return this.compileAndRun(r,[e,t])}fusedDepthwiseConv2D({input:e,filter:t,convInfo:n,bias:r,activation:s,preluActivationWeights:a}){const i=(0,o.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&n.strideWidth<=2&&n.outChannels/n.inChannels==1,u=s?mr(s,i):null,l=[e,t],c=null!=r,d=null!=a;let h;return c&&l.push(r),d&&l.push(a),i?(h=new kt(n,c,u,d),this.compileAndRun(h,l)):(h=new wt(n,c,u,d),this.compileAndRun(h,l))}depthwiseConv2D(e,t,n){let r;return(0,o.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&n.strideWidth<=2&&n.outChannels/n.inChannels==1?(r=new kt(n),this.compileAndRun(r,[e,t])):(r=new wt(n),this.compileAndRun(r,[e,t]))}depthwiseConv2DDerInput(e,t,n){const r=new vt(n);return this.compileAndRun(r,[e,t])}depthwiseConv2DDerFilter(e,t,n){const r=new xt(n);return this.compileAndRun(r,[e,t])}conv3d(e,t,n){const r=new yt(n);return this.compileAndRun(r,[e,t])}conv3dDerInput(e,t,n){const r=new gt(n);return this.compileAndRun(r,[e,t])}conv3dDerFilter(e,t,n){const r=new mt(n);return this.compileAndRun(r,[e,t])}cast(e,t){return o.backend_util.castTensor(e,t,this)}unstack(e,t){const n=e.shape[t],r=new Array(e.rank-1);let s=0;for(let n=0;n<e.rank;n++)n!==t&&(r[s++]=e.shape[n]);const o=new Array(e.rank).fill(0),a=e.shape.slice();a[t]=1;const i=new Array(n);for(let n=0;n<i.length;n++)o[t]=n,i[n]=this.slice(e,o,a).reshape(r);return i}avgPool3d(e,t){const n=new In(t,"avg",!1);return this.compileAndRun(n,[e],"float32")}avgPool3dBackprop(e,t,n){const r=new Je(n);return this.compileAndRun(r,[e],t.dtype)}maxPool3d(e,t){const n=new In(t,"max",!1);return this.compileAndRun(n,[e],"float32")}maxPool3dBackprop(e,t,n,r){const s=new In(r,"max",!0),o=this.compileAndRun(s,[t]),a=new mn(r),i=this.compileAndRun(a,[e,o],t.dtype);return o.dispose(),i}resizeBilinear(e,t,n,r){const s=(0,o.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new En(e.shape,t,n,r):new Rn(e.shape,t,n,r);return this.compileAndRun(s,[e],"float32")}resizeBilinearBackprop(e,t,n){const r=new Sn(e,t,n);return this.compileAndRun(r,[e])}resizeNearestNeighbor(e,t,n,r){const s=new An(e.shape,t,n,r);return this.compileAndRun(s,[e])}resizeNearestNeighborBackprop(e,t,n){const r=new Tn(e,t,n);return this.compileAndRun(r,[e])}multinomial(e,t,n,r){const s=t?e:(0,o.softmax)(e),a=s.shape[0],i=s.shape[1],u=new xn(a,i,n),l=u.getCustomSetupFunc(r);return this.compileAndRun(u,[s],"int32",l)}oneHot(e,t,n,r){const s=new vn(e.size,t,n,r);return this.compileAndRun(s,[e])}diag(e){const t=new At(e.size);return this.compileAndRun(t,[e])}cropAndResize(e,t,n,r,s,o){const a=new It(e.shape,t.shape,r,s,o);return this.compileAndRun(a,[e,t,n],"float32")}depthToSpace(e,t,n){o.util.assert(t>1,(()=>"blockSize should be > 1 for depthToSpace, but was: "+t));const r=e.shape[0],s="NHWC"===n?e.shape[1]:e.shape[2],a="NHWC"===n?e.shape[2]:e.shape[3],i="NHWC"===n?e.shape[3]:e.shape[1],u=s*t,l=a*t,c=i/(t*t),d=new Tt("NHWC"===n?[r,u,l,c]:[r,c,u,l],t,n);return this.compileAndRun(d,[e])}split(e,t,n){return cr(e,t,n)}scatterND(e,t,n){const{sliceRank:r,numUpdates:s,sliceSize:a,strides:i,outputSize:u}=o.backend_util.calculateShapes(t,e,n),l=[u/a,a],c=e.reshape([s,r]),d=t.reshape([s,a]);if(0===u)return o.backend_util.reshapeTensor((0,o.tensor)([]),n);const h=(0,o.scalar)(0),p=new Fn(s,r,c.rank,d.rank,i,l);return this.compileAndRun(p,[d,c,h]).reshape(n)}sparseToDense(e,t,n,r){const{sliceRank:s,numUpdates:a,strides:i,outputSize:u}=o.backend_util.calculateShapes(t,e,n),l=new Fn(a,s,e.rank,t.rank,i,[u,1],!1);return this.compileAndRun(l,[t,e,r]).reshape(n)}fft(e){return this.fftImpl(e,!1)}ifft(e){return this.fftImpl(e,!0)}fftImpl(e,t){const n=this.texData.get(e.dataId),r=new Bt("return real * expR - imag * expI;",e.shape,t),s=new Bt("return real * expI + imag * expR;",e.shape,t),o=[this.makeComplexComponentTensorInfo(e,n.complexTensors.real),this.makeComplexComponentTensorInfo(e,n.complexTensors.imag)],a=this.compileAndRun(r,o),i=this.compileAndRun(s,o),u=this.complex(a,i).as2D(e.shape[0],e.shape[1]);return a.dispose(),i.dispose(),u}gatherND(e,t){const n=t.shape,r=n[n.length-1],[s,a,i,u]=o.backend_util.prepareAndValidate(e,t),l=t.reshape([a,r]),c=e.reshape([e.size/i,i]),d=new Pt(r,u,[a,i]);return this.compileAndRun(d,[c,l]).reshape(s)}fill(e,t,n){if("string"===(n=n||o.util.inferDtype(t))){const r=o.util.getArrayFromDType(n,o.util.sizeFromShape(e));return r.fill(t),(0,o.engine)().makeTensor(r,e,n,this)}{const r=new Ot(e,t),s=r.getCustomSetupFunc(t);return this.compileAndRun(r,[],n,s)}}onesLike(e){if("string"===e.dtype)throw new Error("onesLike is not supported under string dtype");return this.fill(e.shape,1,e.dtype)}zerosLike(e){return this.fill(e.shape,"string"===e.dtype?"":0,e.dtype)}linspace(e,t,n){return o.backend_util.linspaceImpl(e,t,n)}makeTensorInfo(e,t,n){const r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){const{dataId:r}=this.makeTensorInfo(e,t,n);return(0,o.engine)().makeTensorFromDataId(r,e,t,this)}unpackTensor(e){const t=new ur(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new bn(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[X(e.shape),...q(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[X(t),...q(t)],o=new $n(s,n),a=this.runWebGLProgram(o,[r],e.dtype,null,!0);return{dataId:a.dataId,shape:t,dtype:a.dtype}}decode(e){const t=this.texData.get(e),{isPacked:n,shape:r,dtype:s}=t,o=K(r);let a;return a=n?new Et(o):new Rt(o),{dtype:s,shape:r,dataId:this.runWebGLProgram(a,[{shape:o,dtype:s,dataId:e}],s,null,!0).dataId}}runWebGLProgram(e,t,n,r,s=!1){const a=this.makeTensorInfo(e.outputShape,n),i=this.texData.get(a.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===c.DENSE){const t=f(e.outputShape);i.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(i.usage=e.outTexUsage),0===o.util.sizeFromShape(a.shape))return i.values=o.util.getTypedArrayFromDType(a.dtype,0),a;const u=[],l=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&o.util.sizeFromShape(t.shape)<=(0,o.env)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}else if(!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),u.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!Q(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),u.push(t),n=this.texData.get(t.dataId),e.shape=r}return this.uploadToGPU(t.dataId),{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(a.dataId);const d={shape:a.shape,texData:i,isUniform:!1},h=function(e,t,n){let r="";t.concat(n).forEach((e=>{const t=null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0,n=e.isUniform?"uniform":e.texData.texShape;r+=`${e.shape}_${n}_${t}`}));const s=e.userCode;let o=e.constructor.name;return o+="_"+r+"_"+s,o}(e,l,d),p=this.getAndSaveBinary(h,(()=>function(e,t,n,r){const s=t.userCode,a=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),i=a.map((e=>e.shapeInfo)),u={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},l=Pe(a,u,s,t.packedInputs),c=e.createProgram(l);let d=null;const h=e.getUniformLocation(c,"NAN",!1);1===(0,o.env)().getNumber("WEBGL_VERSION")&&(d=e.getUniformLocation(c,"INFINITY",!1));const p={};for(let n=0;n<t.variableNames.length;n++){const r=t.variableNames[n],s=!1;p[r]=e.getUniformLocation(c,r,s),p["offset"+r]=e.getUniformLocation(c,"offset"+r,s)}return{program:t,source:l,webGLProgram:c,uniformLocations:p,inShapeInfos:i,outShapeInfo:u,infLoc:d,nanLoc:h}}(this.gpgpu,e,l,d))),m=null!=this.activeTimers;let g;if(m&&(g=this.startTimer()),function(e,t,n,r,s){ln(t.inShapeInfos,n),ln([t.outShapeInfo],[r]);const a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a,i[0],i[1]):e.setOutputMatrixTexture(a,i[0],i[1]),e.setProgram(t.webGLProgram),1===(0,o.env)().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach(((n,r)=>{const s=t.program.variableNames[r],a=t.uniformLocations[s],i=t.uniformLocations["offset"+s];if(null!=a)if(n.isUniform)if(o.util.sizeFromShape(n.shape)<2)e.gl.uniform1f(a,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}else null!=n.texData.slice&&null!=i&&e.gl.uniform1i(i,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture,a,r)})),null!=s&&s(e,t.webGLProgram),e.executeProgram()}(this.gpgpu,p,l,d,r),u.forEach((e=>this.disposeIntermediateTensorInfo(e))),m&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)})),!(0,o.env)().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===s){const e=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),e}return a}compileAndRun(e,t,n,r,s=!1){n=n||t[0].dtype;const a=this.runWebGLProgram(e,t,n,r,s);return(0,o.engine)().makeTensorFromDataId(a.dataId,a.shape,a.dtype)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||((0,o.env)().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(0,o.tidy)((()=>{if(!(0,o.env)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=(0,o.env)().getBool("DEBUG");(0,o.env)().set("DEBUG",!1);const t=this.abs((0,o.scalar)(1e-8)).dataSync()[0];if((0,o.env)().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:s,texture:a,usage:i,isPacked:u}=t;if(null!=a)return;const l=null!=this.activeTimers;let c;l&&(c=o.util.now());let h=t.texShape;if(null==h&&(h=j(n,u),t.texShape=h),null!=s){const e=K(n);let a,i=h[1],p=h[0];const f=s instanceof Uint8Array;u?([i,p]=m(h[0],h[1]),a=new Dt(e,[p,i],f)):a=new Ft(e,[p,i],f);const g=this.makeTensorInfo([p,i],r);this.texData.get(g.dataId).usage=f?d.PIXELS:d.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(g.dataId),i,p,s);const x=!0,v=this.runWebGLProgram(a,[g],r,null,x),b=this.texData.get(v.dataId);t.texture=b.texture,t.texShape=b.texShape,t.isPacked=b.isPacked,t.usage=b.usage,this.disposeIntermediateTensorInfo(g),this.texData.delete(v.dataId),t.values=null,l&&(this.uploadWaitMs+=o.util.now()-c)}else{const e=this.acquireTexture(h,i,r,u);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error("Unknown dtype "+t)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*o.util.bytesPerElement(t)}tryRunOnCpuOrThrow(e,t){if(this.shouldExecuteOnCPU(e))try{return t()}catch(e){if((0,o.env)().getBool("IS_TEST"))throw new Error("CPU forwarding failed")}return null}}const xr="2.6.0";function vr(){(0,o.env)().set("WEBGL_FORCE_F16_TEXTURES",!0)}o.device_util.isBrowser()&&(0,o.registerBackend)("webgl",(()=>new gr),2);const br={forceHalfFloat:vr};function yr(e){return({inputs:t,backend:n})=>{const{x:r}=t,s=n,o=new Gn(r.shape,e);return s.runWebGLProgram(o,[r],r.dtype)}}function wr(e,t,n,r){return({inputs:s,backend:a})=>{const{a:i,b:u}=s,l=a,c=(0,o.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new at(t,i.shape,u.shape,!!n):new st(e,i.shape,u.shape),d=r||i.dtype;return l.runWebGLProgram(c,[i,u],d)}}const kr=wr("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n","\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"),Ir={kernelName:o.Atan2,backendName:"webgl",kernelFunc:kr};function Cr(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const $r={kernelName:o.Identity,backendName:"webgl",kernelFunc:Cr},Sr={kernelName:o.AvgPool,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;de(s,"avgPool");const{filterSize:a,strides:i,pad:u,dimRoundingMode:l}=r;o.util.assert(o.backend_util.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const c=o.backend_util.computePool2DInfo(s.shape,a,i,1,u,l);if(1===c.filterWidth&&1===c.filterHeight&&o.util.arraysEqual(c.inShape,c.outShape))return Cr({inputs:{x:s},backend:n});const d=new kn(c,"avg",!1);return n.runWebGLProgram(d,[s],"float32")}},Rr={kernelName:o.AvgPoolBackprop,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;de([s,a],"avgPoolBackprop");const{filterSize:u,strides:l,pad:c}=r,d=o.backend_util.computePool2DInfo(i.shape,u,l,1,c),h=new Qe(d);return n.runWebGLProgram(h,[s],i.dtype)}};class Er{constructor(e,t,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],o.backend_util.assertAndGetBroadcastShape(e,t),o.backend_util.assertAndGetBroadcastShape(e,n);let i="0.0";null!=r&&(o.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="1.0";null!=s&&(o.backend_util.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${u};\n        float inv = scale * inversesqrt(variance + float(${a}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Tr{constructor(e,t,n,r,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],o.backend_util.assertAndGetBroadcastShape(e,t),o.backend_util.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";null!=r&&(o.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="vec4(1.0)";null!=s&&(o.backend_util.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${u};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${a}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const Ar={kernelName:o.FusedBatchNorm,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:s,variance:a,offset:i,scale:u}=e;o.util.assert(s.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),o.util.assert(null==i||s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),o.util.assert(null==u||s.shape.length===u.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=n;null==l&&(l=.001);const c=[r,s,a];let d=null;null!=i&&(d=i.shape,c.push(i));let h=null;null!=u&&(h=u.shape,c.push(u));const p=(0,o.env)().getBool("WEBGL_PACK_NORMALIZATION")?new Tr(r.shape,s.shape,a.shape,d,h,l):new Er(r.shape,s.shape,a.shape,d,h,l);return t.runWebGLProgram(p,c,c[0].dtype)}},_r=yr("if (isnan(x)) return x;\n  return cos(x);\n"),Nr={kernelName:o.Cos,backendName:"webgl",kernelFunc:_r},Fr=wr("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;","\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",!0),Dr={kernelName:o.Div,backendName:"webgl",kernelFunc:Fr};class Br{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Or={kernelName:o.FlipLeftRight,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=new Br(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}};class Mr{constructor(e){this.variableNames=["A"];const t=Fe(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class Pr{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Fe(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const Lr={kernelName:o.FromPixels,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:a}=r,i="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,u="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,[l,c]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],h=[c,l],p=[c,l,a];(u||i)&&(null==Vr&&(Vr=document.createElement("canvas").getContext("2d")),Vr.canvas.width=l,Vr.canvas.height=c,Vr.drawImage(s,0,0,l,c),s=Vr.canvas);const f=n.makeTensorInfo(h,"int32");n.texData.get(f.dataId).usage=d.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(f.dataId),s);const m=(0,o.env)().getBool("WEBGL_PACK")?new Pr(p):new Mr(p),g=n.runWebGLProgram(m,[f],"int32");return n.disposeData(f.dataId),g}};let Vr;function Wr(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=n,u=o.util.sizeFromShape(s.shape),l=o.util.inferFromImplicitShape(a,u),c=o.util.sizeFromShape(l);o.util.assert(u===c,(()=>`The new shape (${l}) has ${c} elements and the old shape (${s.shape}) has ${u} elements. The new shape and old shape must have the same number of elements.`));const d=i.texData.get(s.dataId);return!d.isPacked||Q(s.shape,l)||null!==d.texture&&Q(d.shape,l)?(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function(e,t,n){const r=[X(e.shape),...q(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},o=[X(t),...q(t)],a=new $n(o,r),i=n.runWebGLProgram(a,[s],e.dtype,null,!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}(s,l,i)}const zr={kernelName:o.Reshape,backendName:"webgl",kernelFunc:Wr};class Ur{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;const r=qe(this.rank),s=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let t=0;t<e.length;t++)r[e[t]]=n[t];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class Hr{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=qe(this.rank),s=_e("rc",this.rank),o=new Array(this.rank);for(let e=0;e<t.length;e++)o[t[e]]=s[e];const a=`vec2(${o.slice(-2).join()})`,i=`++${s[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${i}) {\n        result[1] = ${u};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${u};\n        if(${i}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function Gr(e,t,n){const r=(0,o.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Hr(e.shape,t):new Ur(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}const Xr={kernelName:o.Max,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{reductionIndices:s,keepDims:a}=t,i=n,u=r.shape.length,l=o.util.parseAxisParam(s,r.shape);let c=l;const d=o.backend_util.getAxesPermutation(c,u),h=null!=d,p=i.shouldExecuteOnCPU([r]);let f=r;if(h){if(p){const e=i.texData.get(f.dataId).values,t=new Array(u);for(let e=0;e<t.length;e++)t[e]=r.shape[d[e]];const n=Se(e,r.shape,r.dtype,d,t);f=i.makeTensorInfo(t,r.dtype),i.texData.get(f.dataId).values=n}else f=Gr(r,d,i);c=o.backend_util.getInnerMostAxes(c.length,u)}o.backend_util.assertAxesAreInnerMostDims("max",c,u);const[m,g]=o.backend_util.computeOutAndReduceShapes(f.shape,c);let x,v=m;if(a&&(v=o.backend_util.expandShapeToKeepDim(m,l)),p){const e=i.texData.get(f.dataId).values,t=we(e,o.util.sizeFromShape(g),v,r.dtype);x=i.makeTensorInfo(v,r.dtype),i.texData.get(x.dataId).values=t}else x=function(e,t,n,r){const s=o.util.sizeFromShape(t),a=Wr({inputs:{x:e},attrs:{shape:[o.util.sizeFromShape(e.shape)/s,s]},backend:r}),i=function(e,t,n,r){const s=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=o.backend_util.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let a=e;for(let o=0;o<s.length;o++){const{inSize:i,windowSize:u,outSize:l}=s[o],c=new Cn({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:l},n),d=a;a=r.runWebGLProgram(c,[a],t),d.dataId!==e.dataId&&r.disposeData(d.dataId)}return a}(a,e.dtype,"max",r),u=Wr({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),u}(f,g,v,i);return h&&i.disposeIntermediateTensorInfo(f),x}},qr={kernelName:o.MaxPool,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;de(s,"maxPool");const{filterSize:a,strides:i,pad:u,dimRoundingMode:l}=r;o.util.assert(o.backend_util.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const c=o.backend_util.computePool2DInfo(s.shape,a,i,1,u,l);if(1===c.filterWidth&&1===c.filterHeight&&o.util.arraysEqual(c.inShape,c.outShape))return Cr({inputs:{x:s},backend:n});const d=new kn(c,"max",!1);return n.runWebGLProgram(d,[s],s.dtype)}},Kr={kernelName:o.MaxPoolBackprop,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,u=a;de([a,i],"maxPoolBackprop");const{filterSize:l,strides:c,pad:d,dimRoundingMode:h}=r,p=o.backend_util.computePool2DInfo(u.shape,l,c,1,d,h),f=new kn(p,"max",!0),m=n.runWebGLProgram(f,[u],u.dtype),g=new fn(p),x=n.runWebGLProgram(g,[s,m],u.dtype);return n.disposeIntermediateTensorInfo(m),x}},jr={kernelName:o.MaxPoolWithArgmax,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:u}=t,l=n;o.util.assert(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const c=[1,1];o.util.assert(o.backend_util.eitherStridesOrDilationsAreOne(a,c),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`));const d=o.backend_util.computePool2DInfo(r.shape,s,a,c,i),[h,p]=function(e,t,n,r){let s=new kn(n,"max",!1);const o=r.runWebGLProgram(s,[e],"float32");return s=new kn(n,"max",!0,!0,t),[o,r.runWebGLProgram(s,[e],"float32")]}(r,u,d,l);return[h,p]}},Yr={kernelName:o.NonMaxSuppressionV3,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{o.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{boxes:r,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u}=n,l=t,c=l.readSync(r.dataId),d=l.readSync(s.dataId),h=a,p=i,f=u;return o.kernel_impls.nonMaxSuppressionV3Impl(c,d,h,p,f)}},Qr=o.kernel_impls.nonMaxSuppressionV4Impl,Jr={kernelName:o.NonMaxSuppressionV4,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{o.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{boxes:r,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:l}=n,c=t,d=c.readSync(r.dataId),h=c.readSync(s.dataId),{selectedIndices:p,validOutputs:f}=Qr(d,h,a,i,u,l);return[p,f]}},Zr=o.kernel_impls.nonMaxSuppressionV5Impl,es={kernelName:o.NonMaxSuppressionV5,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{o.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{boxes:r,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=n,c=t,d=c.readSync(r.dataId),h=c.readSync(s.dataId),p=a,f=i,m=u,g=l,{selectedIndices:x,selectedScores:v}=Zr(d,h,p,f,m,g);return[x,v]}};class ts{constructor(e,t,n,r){this.variableNames=["Image"],this.outputShape=[];const s=e[1],a=e[2],i=Math.sin(t).toFixed(3),u=Math.cos(t).toFixed(3);this.outputShape=e;const[l,c]=o.backend_util.getImageCenter(r,s,a),d=l.toFixed(3),h=c.toFixed(3);let p="";p="number"==typeof n?`float outputValue = ${n.toFixed(2)};`:`\n        vec3 fill = vec3(${n.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - ${d}) * ${u} - (float(y) - ${h}) * ${i};\n          float coordYFloat = (float(x) - ${d}) * ${i} + (float(y) - ${h}) * ${u};\n          int coordX = int(round(coordXFloat + ${d}));\n          int coordY = int(round(coordYFloat + ${h}));\n          ${p}\n          if(coordX >= 0 && coordX < ${a} && coordY >= 0 && coordY < ${s}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const ns={kernelName:o.RotateWithOffset,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:o,center:a}=t,i=n,u=new ts(r.shape,s,o,a);return i.runWebGLProgram(u,[r],r.dtype)}},rs=yr("if (isnan(x)) return x;\n  return sin(x);\n"),ss={kernelName:o.Sin,backendName:"webgl",kernelFunc:rs},os=yr("return x * x;"),as={kernelName:o.Square,backendName:"webgl",kernelFunc:os},is="return (a - b) * (a - b);",us=wr(is,is),ls={kernelName:o.SquaredDifference,backendName:"webgl",kernelFunc:us},cs=yr("return tan(x);"),ds=[Ir,Sr,Rr,Ar,Nr,Dr,Or,Lr,$r,Xr,qr,Kr,jr,Yr,Jr,es,zr,ns,ss,as,ls,{kernelName:o.Tan,backendName:"webgl",kernelFunc:cs},{kernelName:o.Transpose,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{perm:s}=t,o=n,a=r.shape.length,i=new Array(a);for(let e=0;e<i.length;e++)i[e]=r.shape[s[e]];let u;if(o.shouldExecuteOnCPU([r])){const e=o.texData.get(r.dataId).values,t=Se(e,r.shape,r.dtype,s,i);u=o.makeTensorInfo(i,r.dtype),o.texData.get(u.dataId).values=t}else u=Gr(r,s,o);return u}},{kernelName:o.Unique,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:o}=t;de(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=r.readSync(o.dataId),{outputValues:i,outputShape:u,indices:l}=Re(a,s,o.shape,o.dtype);return[r.makeTensorInfo(u,o.dtype,i),r.makeTensorInfo([l.length],"int32",l)]}}];for(const e of ds)(0,o.registerKernel)(e)},22200:(e,t,n)=>{"use strict";function r(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,s=e.length,o=0,a=!1;for(;r<s;){o=r+(s-r>>>1);const i=n(t,e[o]);i>0?r=o+1:(s=o,a=!i)}return a?r:-r-1}(e,t,n||s)}(e,t,n),o=r<0?-(r+1):r;e.splice(o,0,t)}function s(e,t){return e>t?1:e<t?-1:0}n.d(t,{v:()=>r})},68713:(e,t,n)=>{"use strict";n.d(t,{JL:()=>r,Zu:()=>s});class r{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class s{time(e){return o("time")}read(e){return o("read")}readSync(e){return o("readSync")}numDataIds(){return o("numDataIds")}disposeData(e){return o("disposeData")}write(e,t,n){return o("write")}move(e,t,n,r){return o("move")}memory(){return o("memory")}floatPrecision(){return o("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}batchMatMul(e,t,n,r){return o("batchMatMul")}fusedBatchMatMul({a:e,b:t,transposeA:n,transposeB:r,bias:s,activation:a,preluActivationWeights:i}){return o("fusedBatchMatMul")}slice(e,t,n){return o("slice")}stridedSlice(e,t,n,r){return o("stridedSlice")}unstack(e,t){return o("unstack")}reverse(e,t){return o("reverse")}concat(e,t){return o("concat")}neg(e){return o("neg")}add(e,t){return o("add")}addN(e){return o("addN")}subtract(e,t){return o("subtract")}multiply(e,t){return o("multiply")}realDivide(e,t){return o("realDivide")}floorDiv(e,t){return o("floorDiv")}sum(e,t){return o("sum")}prod(e,t){return o("prod")}unsortedSegmentSum(e,t,n){return o("unsortedSegmentSum")}argMin(e,t){return o("argMin")}argMax(e,t){return o("argMax")}equal(e,t){return o("equal")}notEqual(e,t){return o("notEqual")}less(e,t){return o("less")}lessEqual(e,t){return o("lessEqual")}greater(e,t){return o("greater")}greaterEqual(e,t){return o("greaterEqual")}logicalNot(e){return o("logicalNot")}logicalAnd(e,t){return o("logicalAnd")}logicalOr(e,t){return o("logicalOr")}where(e){return o("where")}select(e,t,n){return o("select")}topk(e,t,n){return o("topk")}min(e,t){return o("min")}minimum(e,t){return o("minimum")}mod(e,t){return o("mod")}max(e,t){return o("max")}maximum(e,t){return o("maximum")}all(e,t){return o("all")}any(e,t){return o("any")}squaredDifference(e,t){return o("squaredDifference")}ceil(e){return o("ceil")}floor(e){return o("floor")}round(e){return o("round")}sign(e){return o("sign")}isNaN(e){return o("isNaN")}isInf(e){return o("isInf")}isFinite(e){return o("isFinite")}pow(e,t){return o("pow")}exp(e){return o("exp")}expm1(e){return o("expm1")}softmax(e,t){return o("softmax")}log(e){return o("log")}log1p(e){return o("log1p")}sqrt(e){return o("sqrt")}rsqrt(e){return o("rsqrt")}square(e){return o("square")}reciprocal(e){return o("reciprocal")}relu(e){return o("relu")}relu6(e){return o("relu6")}prelu(e,t){return o("prelu")}elu(e){return o("elu")}eluDer(e,t){return o("eluDer")}selu(e){return o("selu")}int(e){return o("int")}clip(e,t,n){return o("clip")}abs(e){return o("abs")}complexAbs(e){return o("complexAbs")}sigmoid(e){return o("sigmoid")}softplus(e){return o("softplus")}sin(e){return o("sin")}cos(e){return o("cos")}tan(e){return o("tan")}asin(e){return o("asin")}acos(e){return o("acos")}atan(e){return o("atan")}atan2(e,t){return o("atan2")}sinh(e){return o("sinh")}cosh(e){return o("cosh")}tanh(e){return o("tanh")}asinh(e){return o("asinh")}acosh(e){return o("acosh")}atanh(e){return o("atanh")}erf(e){return o("erf")}step(e,t){return o("step")}fusedConv2d({input:e,filter:t,convInfo:n,bias:r,activation:s,preluActivationWeights:a}){return o("fusedConv2d")}conv2d(e,t,n){return o("conv2d")}conv2dDerInput(e,t,n){return o("conv2dDerInput")}conv2dDerFilter(e,t,n){return o("conv2dDerFilter")}fusedDepthwiseConv2D({input:e,filter:t,convInfo:n,bias:r,activation:s,preluActivationWeights:a}){return o("fusedDepthwiseConv2D")}depthwiseConv2D(e,t,n){return o("depthwiseConv2D")}depthwiseConv2DDerInput(e,t,n){return o("depthwiseConv2DDerInput")}depthwiseConv2DDerFilter(e,t,n){return o("depthwiseConv2DDerFilter")}conv3d(e,t,n){return o("conv3d")}conv3dDerInput(e,t,n){return o("conv3dDerInput")}conv3dDerFilter(e,t,n){return o("conv3dDerFilter")}maxPool(e,t){return o("maxPool")}maxPoolBackprop(e,t,n,r){return o("maxPoolBackprop")}avgPool(e,t){return o("avgPool")}avgPoolBackprop(e,t,n){return o("avgPoolBackprop")}avgPool3d(e,t){return o("avgPool3d")}avgPool3dBackprop(e,t,n){return o("avgPool3dBackprop")}maxPool3d(e,t){return o("maxPool3d")}maxPool3dBackprop(e,t,n,r){return o("maxPool3dBackprop")}reshape(e,t){return o("reshape")}cast(e,t){return o("cast")}tile(e,t){return o("tile")}pad(e,t,n){return o("pad")}transpose(e,t){return o("transpose")}gather(e,t,n){return o("gather")}gatherND(e,t){return o("gatherND")}scatterND(e,t,n){return o("scatterND")}batchToSpaceND(e,t,n){return o("batchToSpaceND")}spaceToBatchND(e,t,n){return o("spaceToBatchND")}resizeBilinear(e,t,n,r){return o("resizeBilinear")}resizeBilinearBackprop(e,t,n){return o("resizeBilinearBackprop")}resizeNearestNeighbor(e,t,n,r){return o("resizeNearestNeighbor")}resizeNearestNeighborBackprop(e,t,n){return o("resizeNearestNeighborBackprop")}batchNorm(e,t,n,r,s,a){return o("batchNorm")}localResponseNormalization4D(e,t,n,r,s){return o("localResponseNormalization4D")}LRNGrad(e,t,n,r,s,a,i){return o("LRNGrad")}multinomial(e,t,n,r){return o("multinomial")}oneHot(e,t,n,r){return o("oneHot")}cumsum(e,t,n,r){return o("cumsum")}nonMaxSuppression(e,t,n,r,s){return o("nonMaxSuppression")}fft(e){return o("fft")}ifft(e){return o("ifft")}complex(e,t){return o("complex")}real(e){return o("real")}imag(e){return o("imag")}cropAndResize(e,t,n,r,s,a){return o("cropAndResize")}depthToSpace(e,t,n){return o("depthToSpace")}split(e,t,n){return o("split")}sparseToDense(e,t,n,r){return o("sparseToDense")}diag(e){return o("diag")}fill(e,t,n){return o("fill")}onesLike(e){return o("onesLike")}zerosLike(e){return o("zerosLike")}linspace(e,t,n){return o("linspace")}dispose(){return o("dispose")}}function o(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},73417:(e,t,n)=>{"use strict";n.r(t),n.d(t,{assertAxesAreInnerMostDims:()=>l.lB,axesAreInnerMostDims:()=>l.YB,combineLocations:()=>l.Vh,computeOutAndReduceShapes:()=>l.kz,expandShapeToKeepDim:()=>l.rv,getAxesPermutation:()=>l.Q3,getInnerMostAxes:()=>l.sY,getUndoAxesPermutation:()=>l.LJ,assertAndGetBroadcastShape:()=>c.$N,getBroadcastDims:()=>c.XF,getReductionAxes:()=>c.RR,assertParamsConsistent:()=>d.o,computeOutShape:()=>d.N,computeConv2DInfo:()=>h.Ix,computeConv3DInfo:()=>h.jw,computeDefaultPad:()=>h.aO,computeDilation2DInfo:()=>h.Rf,computePool2DInfo:()=>h.Xw,computePool3DInfo:()=>h.pl,convertConv2DDataFormat:()=>h.sl,eitherStridesOrDilationsAreOne:()=>h.jT,tupleValuesAreOne:()=>h.I0,applyActivation:()=>p.QH,getFusedBiasGradient:()=>p.pf,getFusedDyActivation:()=>p.Fr,shouldFuse:()=>p.uy,PARALLELIZE_THRESHOLD:()=>f.g,computeOptimalWindowSize:()=>f.A,slice_util:()=>m,upcastType:()=>g.x8,getImageCenter:()=>x.Q,getPermuted:()=>v.xw,getReshaped:()=>v.R7,getReshapedPermuted:()=>v.TK,getSliceBeginCoords:()=>v.oP,getSliceSize:()=>v.qX,prepareAndValidate:()=>b.prepareAndValidate,calculateShapes:()=>y.calculateShapes,validateInput:()=>y.validateInput,validateUpdateShape:()=>y.validateUpdateShape,SELU_SCALE:()=>w.$,SELU_SCALEALPHA:()=>w.y,ERF_A1:()=>k.Aj,ERF_A2:()=>k.py,ERF_A3:()=>k.Kh,ERF_A4:()=>k.Qy,ERF_A5:()=>k.eh,ERF_P:()=>k.IA,log:()=>I.c,warn:()=>I.Z,assignToTypedArray:()=>C.KV,complexWithEvenIndex:()=>C.GH,complexWithOddIndex:()=>C.H3,exponent:()=>C.ts,exponents:()=>C.mG,getComplexWithIndex:()=>C.cC,mergeRealAndImagArrays:()=>C.Cs,splitRealAndImagArrays:()=>C.cf,prepareSplitSize:()=>$.O,segment_util:()=>S,castTensor:()=>R,reshapeTensor:()=>E,linspaceImpl:()=>T});var r=n(23926),s=n(62271),o=n(99494),a=n(46092),i=n(59640),u=n(59155),l=n(83591),c=n(72200),d=n(30398),h=n(2582),p=n(19323),f=n(25466),m=n(37650),g=n(71221),x=n(29645),v=n(87199),b=n(37410),y=n(33028),w=n(43179),k=n(52176),I=n(64706),C=n(70885),$=n(34099),S=n(14931);function R(e,t,n){if("complex64"===t){if("complex64"===e.dtype)return e.clone();const t=(0,i.l)(e.shape),r=(0,s.p)(e,"float32"),o=n.complex(r,t);return t.dispose(),r.dispose(),o}if(!(0,u.hasEncodingLoss)(e.dtype,t))return r.BV.makeTensorFromDataId(e.dataId,e.shape,t);if("complex64"===e.dtype){const r=n.real(e),o=(0,s.p)(r,t);return r.dispose(),o}if("int32"===t)return n.int(e);if("bool"===t){const t=(0,o.i)(0,e.dtype),r=n.notEqual(e,t);return t.dispose(),r}throw new Error(`Error in Cast: failed to cast ${e.dtype} to ${t}`)}function E(e,t){return r.BV.makeTensorFromDataId(e.dataId,t,e.dtype)}function T(e,t,n){const r=(t-e)/(n-1),s=(0,u.makeZerosTypedArray)(n,"float32");s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+r;return(0,a.R)(s,"float32")}},70885:(e,t,n)=>{"use strict";function r(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function s(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function o(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=0;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function a(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=2;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function i(e,t){return{real:e[2*t],imag:e[2*t+1]}}function u(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function l(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const o=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:n,imag:r}}function c(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}n.d(t,{Cs:()=>r,cf:()=>s,GH:()=>o,H3:()=>a,cC:()=>i,KV:()=>u,mG:()=>l,ts:()=>c})},47242:(e,t,n)=>{"use strict";n.d(t,{nonMaxSuppressionV3Impl:()=>r.GP,nonMaxSuppressionV4Impl:()=>r.qP,nonMaxSuppressionV5Impl:()=>r.pA,split:()=>s.V,tile:()=>o.G,topkImpl:()=>a.v,whereImpl:()=>i.Z});var r=n(12667),s=n(11259),o=n(76517),a=n(82058),i=n(48333)},12667:(e,t,n)=>{"use strict";n.d(t,{GP:()=>a,qP:()=>i,pA:()=>u});var r=n(99494),s=n(46092),o=n(22200);function a(e,t,n,r,s){return l(e,t,n,r,s,0).selectedIndices}function i(e,t,n,r,s,o){return l(e,t,n,r,s,0,!1,o,!0)}function u(e,t,n,r,s,o){return l(e,t,n,r,s,o,!0)}function l(e,t,n,a,i,u,l=!1,p=!1,f=!1){const m=[];for(let e=0;e<t.length;e++)t[e]>i&&m.push({score:t[e],boxIndex:e,suppressBeginIndex:0});m.sort(h);const g=u>0?-.5/u:0,x=[],v=[];for(;x.length<n&&m.length>0;){const t=m.pop(),{score:n,boxIndex:r,suppressBeginIndex:s}=t;if(n<i)break;let u=!1;for(let n=x.length-1;n>=s;--n){const s=c(e,r,x[n]);if(s>=a){u=!0;break}if(t.score=t.score*d(a,g,s),t.score<=i)break}t.suppressBeginIndex=x.length,u||(t.score===n?(x.push(r),v.push(t.score)):t.score>i&&(0,o.v)(m,t,h))}const b=x.length,y=n-b;p&&y>0&&(x.push(...new Array(y).fill(0)),v.push(...new Array(y).fill(0)));const w={selectedIndices:(0,s.R)(x,"int32")};return l&&(w.selectedScores=(0,s.R)(v,"float32")),f&&(w.validOutputs=(0,r.i)(b,"int32")),w}function c(e,t,n){const r=e.subarray(4*t,4*t+4),s=e.subarray(4*n,4*n+4),o=Math.min(r[0],r[2]),a=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),p=(i-o)*(u-a),f=(d-l)*(h-c);if(p<=0||f<=0)return 0;const m=Math.max(o,l),g=Math.max(a,c),x=Math.min(i,d),v=Math.min(u,h),b=Math.max(x-m,0)*Math.max(v-g,0);return b/(p+f-b)}function d(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function h(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}},11259:(e,t,n)=>{"use strict";n.d(t,{V:()=>s});var r=n(22676);function s(e,t,n){const s=new Array(e.rank).fill(0),o=e.shape.slice();return t.map((t=>{const a=[...o];a[n]=t;const i=(0,r.t)(e,s,a);return s[n]+=t,i}))}},76517:(e,t,n)=>{"use strict";n.d(t,{G:()=>s});var r=n(72657);function s(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const s=(0,r.f)(n,e.dtype);for(let t=0;t<s.values.length;++t){const n=s.indexToLoc(t),r=new Array(e.rank);for(let t=0;t<r.length;t++)r[t]=n[t]%e.shape[t];const o=e.locToIndex(r);s.values[t]=e.values[o]}return s.toTensor()}},82058:(e,t,n)=>{"use strict";n.d(t,{v:()=>o});var r=n(10701),s=n(59155);function o(e,t,n,o,a){const i=t[t.length-1],[u,l]=[e.length/i,i],c=(0,s.getTypedArrayFromDType)(n,u*o),d=(0,s.getTypedArrayFromDType)("int32",u*o);for(let t=0;t<u;t++){const n=t*l,r=e.subarray(n,n+l),s=[];for(let e=0;e<r.length;e++)s.push({value:r[e],index:e});s.sort(((e,t)=>t.value-e.value));const a=t*o,i=c.subarray(a,a+o),u=d.subarray(a,a+o);for(let e=0;e<o;e++)i[e]=s[e].value,u[e]=s[e].index}const h=t.slice();return h[h.length-1]=o,[(0,r.X)(c,h,n),(0,r.X)(d,h,"int32")]}},48333:(e,t,n)=>{"use strict";n.d(t,{Z:()=>s});var r=n(72657);function s(e,t){const n=[];for(let e=0;e<t.length;e++)t[e]&&n.push(e);const s=(0,r.f)(e,"int32"),o=(0,r.f)([n.length,e.length],"int32");for(let t=0;t<n.length;t++){const r=s.indexToLoc(n[t]),a=t*e.length;o.values.set(r,a)}return o.toTensor()}},45898:(e,t,n)=>{"use strict";n.d(t,{YDk:()=>o.YD,z4k:()=>a.z4,x8V:()=>a.x8,IHx:()=>i.IHx,f3b:()=>i.f3b,PYB:()=>i.PYB,hiC:()=>i.hiC,pyx:()=>i.pyx,DgJ:()=>i.DgJ,Qqt:()=>i.Qqt,asL:()=>i.asL,Fp7:()=>i.Fp7,dC7:()=>i.dC7,w6H:()=>i.w6H,kwC:()=>i.kwC,XLQ:()=>i.XLQ,iD$:()=>i.iD$,tPi:()=>i.tPi,XAC:()=>i.XAC,knu:()=>i.knu,luU:()=>i.luU,XeE:()=>i.XeE,odF:()=>i.odF,yXz:()=>i.yXz,p4s:()=>i.p4s,lls:()=>i.lls,SRH:()=>u.SR,jqO:()=>u.jq,lub:()=>u.lu,wCN:()=>l.wC,OBj:()=>c.OB,D5U:()=>s,Wap:()=>d,kuN:()=>r,C2$:()=>h,GDt:()=>p,Zuw:()=>f.Zu,JLz:()=>f.JL,SYM:()=>m.SY,VGw:()=>m.VG,SpW:()=>m.Sp,mm_:()=>m.mm,M2y:()=>m.M2,qw7:()=>m.qw,jMg:()=>m.jM,QCc:()=>m.QC,Oyi:()=>m.Oy,JhU:()=>m.Jh,xts:()=>m.xt,RFZ:()=>m.RF,gJX:()=>m.gJ,xnO:()=>m.xn,Zz9:()=>m.Zz,Eh3:()=>m.Eh,mc4:()=>m.mc,TR1:()=>m.TR,p4S:()=>m.p4,Vn9:()=>m.Vn,ekb:()=>m.ek,ZCY:()=>m.ZC,SX0:()=>m.SX,Omj:()=>m.Om,NEP:()=>m.NE,Y0y:()=>m.Y0,vwp:()=>m.vw,Uyb:()=>m.Uy,OR:()=>m.OR,eBW:()=>m.eB,sHE:()=>m.sH,Qg5:()=>m.Qg,iJz:()=>m.iJ,J_u:()=>m.J_,avt:()=>m.av,iWB:()=>m.iW,r7n:()=>m.r7,ZbH:()=>m.Zb,kU:()=>m.kU,VfG:()=>m.Vf,YoZ:()=>m.Yo,mTV:()=>m.mT,GvW:()=>m.Gv,vFR:()=>m.vF,wYn:()=>m.wY,uv1:()=>m.uv,cye:()=>m.cy,W0H:()=>m.W0,yQU:()=>m.yQ,lyA:()=>m.ly,xJR:()=>m.xJ,$HU:()=>m.$H,HZH:()=>m.HZ,b9H:()=>m.b9,e07:()=>m.e0,bV0:()=>m.bV,oFR:()=>m.oF,a5O:()=>m.a5,i5y:()=>m.i5,RQH:()=>m.RQ,wYB:()=>m.w3,p2w:()=>m.p2,MRv:()=>m.MR,TQc:()=>m.TQ,FKq:()=>m.FK,bK0:()=>m.bK,_tC:()=>m._t,h8e:()=>m.h8,Tr8:()=>m.Tr,sEM:()=>m.sE,MIZ:()=>m.MI,G3Y:()=>m.G3,kpP:()=>m.kp}),n(46784);var r=n(37650),s=n(59155),o=n(73327),a=n(71221),i=n(77912),u=n(4368),l=n(26151),c=n(22885),d=n(73417),h=n(85999),p=n(47242),f=n(68713),m=n(29121)},88549:(e,t,n)=>{"use strict";var r=n(23926),s=(n(79998),n(26480),n(35221),n(72657)),o=n(62271),a=n(8723),i=n(29798),u=n(73327);(0,r.wv)();const l={buffer:s.f,cast:o.p,clone:a.d,print:i.S};(0,u.Vp)(l)},85999:(e,t,n)=>{"use strict";function r(){if("undefined"!=typeof navigator&&null!=navigator){const e=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function s(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}n.d(t,{isMobile:()=>r,isBrowser:()=>s})},23926:(e,t,n)=>{"use strict";n.d(t,{wv:()=>m,BV:()=>g});var r=n(68713),s=n(22885),o=n(55938),a=n(29121),i=n(26151),u=n(52368),l=n(50223),c=n(73327),d=n(80747),h=n(59155);class p{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class f{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new p}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(console.warn(e+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new u.Q1(this.backendInstance),!0}setupRegisteredKernels(){(0,i.tr)(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){(0,i.tr)(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof r.Zu||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId||(this.registry[e]=n,this.pendingBackendInit=null,0)))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${e} failed`),console.warn(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(t){return console.warn(`Initialization of backend ${e} failed`),console.warn(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(e+" backend not found in registry");this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t);r.disposeData(t),n.backend=e,e.move(t,s,n.shape,n.dtype),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return f.nextTensorId++}nextVariableId(){return f.nextVariableId++}clone(e){const t=this.makeTensorFromDataId(e.dataId,e.shape,e.dtype),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t="float32",n={x:e},r={dtype:t};return g.runKernelFunc((n=>n.cast(e,t)),n,null,a.RF,r)}})),[],{}),t}runKernel(e,t,n,r,s){return this.runKernelFunc(null,t,null,e,n,r,s)}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let s=0;n.forEach((e=>{s+="complex64"===e.dtype?3:1}));const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-t-s-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e,t,n,r,s,o,a){let u,l=[];const c=this.isTapeOn();null==r&&(r=null!=this.state.activeScope?this.state.activeScope.name:"");const d=this.state.numBytes,h=this.state.numTensors;let p;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const f=(0,i.pI)(r,this.backendName);let m,g;if(null!=f)p=()=>{const e=this.backend.numDataIds();m=f.kernelFunc({inputs:t,attrs:s,backend:this.backend});const n=Array.isArray(m)?m:[m];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(r,e,n);const i=n.map((({dataId:e,shape:t,dtype:n})=>this.makeTensorFromDataId(e,t,n)));if(c){let e=this.getTensorsForGradient(r,t,i);if(null==e){null==a&&(a=[]);const t=i.filter(((e,t)=>a[t]));e=(o||[]).slice().concat(t)}l=this.saveTensorsForBackwardMode(e)}return i};else{const t=e=>{c&&(l=e.map((e=>this.keep(this.clone(e)))))};p=()=>{const n=this.backend.numDataIds();m=this.tidy((()=>e(this.backend,t)));const s=Array.isArray(m)?m:[m];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(r,n,s),s}}return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(g=this.profiler.profileKernel(r,t,(()=>p())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(g),u=g.outputs):u=p()})),c&&this.addTapeNode(r,t,u,n,l,s),this.state.profiling&&this.state.activeProfile.kernels.push({name:r,bytesAdded:this.state.numBytes-d,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-h,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(t).map((e=>null!=t[e]?t[e].shape:null)),outputShapes:u.map((e=>e.shape)),kernelTimeMs:g.timeMs,extraInfo:g.extraInfo}),Array.isArray(m)?u:u[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){const r=(0,i.uk)(e);if(null!=r){const e=r.inputsToSave||[],s=r.outputsToSave||[];let o;r.saveAllInputs?(h.assert(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),o=Object.keys(t).map((e=>t[e]))):o=e.map((e=>t[e]));const a=n.filter(((e,t)=>s[t]));return o.concat(a)}return null}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=e;"string"===n&&h.isString(e[0])&&(s=e.map((e=>h.encodeString(e))));const o=r.write(s,t,n),a=new c.es(t,n,o,this.nextTensorId());if(this.incRef(a,r),"string"===n){const e=this.state.tensorInfo.get(o),t=(0,h.bytesFromStringArray)(s);this.state.numBytes+=t-e.bytes,e.bytes=t}return a}makeTensorFromDataId(e,t,n,r){n=n||"float32";const s=new c.es(t,n,e,this.nextTensorId());return this.incRef(s,r),s}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const s=new c._w(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}incRef(e,t){const n=this.state.tensorInfo.has(e.dataId)?this.state.tensorInfo.get(e.dataId).refCount:0;if(this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++,0===n){this.state.numDataBuffers++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*h.bytesPerElement(e.dtype)),this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n,refCount:0}),this.state.numBytes+=n}this.state.tensorInfo.get(e.dataId).refCount++,e instanceof c._w||this.track(e)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;this.state.numTensors--,"string"===e.dtype&&this.state.numStringTensors--;const t=this.state.tensorInfo.get(e.dataId);t.refCount<=1?("complex64"!==e.dtype&&(this.state.numBytes-=t.bytes),this.state.numDataBuffers--,t.backend.disposeData(e.dataId),this.state.tensorInfo.delete(e.dataId)):this.state.tensorInfo.get(e.dataId).refCount--}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const e of this.state.activeProfile.kernels)e.kernelTimeMs=await e.kernelTimeMs,e.extraInfo=await e.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,s,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},u=(0,i.uk)(e);null!=u&&(r=u.gradFunc),null!=r&&(a.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=h.makeZerosTypedArray(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],s,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=(0,d.getTensorsInContainer)(e),n=new Set(t.map((e=>e.id)));for(let e=0;e<this.state.activeScope.track.length;e++){const t=this.state.activeScope.track[e];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n,r=!1){if(h.assert(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));h.assert(s instanceof c.es,(()=>"The result y returned by f() must be a tensor."));const o=(0,l.C)(this.state.activeTape,t,s);if(!r&&0===o.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[s.id]=null==n?function(e){const t=(0,h.makeOnesTypedArray)((0,h.sizeFromShape)(e),"float32");return g.makeTensor(t,e,"float32")}(s.shape):n,(0,l._)(e,o,(e=>this.tidy(e)),x);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:s,grads:r}}))}customGrad(e){return h.assert(h.isFunction(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{let n;h.assert(t.every((e=>e instanceof c.es)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};return t.forEach(((e,t)=>{r[t]=e})),this.runKernelFunc(((r,s)=>(n=e(...t,s),h.assert(n.value instanceof c.es,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),h.assert(h.isFunction(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value)),r,((e,r)=>{const s=n.gradFunc(e,r),o=Array.isArray(s)?s:[s];h.assert(o.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),h.assert(o.every((e=>e instanceof c.es)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const a={};return o.forEach(((e,t)=>{a[t]=()=>e})),a}))}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}async time(e){const t=(0,h.now)(),n=await this.backend.time(e);return n.wallMs=(0,h.now)()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new p;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function m(){const e=(0,o.D)();if(null==e._tfengine){const t=new s.qA(e);e._tfengine=new f(t)}return(0,s.iG)(e._tfengine.ENV),(0,c.Vi)((()=>e._tfengine)),e._tfengine}f.nextTensorId=0,f.nextVariableId=0;const g=m();function x(e,t){const n={a:e,b:t};return g.runKernelFunc(((n,r)=>{const s=n.add(e,t);return r([e,t]),s}),n,null,a.mm)}},22885:(e,t,n)=>{"use strict";n.d(t,{qA:()=>r,OB:()=>s,iG:()=>a});class r{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(t instanceof Promise)throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=function(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("=")))),t}(this.global.location.search);"tfjsflags"in e&&e.tfjsflags.split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}(t,n)}))}}function s(){return o}let o=null;function a(e){o=e}},79998:(e,t,n)=>{"use strict";var r=n(85999);const s=(0,n(22885).OB)();s.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),s.registerFlag("IS_BROWSER",(()=>r.isBrowser())),s.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node)),s.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),s.registerFlag("PROD",(()=>!1)),s.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>s.getBool("DEBUG"))),s.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),s.registerFlag("IS_TEST",(()=>!1))},55938:(e,t,n)=>{"use strict";let r;function s(){if(null==r){let e;if("undefined"!=typeof window)e=window;else if(void 0!==n.g)e=n.g;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}r=e}return r}function o(e,t){const n=function(){const e=s();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}n.d(t,{D:()=>s,R:()=>o})},4368:(e,t,n)=>{"use strict";n.d(t,{MX:()=>i,SR:()=>u,lu:()=>l,B9:()=>c,jq:()=>d});var r=n(23926),s=n(22885),o=n(73327),a=n(80747);function i(e){(0,s.OB)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function u(){return r.BV}function l(e,t){return r.BV.tidy(e,t)}function c(e){(0,a.getTensorsInContainer)(e).forEach((e=>e.dispose()))}function d(e,t,n=1){return r.BV.registerBackend(e,t,n)}(0,o.FZ)(i)},30633:(e,t,n)=>{"use strict";n.d(t,{cb:()=>s});var r=n(23926);function s(e){return r.BV.customGrad(e)}},32259:(e,t,n)=>{"use strict";n.d(t,{Q:()=>i});var r=n(29121),s=n(62271),o=n(24841),a=n(71901);const i={kernelName:r.SY,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,o.d)(e,(0,a.N)((0,s.p)(n,"float32"),-1))}}}},35589:(e,t,n)=>{"use strict";n.d(t,{K:()=>d});var r=n(29121),s=n(62271),o=n(41274),a=n(17370),i=n(99494),u=n(13261),l=n(50248),c=n(70827);const d={kernelName:r.VG,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=(0,l.h)((0,s.p)(n,"float32")),r=(0,u._)((0,c.l)((0,i.i)(1),t));return(0,a.W)((0,o.h)(e,r))}}}}},10629:(e,t,n)=>{"use strict";n.d(t,{M:()=>l});var r=n(29121),s=n(62271),o=n(41274),a=n(13261),i=n(50248),u=n(70827);const l={kernelName:r.Sp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=(0,a._)((0,u.l)((0,i.h)((0,s.p)(n,"float32")),1));return(0,o.h)(e,t)}}}}},42724:(e,t,n)=>{"use strict";n.d(t,{C:()=>r});const r={kernelName:n(29121).Xz,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}}},18707:(e,t,n)=>{"use strict";n.d(t,{m:()=>i});var r=n(29121),s=n(72200),o=n(4968),a=n(15475);const i={kernelName:r.mm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,i=s.$N(n.shape,r.shape);return{a:()=>{let t=e;const r=s.RR(n.shape,i);return r.length>0&&(t=(0,a.S)(t,r)),(0,o.X)(t,n.shape)},b:()=>{let t=e;const n=s.RR(r.shape,i);return n.length>0&&(t=(0,a.S)(t,n)),(0,o.X)(t,r.shape)}}}}},64017:(e,t,n)=>{"use strict";n.d(t,{C:()=>o});var r=n(29121),s=n(6577);const o={kernelName:r.sJ,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.P)(n)}}}},67851:(e,t,n)=>{"use strict";n.d(t,{Q:()=>o});var r=n(29121),s=n(6577);const o={kernelName:r.aJ,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.P)(n)}}}},20080:(e,t,n)=>{"use strict";n.d(t,{V:()=>c});var r=n(29121),s=n(62271),o=n(41274),a=n(99494),i=n(13261),u=n(50248),l=n(70827);const c={kernelName:r.M2,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,o.h)(e,(0,i._)((0,l.l)((0,a.i)(1),(0,u.h)((0,s.p)(n,"float32")))))}}}},11669:(e,t,n)=>{"use strict";n.d(t,{f:()=>c});var r=n(29121),s=n(56407),o=n(62271),a=n(41274),i=n(99494),u=n(13261),l=n(50248);const c={kernelName:r.qw,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=(0,u._)((0,s.I)((0,i.i)(1),(0,l.h)((0,o.p)(n,"float32"))));return(0,a.h)(e,t)}}}}},55535:(e,t,n)=>{"use strict";n.d(t,{H:()=>h});var r=n(29121),s=n(56407),o=n(72200),a=n(41274),i=n(24841),u=n(17370),l=n(4968),c=n(50248),d=n(15475);const h={kernelName:r.QC,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,h=(0,o.$N)(n.shape,r.shape);return{a:()=>{const t=(0,s.I)((0,c.h)(n),(0,c.h)(r));let u=(0,i.d)(e,(0,a.h)(r,t));const p=(0,o.RR)(n.shape,h);return p.length>0&&(u=(0,d.S)(u,p)),(0,l.X)(u,n.shape)},b:()=>{const t=(0,s.I)((0,c.h)(n),(0,c.h)(r));let p=(0,u.W)((0,i.d)(e,(0,a.h)(n,t)));const f=(0,o.RR)(r.shape,h);return f.length>0&&(p=(0,d.S)(p,f)),(0,l.X)(p,r.shape)}}}}},23755:(e,t,n)=>{"use strict";n.d(t,{A:()=>u});var r=n(29121),s=n(56407),o=n(62271),a=n(41274),i=n(50248);const u={kernelName:r.jM,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,a.h)(e,(0,s.I)((0,i.h)((0,o.p)(n,"float32")),1))}}}},87242:(e,t,n)=>{"use strict";n.d(t,{q:()=>l});var r=n(29121),s=n(62271),o=n(41274),a=n(50248),i=n(70827),u=n(99494);const l={kernelName:r.Oy,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,o.h)(e,(0,i.l)((0,u.i)(1),(0,a.h)((0,s.p)(n,"float32"))))}}}},92153:(e,t,n)=>{"use strict";n.d(t,{Y:()=>o});var r=n(29121),s=n(809);const o={kernelName:r._k,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:o,strides:a,dilations:i,pad:u,dimRoundingMode:l}=n,c=null==i?[1,1,1]:i;return{x:()=>(0,s.V)(e,r,o,a,c,u,l)}}}},24254:(e,t,n)=>{"use strict";n.d(t,{v:()=>o});var r=n(29121),s=n(21486);const o={kernelName:r.Jh,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:o,strides:a,pad:i}=n;return{x:()=>(0,s.T)(e,r,o,a,i)}}}},9742:(e,t,n)=>{"use strict";n.d(t,{C:()=>o});var r=n(29121),s=n(28687);const o={kernelName:r.XL,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,o]=t,{transposeA:a,transposeB:i}=n;return a||i?!a&&i?{a:()=>(0,s.O)(e,o,!1,!1),b:()=>(0,s.O)(e,r,!0,!1)}:a&&!i?{a:()=>(0,s.O)(o,e,!1,!0),b:()=>(0,s.O)(r,e,!1,!1)}:{a:()=>(0,s.O)(o,e,!0,!0),b:()=>(0,s.O)(e,r,!0,!0)}:{a:()=>(0,s.O)(e,o,!1,!0),b:()=>(0,s.O)(r,e,!0,!1)}}}},3477:(e,t,n)=>{"use strict";n.d(t,{s:()=>o});var r=n(29121),s=n(27918);const o={kernelName:r.zw,gradFunc:(e,t,n)=>{const{blockShape:r,crops:o}=n;return{x:()=>(0,s.f)(e,r,o)}}}},27914:(e,t,n)=>{"use strict";n.d(t,{O:()=>o});var r=n(29121),s=n(15475);const o={kernelName:r.Ly,gradFunc:(e,t,n)=>{const r=n,o=r.inputShape,a=r.shape,i=Array.from(a);for(let e=o.length-1;e>=0;e--)if(o[e]===a[e])i[e]=1;else if(1!==o[e])throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${a}].`);const u=[];for(let e=0;e<i.length;e++)i[e]>1&&u.push(e);return{x:()=>(0,s.S)(e,u,!0)}}}},42680:(e,t,n)=>{"use strict";n.d(t,{D:()=>r});const r={kernelName:n(29121).RF,gradFunc:e=>({x:()=>e.clone()})}},49467:(e,t,n)=>{"use strict";n.d(t,{t:()=>o});var r=n(29121),s=n(6577);const o={kernelName:r.gJ,gradFunc:e=>({x:()=>(0,s.P)(e)})}},57777:(e,t,n)=>{"use strict";n.d(t,{v:()=>l});var r=n(29121),s=n(17630),o=n(50624),a=n(2856),i=n(95912),u=n(6577);const l={kernelName:r.xn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:l,clipValueMax:c}=n;return{x:()=>(0,i.a)((0,a.H)((0,s.b)(r,l),(0,o.z)(r,c)),e,(0,u.P)(e))}}}},54565:(e,t,n)=>{"use strict";n.d(t,{x:()=>a});var r=n(29121),s=n(28644),o=n(59155);const a={kernelName:r.Eh,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map((e=>e.shape)),{axis:a}=n,i=(0,o.parseAxisParam)(a,t[0].shape)[0],u=r.map((e=>e[i]));return(0,s.V)(e,u,i).map((e=>()=>e))}}},9920:(e,t,n)=>{"use strict";n.d(t,{F:()=>a});var r=n(29121),s=n(64794),o=n(36013);const a={kernelName:r.wm,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,{strides:i,pad:u,dataFormat:l,dimRoundingMode:c}=n;return{dy:()=>(0,s.T)(e,a,i,u,l,1,c),filter:()=>(0,o.p)(e,r,a.shape,i,u,l,c)}}}},45396:(e,t,n)=>{"use strict";n.d(t,{S:()=>u});var r=n(29121),s=n(36013),o=n(39832),a=n(2582),i=n(59155);const u={kernelName:r.mh,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,u]=t,{dilations:l,strides:c,pad:d,dataFormat:h}=n;return i.assert(a.I0(l),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${l}'`)),{x:()=>(0,o._)(r.shape,e,u,c,d,h),filter:()=>(0,s.p)(r,e,u.shape,c,d,h)}}}},77355:(e,t,n)=>{"use strict";n.d(t,{w:()=>u});var r=n(29121),s=n(3365),o=n(97594),a=n(2582),i=n(59155);const u={kernelName:r.x1,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:u,pad:l}=n;i.assert((0,a.I0)(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[c,d]=t;return{x:()=>(0,o._)(c.shape,e,d,u,l),filter:()=>(0,s.s)(c,e,d.shape,u,l)}}}},77528:(e,t,n)=>{"use strict";n.d(t,{L:()=>u});var r=n(29121),s=n(62271),o=n(24841),a=n(17370),i=n(99331);const u={kernelName:r.mc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,o.d)((0,a.W)((0,i.O)((0,s.p)(n,"float32"))),e)}}}},61763:(e,t,n)=>{"use strict";n.d(t,{a:()=>i});var r=n(29121),s=n(62271),o=n(24841),a=n(83254);const i={kernelName:r.TR,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,o.d)((0,a.R)((0,s.p)(n,"float32")),e)}}}},12090:(e,t,n)=>{"use strict";n.d(t,{g:()=>i});var r=n(29121),s=n(83591),o=n(37405),a=n(89065);const i={kernelName:r.iH,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:i,exclusive:u,reverse:l}=n;return{x:()=>{const t=(0,s.Q3)([i],r.rank);let n=(0,o.z)(e,i,u,!l);return null!=t&&(n=(0,a.p)(n,t)),n}}}}},303:(e,t,n)=>{"use strict";n.d(t,{v:()=>u});var r=n(29121),s=n(2582),o=n(88098),a=n(54375),i=n(59155);const u={kernelName:r.ci,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:u,pad:l,dimRoundingMode:c}=n,d=null==r?[1,1]:r;i.assert(s.I0(d),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${d}'`));const[h,p]=t;i.assert(4===h.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${h.rank}.`)),i.assert(4===p.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${p.rank}.`)),i.assert(h.shape[3]===p.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`)),i.assert(s.jT(u,d),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${u} and dilations '${d}'.`)),null!=c&&i.assert(i.isInt(l),(()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${c} but got pad ${l}.`));const f=s.Ix(h.shape,p.shape,u,d,l,c,!0);return{x:()=>(0,a.v)(h.shape,e,p,f),filter:()=>(0,o.z)(h,e,p.shape,f)}}}},62207:(e,t,n)=>{"use strict";n.d(t,{T:()=>o});var r=n(23926),s=n(29121);const o={kernelName:s.p4,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[o,a]=t,i={x:o,filter:a,dy:e},u={x:o,filter:a,dy:e};return{x:()=>r.BV.runKernel(s.ek,i,n),filter:()=>r.BV.runKernel(s.Vn,u,n)}}}},45449:(e,t,n)=>{"use strict";n.d(t,{Z:()=>h});var r=n(29121),s=n(72200),o=n(62271),a=n(41274),i=n(24841),u=n(17370),l=n(4968),c=n(50248),d=n(15475);const h={kernelName:r.ZC,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,h=s.$N(n.shape,r.shape);return{a:()=>{const t=(0,a.h)(e,(0,o.p)(r,"float32")),i=s.RR(n.shape,h);return i.length>0?(0,l.X)((0,d.S)(t,i),n.shape):t},b:()=>{let t=(0,i.d)(e,(0,o.p)(n,"float32"));const p=s.RR(r.shape,h);p.length>0&&(t=(0,l.X)((0,d.S)(t,p),r.shape));const f=(0,c.h)(r);return(0,u.W)((0,a.h)(t,(0,o.p)(f,"float32")))}}}}},29479:(e,t,n)=>{"use strict";n.d(t,{q:()=>o});var r=n(23926),s=n(29121);const o={kernelName:s.SX,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,o=t=>t.eluDer(e,n),a={dy:e,y:n};return{x:()=>r.BV.runKernelFunc(o,a,null,s.HE)}}}},82221:(e,t,n)=>{"use strict";n.d(t,{j:()=>u});var r=n(29121),s=n(44842),o=n(24841),a=n(17370),i=n(50248);const u={kernelName:r.Om,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=(0,o.d)((0,s.Q)((0,a.W)((0,i.h)(n))),2/Math.sqrt(Math.PI));return{x:()=>(0,o.d)(e,r)}}}},15833:(e,t,n)=>{"use strict";n.d(t,{K:()=>o});var r=n(29121),s=n(24841);const o={kernelName:r.NE,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.d)(e,n)}}}},72087:(e,t,n)=>{"use strict";n.d(t,{g:()=>a});var r=n(29121),s=n(44842),o=n(24841);const a={kernelName:r.Y0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,o.d)(e,(0,s.Q)(n))}}}},18284:(e,t,n)=>{"use strict";n.d(t,{T:()=>h});var r=n(29121),s=n(72200),o=n(62271),a=n(41274),i=n(24841),u=n(17370),l=n(4968),c=n(50248),d=n(15475);const h={kernelName:r.je,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,h=(0,s.$N)(n.shape,r.shape);return{a:()=>{const t=(0,a.h)(e,(0,o.p)(r,"float32")),i=(0,s.RR)(n.shape,h);return i.length>0?(0,l.X)((0,d.S)(t,i),n.shape):t},b:()=>{let t=(0,i.d)(e,(0,o.p)(n,"float32"));const p=(0,s.RR)(r.shape,h);p.length>0&&(t=(0,l.X)((0,d.S)(t,p),r.shape));const f=(0,c.h)(r);return(0,u.W)((0,a.h)(t,(0,o.p)(f,"float32")))}}}}},30782:(e,t,n)=>{"use strict";n.d(t,{G:()=>o});var r=n(29121),s=n(6577);const o={kernelName:r.OR,gradFunc:e=>({x:()=>(0,s.P)(e)})}},38905:(e,t,n)=>{"use strict";n.d(t,{c:()=>p});var r=n(29121),s=n(56407),o=n(72200),a=n(24841),i=n(4968),u=n(32634),l=n(99494),c=n(70827),d=n(15475),h=n(47501);const p={kernelName:r.sH,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[p,f,m,g]=t,x=null==g?(0,l.i)(1):g,v=(0,o.RR)(f.shape,p.shape),b=[];if(1===f.rank){for(let e=0;e<p.shape.length-1;++e)b.push(p.shape[e]);b.push(1)}const y=(0,c.l)(p,f),w=(0,a.d)(e,x),k=(0,u.b)((0,s.I)(m,(0,l.i)(r))),I=(0,a.d)((0,a.d)((0,a.d)(k,k),k),(0,l.i)(-.5));return{x:()=>1===f.rank?(0,i.X)((0,a.d)((0,a.d)(e,(0,h.G)((0,i.X)(k,[1,1,1,f.shape[0]]),b)),x),p.shape):(0,i.X)((0,a.d)((0,a.d)(e,k),x),p.shape),mean:()=>{let e=(0,a.d)((0,a.d)(k,(0,l.i)(-1)),w);return 1===f.rank&&(e=(0,d.S)(e,v)),(0,i.X)(e,f.shape)},variance:()=>{let e=(0,a.d)((0,a.d)(I,y),w);return 1===f.rank&&(e=(0,d.S)(e,v)),(0,i.X)(e,f.shape)},scale:()=>{const t=(0,a.d)(y,k);let n=(0,a.d)(e,t);return 1===f.rank&&(n=(0,d.S)(n,v)),(0,i.X)(n,f.shape)},offset:()=>{let t=e;return 1===f.rank&&(t=(0,d.S)(t,v)),(0,i.X)(t,f.shape)}}}}},66568:(e,t,n)=>{"use strict";n.d(t,{t:()=>l});var r=n(29121),s=n(83591),o=n(4968),a=n(89065),i=n(98749),u=n(59155);const l={kernelName:r.qi,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,l]=t,{axis:h}=n,p=(0,u.parseAxisParam)(h,r.shape)[0];return{x:()=>{const t=r.shape,n=l.size,u=t.slice(0,p),f=u.length,m=t.slice(h,t.length).slice(1),g=m.length,x=c(0,f),v=c(f+1,f+1+g),b=d([u,[n],m]),y=(0,o.X)(e,b),w=(0,o.X)(l,[n]),k=d([[f],x,v]),I=(0,a.p)(y,k);let C=(0,i.p)(I,w,r.shape[p]);const $=(0,s.LJ)(k);return C=(0,a.p)(C,$),C},indices:()=>l}}};function c(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function d(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}},3258:(e,t,n)=>{"use strict";n.d(t,{i:()=>o});var r=n(29121),s=n(6577);const o={kernelName:r.Ac,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>(0,s.P)(n),b:()=>(0,s.P)(r)}}}},91603:(e,t,n)=>{"use strict";n.d(t,{w:()=>o});var r=n(29121),s=n(62271);const o={kernelName:r.iJ,gradFunc:e=>({x:()=>(0,s.p)(e,"float32")})}},13079:(e,t,n)=>{"use strict";n.d(t,{Y:()=>o});var r=n(29121),s=n(6577);const o={kernelName:r.av,gradFunc:e=>({x:()=>(0,s.P)(e)})}},8474:(e,t,n)=>{"use strict";n.d(t,{i:()=>o});var r=n(29121),s=n(6577);const o={kernelName:r.iW,gradFunc:e=>({x:()=>(0,s.P)(e)})}},48971:(e,t,n)=>{"use strict";n.d(t,{W:()=>o});var r=n(29121),s=n(6577);const o={kernelName:r.r7,gradFunc:e=>({x:()=>(0,s.P)(e)})}},54488:(e,t,n)=>{"use strict";n.d(t,{e:()=>o});var r=n(29121),s=n(69369);const o={kernelName:r.eZ,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,o]=t,{depthRadius:a,bias:i,alpha:u,beta:l}=n;return{x:()=>(0,s.Y)(r,o,e,a,i,u,l)}}}},74937:(e,t,n)=>{"use strict";n.d(t,{P:()=>a});var r=n(29121),s=n(56407),o=n(41274);const a={kernelName:r.kU,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,o.h)(e,(0,s.I)(n,1))}}}},7759:(e,t,n)=>{"use strict";n.d(t,{K:()=>u});var r=n(29121),s=n(44842),o=n(24841),a=n(70827),i=n(15475);const u={kernelName:r.qC,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:u}=n;return{logits:()=>{const t=(0,s.Q)(r);return(0,a.l)(e,(0,o.d)((0,i.S)(e,u,!0),t))}}}}},72486:(e,t,n)=>{"use strict";n.d(t,{X:()=>a});var r=n(29121),s=n(62271),o=n(41274);const a={kernelName:r.Zb,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,o.h)(e,(0,s.p)(n,"float32"))}}}},7400:(e,t,n)=>{"use strict";n.d(t,{J:()=>o});var r=n(29121),s=n(75257);const o={kernelName:r.OA,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,o]=t,{filterSize:a,strides:i,dilations:u,pad:l,dimRoundingMode:c}=n,d=null==u?[1,1,1]:u;return{x:()=>(0,s.O)(e,r,o,a,i,d,l,c)}}}},32282:(e,t,n)=>{"use strict";n.d(t,{f:()=>o});var r=n(29121),s=n(67824);const o={kernelName:r.mT,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,o]=t,{filterSize:a,strides:i,pad:u}=n;return{x:()=>(0,s.Z)(e,r,o,a,i,u)}}}},62850:(e,t,n)=>{"use strict";n.d(t,{J:()=>u});var r=n(29121),s=n(83591),o=n(89065),a=n(59155),i=n(79363);const u={kernelName:r.Yo,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:u}=r,[l,c]=t,d=a.parseAxisParam(u,l.shape),h=s.Q3(d,l.rank),p=(0,i.c)(e,c,l,d,h);return{x:()=>{let e=p.x();return null!=h&&(e=(0,o.p)(e)),e}}}}},25241:(e,t,n)=>{"use strict";n.d(t,{R:()=>u});var r=n(29121),s=n(62271),o=n(17630),a=n(86573),i=n(24841);const u={kernelName:r.BM,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>(0,i.d)(e,(0,s.p)((0,o.b)(n,r),"float32")),b:()=>(0,i.d)(e,(0,s.p)((0,a.d)(n,r),"float32"))}}}},22735:(e,t,n)=>{"use strict";n.d(t,{j:()=>u});var r=n(29121),s=n(83591),o=n(89065),a=n(59155),i=n(79363);const u={kernelName:r.c1,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:u}=r,[l,c]=t,d=a.parseAxisParam(u,l.shape),h=s.Q3(d,l.rank),p=(0,i.c)(e,c,l,d,h);return{x:()=>{let e=p.x();return null!=h&&(e=(0,o.p)(e)),e}}}}},50629:(e,t,n)=>{"use strict";n.d(t,{c:()=>u});var r=n(29121),s=n(62271),o=n(20636),a=n(50624),i=n(24841);const u={kernelName:r.q8,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>(0,i.d)(e,(0,s.p)((0,a.z)(n,r),"float32")),b:()=>(0,i.d)(e,(0,s.p)((0,o.p)(n,r),"float32"))}}}},74812:(e,t,n)=>{"use strict";n.d(t,{E:()=>d});var r=n(29121),s=n(72200),o=n(41274),a=n(26943),i=n(24841),u=n(17370),l=n(4968),c=n(15475);const d={kernelName:r.Vb,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,d=(0,s.$N)(n.shape,r.shape);return{a:()=>{const t=(0,s.RR)(n.shape,d);return t.length>0?(0,l.X)((0,c.S)(e,t),n.shape):e},b:()=>{const t=(0,i.d)(e,(0,u.W)((0,a.G)((0,o.h)(n,r)))),h=(0,s.RR)(r.shape,d);return h.length>0?(0,l.X)((0,c.S)(t,h),r.shape):t}}}}},75508:(e,t,n)=>{"use strict";n.d(t,{q:()=>l});var r=n(29121),s=n(72200),o=n(62271),a=n(24841),i=n(4968),u=n(15475);const l={kernelName:r.wY,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,l=(0,s.$N)(n.shape,r.shape);return{a:()=>{const t=(0,a.d)(e,(0,o.p)(r,"float32")),c=(0,s.RR)(n.shape,l);return c.length>0?(0,i.X)((0,u.S)(t,c),n.shape):t},b:()=>{const t=(0,a.d)(e,(0,o.p)(n,"float32")),c=(0,s.RR)(r.shape,l);return c.length>0?(0,i.X)((0,u.S)(t,c),r.shape):t}}}}},8899:(e,t,n)=>{"use strict";n.d(t,{$:()=>o});var r=n(29121),s=n(17370);const o={kernelName:r.L0,gradFunc:e=>({x:()=>(0,s.W)(e)})}},30154:(e,t,n)=>{"use strict";n.d(t,{p:()=>o});var r=n(29121),s=n(59640);const o={kernelName:r.we,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>(0,s.l)(n.shape,"float32")}}}},63668:(e,t,n)=>{"use strict";n.d(t,{N:()=>o});var r=n(29121),s=n(6577);const o={kernelName:r.qW,gradFunc:e=>({x:()=>(0,s.P)(e)})}},99:(e,t,n)=>{"use strict";n.d(t,{G:()=>o});var r=n(29121),s=n(22676);const o={kernelName:r.ly,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:o}=n,a=o.map((e=>e[0]));return{x:()=>(0,s.t)(e,a,r.shape)}}}},45370:(e,t,n)=>{"use strict";n.d(t,{i:()=>g});var r=n(29121),s=n(72200),o=n(62271),a=n(20636),i=n(82597),u=n(24841),l=n(33453),c=n(4968),d=n(99494),h=n(70827),p=n(15475),f=n(95912),m=n(6577);const g={kernelName:r.pe,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,g]=t,x=n,v=r,b=s.$N(x.shape,v.shape);return{a:()=>{const t=(0,o.p)(v,"float32");let n=(0,u.d)(e,(0,u.d)(t,(0,l.s)(x,(0,h.l)(t,(0,d.i)(1)))));const r=s.RR(x.shape,b);return r.length>0&&(n=(0,p.S)(n,r)),(0,c.X)(n,x.shape)},b:()=>{const t=(0,a.p)(x,0),n=(0,f.a)(t,(0,i.c)(x),(0,m.P)(x));let r=(0,u.d)(e,(0,u.d)(g,n));const o=s.RR(v.shape,b);return o.length>0&&(r=(0,p.S)(r,o)),(0,c.X)(r,v.shape)}}}}},96587:(e,t,n)=>{"use strict";n.d(t,{d:()=>d});var r=n(29121),s=n(72200),o=n(20636),a=n(24841),i=n(4968),u=n(15475),l=n(95912),c=n(6577);const d={kernelName:r.o0,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,d=(0,o.p)(n,0);return{x:()=>(0,l.a)(d,e,(0,a.d)(e,r)),alpha:()=>{let t=(0,l.a)(d,(0,c.P)(e),(0,a.d)(e,n));const o=(0,s.RR)(r.shape,e.shape);return o.length>0&&(t=(0,u.S)(t,o)),(0,i.X)(t,r.shape)}}}}},60006:(e,t,n)=>{"use strict";n.d(t,{a:()=>i});var r=n(29121),s=n(41274),o=n(17370),a=n(50248);const i={kernelName:r.$H,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.h)(e,(0,o.W)((0,a.h)(n)))}}}},76179:(e,t,n)=>{"use strict";n.d(t,{d:()=>u});var r=n(29121),s=n(62271),o=n(50624),a=n(24841),i=n(71901);const u={kernelName:r.Sb,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=(0,a.d)((0,o.z)(n,6),(0,i.N)(n));return{x:()=>(0,a.d)(e,(0,s.p)(r,"float32"))}}}},15938:(e,t,n)=>{"use strict";n.d(t,{T:()=>i});var r=n(29121),s=n(62271),o=n(24841),a=n(71901);const i={kernelName:r.qk,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,o.d)(e,(0,s.p)((0,a.N)(n),"float32"))}}}},15997:(e,t,n)=>{"use strict";n.d(t,{H:()=>o});var r=n(29121),s=n(4968);const o={kernelName:r.HZ,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.X)(e,n.shape)}}}},55253:(e,t,n)=>{"use strict";n.d(t,{G:()=>o});var r=n(23926),s=n(29121);const o={kernelName:s._Y,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[o]=t,a=t=>{const{alignCorners:r}=n;return t.resizeBilinearBackprop(e,o,r)},i={images:o};return{images:()=>r.BV.runKernelFunc(a,i,null,s.zb,n)}}}},84998:(e,t,n)=>{"use strict";n.d(t,{S:()=>o});var r=n(23926),s=n(29121);const o={kernelName:s.dp,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[o]=t,a=t=>{const{alignCorners:r}=n;return t.resizeNearestNeighborBackprop(e,o,r)},i={images:o};return{images:()=>r.BV.runKernelFunc(a,i,null,s.Hm,n)}}}},95906:(e,t,n)=>{"use strict";n.d(t,{T:()=>a});var r=n(29121),s=n(57486),o=n(59155);const a={kernelName:r.mK,gradFunc:(e,t,n)=>{const{dims:r}=n,a=(0,o.parseAxisParam)(r,e.shape);return{x:()=>(0,s.G)(e,a)}}}},30027:(e,t,n)=>{"use strict";n.d(t,{O:()=>o});var r=n(29121),s=n(6577);const o={kernelName:r.e0,gradFunc:e=>({x:()=>(0,s.P)(e)})}},37699:(e,t,n)=>{"use strict";n.d(t,{C:()=>u});var r=n(29121),s=n(41274),o=n(24841),a=n(17370),i=n(33453);const u={kernelName:r.bV,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,a.W)((0,s.h)(e,(0,o.d)((0,i.s)(n,1.5),2)))}}}},47738:(e,t,n)=>{"use strict";n.d(t,{B:()=>u});var r=n(29121),s=n(62271),o=n(38651),a=n(24841),i=n(6577);const u={kernelName:r.xc,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>(0,s.p)((0,i.P)(n),"float32"),t:()=>(0,a.d)(e,(0,s.p)(n,e.dtype)),e:()=>(0,a.d)(e,(0,s.p)((0,o.h)(n),e.dtype))}}}},82606:(e,t,n)=>{"use strict";n.d(t,{W:()=>d});var r=n(29121),s=n(62271),o=n(44842),a=n(20636),i=n(24841),u=n(99494),l=n(43179),c=n(95912);const d={kernelName:r.oF,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=(0,a.p)(n,(0,u.i)(0)),r=(0,u.i)(l.y),d=(0,u.i)(l.$),h=(0,i.d)(e,d),p=(0,i.d)((0,i.d)(e,r),(0,o.Q)((0,s.p)(n,"float32")));return(0,c.a)(t,h,p)}}}}},45777:(e,t,n)=>{"use strict";n.d(t,{E:()=>i});var r=n(29121),s=n(24841),o=n(99494),a=n(70827);const i={kernelName:r.a5,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.d)(e,(0,s.d)(n,(0,a.l)((0,o.i)(1),n)))}}}},80125:(e,t,n)=>{"use strict";n.d(t,{Q:()=>o});var r=n(29121),s=n(6577);const o={kernelName:r.i5,gradFunc:e=>({x:()=>(0,s.P)(e)})}},94936:(e,t,n)=>{"use strict";n.d(t,{_:()=>i});var r=n(29121),s=n(62271),o=n(70173),a=n(24841);const i={kernelName:r.RQ,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,a.d)((0,o.m)((0,s.p)(n,"float32")),e)}}}},77145:(e,t,n)=>{"use strict";n.d(t,{m:()=>i});var r=n(29121),s=n(62271),o=n(2699),a=n(24841);const i={kernelName:r.w3,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,a.d)((0,o.f)((0,s.p)(n,"float32")),e)}}}},22154:(e,t,n)=>{"use strict";n.d(t,{M:()=>a});var r=n(29121),s=n(39682),o=n(37650);const a={kernelName:r.p2,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:a,size:i}=n,u=r.shape,[l,c]=(0,o.parseSliceParams)(r,a,i),d=[];for(let t=0;t<e.rank;t++)d.push([l[t],u[t]-l[t]-c[t]]);return{x:()=>(0,s.v)(e,d)}}}},82232:(e,t,n)=>{"use strict";n.d(t,{J:()=>i});var r=n(29121),s=n(24841),o=n(70827),a=n(15475);const i={kernelName:r.Gc,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:i}=n,u=(0,s.d)(e,r);return{logits:()=>(0,o.l)(u,(0,s.d)((0,a.S)(u,[i],!0),r))}}}},71372:(e,t,n)=>{"use strict";n.d(t,{H:()=>a});var r=n(29121),s=n(24841),o=n(30625);const a={kernelName:r.MR,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.d)(e,(0,o.X)(n))}}}},18558:(e,t,n)=>{"use strict";n.d(t,{a:()=>o});var r=n(29121),s=n(28441);const o={kernelName:r.TQ,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:o}=n;return{x:()=>(0,s.E)(e,r,o)}}}},32439:(e,t,n)=>{"use strict";n.d(t,{n:()=>o});var r=n(29121),s=n(46884);const o={kernelName:r.L8,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>(0,s.z)(e,r)}}}},30595:(e,t,n)=>{"use strict";n.d(t,{C:()=>u});var r=n(29121),s=n(62271),o=n(41274),a=n(24841),i=n(13261);const u={kernelName:r.FK,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,o.h)(e,(0,a.d)((0,i._)((0,s.p)(n,"float32")),2))}}}},40521:(e,t,n)=>{"use strict";n.d(t,{t:()=>a});var r=n(29121),s=n(62271),o=n(24841);const a={kernelName:r.bK,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,o.d)(e,(0,o.d)((0,s.p)(n,"float32"),2))}}}},79719:(e,t,n)=>{"use strict";n.d(t,{k:()=>i});var r=n(29121),s=n(24841),o=n(99494),a=n(70827);const i={kernelName:r._t,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,i=(0,o.i)(2);return{a:()=>(0,s.d)(e,(0,s.d)(i,(0,a.l)(n,r))),b:()=>(0,s.d)(e,(0,s.d)(i,(0,a.l)(r,n)))}}}},81554:(e,t,n)=>{"use strict";n.d(t,{l:()=>o});var r=n(29121),s=n(6577);const o={kernelName:r.h8,gradFunc:e=>({x:()=>(0,s.P)(e)})}},9460:(e,t,n)=>{"use strict";n.d(t,{h:()=>u});var r=n(29121),s=n(72200),o=n(17370),a=n(4968),i=n(15475);const u={kernelName:r.Tr,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,u=s.$N(n.shape,r.shape);return{a:()=>{let t=e;const r=s.RR(n.shape,u);return r.length>0&&(t=(0,i.S)(t,r)),(0,a.X)(t,n.shape)},b:()=>{let t=e;const n=s.RR(r.shape,u);return n.length>0&&(t=(0,i.S)(t,n)),(0,a.X)((0,o.W)(t),r.shape)}}}}},14574:(e,t,n)=>{"use strict";n.d(t,{y:()=>u});var r=n(29121),s=n(24841),o=n(44917),a=n(4968),i=n(59155);const u={kernelName:r.GB,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,u=r.shape.slice(),{axis:l}=n;(0,i.parseAxisParam)(l,r.shape).forEach((e=>{u[e]=1}));const c=(0,a.X)(e,u),d=(0,s.d)(c,(0,o.i)(r.shape,"float32"));return{x:()=>d}}}},83933:(e,t,n)=>{"use strict";n.d(t,{w:()=>i});var r=n(29121),s=n(70173),o=n(41274),a=n(50248);const i={kernelName:r.sE,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,o.h)(e,(0,a.h)((0,s.m)(n)))}}}},47320:(e,t,n)=>{"use strict";n.d(t,{W:()=>u});var r=n(29121),s=n(24841),o=n(99494),a=n(50248),i=n(70827);const u={kernelName:r.MI,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.d)((0,i.l)((0,o.i)(1),(0,a.h)(n)),e)}}}},272:(e,t,n)=>{"use strict";n.d(t,{x:()=>i});var r=n(29121),s=n(56407),o=n(22676),a=n(6577);const i={kernelName:r.n9,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:i}=n;return{x:()=>{let t=(0,a.P)(r);if(1===r.rank)for(let n=0;n<i[0];++n)t=(0,s.I)(t,(0,o.t)(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<i[0];++n)for(let a=0;a<i[1];++a)t=(0,s.I)(t,(0,o.t)(e,[n*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<i[0];++n)for(let a=0;a<i[1];++a)for(let u=0;u<i[2];++u)t=(0,s.I)(t,(0,o.t)(e,[n*r.shape[0],a*r.shape[1],u*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+r.rank+" tensors yet.");for(let n=0;n<i[0];++n)for(let a=0;a<i[1];++a)for(let u=0;u<i[2];++u)for(let l=0;l<i[3];++l)t=(0,s.I)(t,(0,o.t)(e,[n*r.shape[0],a*r.shape[1],u*r.shape[2],l*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}}},22625:(e,t,n)=>{"use strict";n.d(t,{j:()=>a});var r=n(29121),s=n(83591),o=n(89065);const a={kernelName:r.G3,gradFunc:(e,t,n)=>{const r=n,{perm:a}=r,i=s.LJ(a);return{x:()=>(0,o.p)(e,i)}}}},23489:(e,t,n)=>{"use strict";n.d(t,{T:()=>o});var r=n(29121),s=n(82991);const o={kernelName:r.To,gradFunc:(e,t,n)=>{const r=n,{axis:o}=r;return{value:()=>(0,s.k)(e,o)}}}},52679:(e,t,n)=>{"use strict";n.d(t,{x:()=>p});var r=n(29121),s=n(81300),o=n(24926),a=n(17630),i=n(2856),u=n(80632),l=n(44917),c=n(99494),d=n(95912),h=n(6577);const p={kernelName:r.Qv,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=(0,u.g)(t,(0,h.P)(t)),r=(0,o.I)(e,n);let p=(0,a.b)(t,(0,c.i)(0,"int32"));const f=r.rank-p.rank;for(let e=0;e<f;++e)p=(0,s.d)(p,e+1);p=(0,i.H)(p,(0,l.i)(r.shape,"bool"));const m=(0,h.P)(r);return(0,d.a)(p,r,m)}(e,n)}}}},51466:(e,t,n)=>{"use strict";n.d(t,{a:()=>o});var r=n(29121),s=n(6577);const o={kernelName:r.Ru,gradFunc:e=>({x:()=>(0,s.P)(e)})}},79363:(e,t,n)=>{"use strict";n.d(t,{c:()=>l});var r=n(83591),s=n(62271),o=n(26477),a=n(24841),i=n(4968),u=n(89065);function l(e,t,n,l,c){return t.rank<n.rank&&(t=(0,i.X)(t,r.rv(t.shape,l))),e.rank<n.rank&&(e=(0,i.X)(e,r.rv(e.shape,l))),{x:()=>{const r=(0,a.d)(e,(0,s.p)((0,o.D)(n,t),e.dtype));return null==c?r:(0,u.p)(r,c)}}}},6639:(e,t,n)=>{"use strict";n.d(t,{Abs:()=>r.SYM,Acos:()=>r.VGw,Acosh:()=>r.SpW,Add:()=>r.mm_,Asin:()=>r.M2y,Asinh:()=>r.qw7,Atan:()=>r.jMg,Atan2:()=>r.QCc,Atanh:()=>r.Oyi,AvgPool:()=>r.JhU,AvgPoolBackprop:()=>r.xts,Cast:()=>r.RFZ,Ceil:()=>r.gJX,ClipByValue:()=>r.xnO,Complex:()=>r.Zz9,Concat:()=>r.Eh3,Cos:()=>r.mc4,Cosh:()=>r.TR1,DataStorage:()=>r.JLz,Dilation2D:()=>r.p4S,Dilation2DBackpropFilter:()=>r.Vn9,Dilation2DBackpropInput:()=>r.ekb,Div:()=>r.ZCY,Elu:()=>r.SX0,Erf:()=>r.Omj,Exp:()=>r.NEP,Expm1:()=>r.Y0y,FFT:()=>r.vwp,FlipLeftRight:()=>r.Uyb,Floor:()=>r.OR,FromPixels:()=>r.eBW,FusedBatchNorm:()=>r.sHE,IFFT:()=>r.Qg5,Identity:()=>r.iJz,Imag:()=>r.J_u,IsFinite:()=>r.avt,IsInf:()=>r.iWB,IsNan:()=>r.r7n,KernelBackend:()=>r.Zuw,Log:()=>r.ZbH,Log1p:()=>r.kU,LogicalNot:()=>r.VfG,Max:()=>r.YoZ,MaxPool:()=>r.mTV,MaxPoolBackprop:()=>r.GvW,MaxPoolWithArgmax:()=>r.vFR,Multiply:()=>r.wYn,NonMaxSuppressionV3:()=>r.uv1,NonMaxSuppressionV4:()=>r.cye,NonMaxSuppressionV5:()=>r.W0H,NotEqual:()=>r.yQU,PadV2:()=>r.lyA,Real:()=>r.xJR,Reciprocal:()=>r.$HU,Reshape:()=>r.HZH,RotateWithOffset:()=>r.b9H,Round:()=>r.e07,Rsqrt:()=>r.bV0,Selu:()=>r.oFR,Sigmoid:()=>r.a5O,Sign:()=>r.i5y,Sin:()=>r.RQH,Sinh:()=>r.wYB,Slice:()=>r.p2w,Softplus:()=>r.MRv,SpaceToBatchND:()=>r.TQc,Sqrt:()=>r.FKq,Square:()=>r.bK0,SquaredDifference:()=>r._tC,Step:()=>r.h8e,Sub:()=>r.Tr8,Tan:()=>r.sEM,Tanh:()=>r.MIZ,TensorBuffer:()=>r.YDk,Transpose:()=>r.G3Y,Unique:()=>r.kpP,add:()=>r.IHx,backend_util:()=>r.Wap,buffer:()=>r.f3b,complex:()=>r.PYB,device_util:()=>r.C2$,div:()=>r.hiC,elu:()=>r.pyx,engine:()=>r.SRH,env:()=>r.OBj,equal:()=>r.DgJ,exp:()=>r.Qqt,imag:()=>r.asL,kernel_impls:()=>r.GDt,max:()=>r.Fp7,mul:()=>r.dC7,range:()=>r.w6H,real:()=>r.kwC,registerBackend:()=>r.jqO,registerKernel:()=>r.wCN,reshape:()=>r.XLQ,scalar:()=>r.iD$,slice:()=>r.tPi,slice_util:()=>r.kuN,softmax:()=>r.XAC,stack:()=>r.knu,sub:()=>r.luU,sumOutType:()=>r.z4k,tensor:()=>r.XeE,tensor2d:()=>r.odF,tensor4d:()=>r.yXz,tidy:()=>r.lub,transpose:()=>r.p4s,upcastType:()=>r.x8V,util:()=>r.D5U,zeros:()=>r.lls}),n(88549);var r=n(45898);n(88940),n(64642)},23625:(e,t,n)=>{"use strict";n(79998);var r=n(22885),s=n(91989),o=n(36493);function a(e){return new Promise((e=>setTimeout(e))).then(e)}class i{constructor(e){if(!(0,r.OB)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(i.URL_SCHEME)&&(e=e.slice(i.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelTopologyFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:n},o=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),i=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor;if(i.download=this.modelTopologyFileName,i.href=o,await a((()=>i.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=t,await a((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:(0,s.Q)(e)}}}}i.URL_SCHEME="downloads://",o.U3.registerSaveRouter((e=>(0,r.OB)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(i.URL_SCHEME)?function(e="model"){return new i(e)}(e.slice(i.URL_SCHEME.length)):null))},80731:(e,t,n)=>{"use strict";var r=n(22885),s=n(59155),o=n(91989),a=n(36493),i=n(93120);class u{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?((0,s.assert)("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=(0,r.OB)().platform.fetch,(0,s.assert)(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&(0,s.assert)(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,userDefinedMetadata:e.userDefinedMetadata,weightsManifest:n};t.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),null!=e.weightData&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:(0,o.Q)(e),responses:[s]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+s.status+".")}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code `+e.status+". Please verify this URL points to the model JSON of the model to load.");let t;try{t=await e.json()}catch(e){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,r=t.weightsManifest,s=t.generatedBy,o=t.convertedBy,a=t.format,i=t.userDefinedMetadata;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let u,l;if(null!=r){const e=await this.loadWeights(r);[u,l]=e}const c={modelTopology:n,weightSpecs:u,weightData:l,userDefinedMetadata:i,generatedBy:s,convertedBy:o,format:a},d=t.modelInitializer;return d&&(c.modelInitializer=d),c}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?");return[e.substring(0,t)+"/",n>t?e.substring(n):""]}(t),s=this.weightPathPrefix||n,a=[];for(const t of e)a.push(...t.weights);const u=[],l=[];for(const t of e)for(const e of t.paths)null!=this.weightUrlConverter?l.push(this.weightUrlConverter(e)):u.push(s+e+r);this.weightUrlConverter&&u.push(...await Promise.all(l));const c=await(0,i.aV)(u,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,(0,o.JY)(c)]}}function l(e){return null!=e.match(u.URL_SCHEME_REGEX)}u.URL_SCHEME_REGEX=/^https?:\/\//;const c=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>l(e))):l(e),n)return function(e,t){return new u(e,t)}(e,t)}return null};a.U3.registerSaveRouter(c),a.U3.registerLoadRouter(c)},61044:(e,t,n)=>{"use strict";n.d(t,{ns:()=>d,y$:()=>p}),n(79998);var r=n(22885),s=n(91989),o=n(36493);const a="tensorflowjs",i="models_store",u="model_info_store";function l(){if(!(0,r.OB)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function c(e){const t=e.result;t.createObjectStore(i,{keyPath:"modelPath"}),t.createObjectStore(u,{keyPath:"modelPath"})}class d{constructor(e){if(this.indexedDB=l(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(a,1);r.onupgradeneeded=()=>c(r),r.onsuccess=()=>{const o=r.result;if(null==t){const t=o.transaction(i,"readonly"),r=t.objectStore(i).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return o.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(o.close(),n(r.error)),t.oncomplete=()=>o.close()}else{const r=(0,s.Q)(t),a=o.transaction(u,"readwrite");let l=a.objectStore(u);const c=l.put({modelPath:this.modelPath,modelArtifactsInfo:r});let d;c.onsuccess=()=>{d=o.transaction(i,"readwrite");const s=d.objectStore(i).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r});s.onsuccess=()=>e({modelArtifactsInfo:r}),s.onerror=e=>{l=a.objectStore(u);const t=l.delete(this.modelPath);t.onsuccess=()=>(o.close(),n(s.error)),t.onerror=e=>(o.close(),n(s.error))}},c.onerror=e=>(o.close(),n(c.error)),a.oncomplete=()=>{null==d?o.close():d.oncomplete=()=>o.close()}}},r.onerror=e=>n(r.error)}))}}d.URL_SCHEME="indexeddb://";const h=e=>{return(0,r.OB)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(d.URL_SCHEME)?(t=e.slice(d.URL_SCHEME.length),new d(t)):null;var t};o.U3.registerSaveRouter(h),o.U3.registerLoadRouter(h);class p{constructor(){this.indexedDB=l()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(a,1);n.onupgradeneeded=()=>c(n),n.onsuccess=()=>{const r=n.result,s=r.transaction(u,"readonly"),o=s.objectStore(u).getAll();o.onsuccess=()=>{const t={};for(const e of o.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},o.onerror=e=>(r.close(),t(o.error)),s.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(d.URL_SCHEME)?t.slice(d.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open(a,1);r.onupgradeneeded=()=>c(r),r.onsuccess=()=>{const s=r.result,o=s.transaction(u,"readwrite"),a=o.objectStore(u),l=a.get(e);let c;l.onsuccess=()=>{if(null==l.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=a.delete(e),o=()=>{c=s.transaction(i,"readwrite");const r=c.objectStore(i).delete(e);r.onsuccess=()=>t(l.result.modelArtifactsInfo),r.onerror=e=>n(l.error)};r.onsuccess=o,r.onerror=e=>(o(),s.close(),n(l.error))}},l.onerror=e=>(s.close(),n(l.error)),o.oncomplete=()=>{null==c?s.close():c.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)}))}}},46784:(e,t,n)=>{"use strict";n(61044),n(28209),n(23625),n(80731),n(91989),n(93120),n(90780)},91989:(e,t,n)=>{"use strict";n.d(t,{_n:()=>o,n7:()=>a,JY:()=>i,Q:()=>u}),n(75771);const r="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function s(e){return r?Buffer.byteLength(e):new Blob([e]).size}function o(e){if(r)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let e=0,r=t.length;e<r;e++)n+=String.fromCharCode(t[e]);return btoa(n)}function a(e){if(r){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n.set([t.charCodeAt(e)],e);return n.buffer}function i(e){if(1===e.length)return e[0];let t=0;e.forEach((e=>{t+=e.byteLength}));const n=new Uint8Array(t);let r=0;return e.forEach((e=>{n.set(new Uint8Array(e),r),r+=e.byteLength})),n.buffer}function u(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:s(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:s(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}},28209:(e,t,n)=>{"use strict";n.d(t,{Ew:()=>g,JL:()=>v}),n(79998);var r=n(22885),s=n(59155),o=n(91989),a=n(36493);const i="/",u="tensorflowjs_models",l="info",c="model_topology",d="weight_specs",h="weight_data",p="model_metadata";function f(e){return{info:[u,e,l].join(i),topology:[u,e,c].join(i),weightSpecs:[u,e,d].join(i),weightData:[u,e,h].join(i),modelMetadata:[u,e,p].join(i)}}function m(e){const t=e.split(i);if(t.length<3)throw new Error("Invalid key format: "+e);return t.slice(1,t.length-1).join(i)}class g{constructor(e){if(!(0,r.OB)().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=f(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=(0,o.Q)(e);try{return this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,(0,o._n)(e.weightData)),this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,userDefinedMetadata:e.userDefinedMetadata})),{modelArtifactsInfo:r}}catch(e){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const e=JSON.parse(s);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,t.userDefinedMetadata=e.userDefinedMetadata}const a=this.LS.getItem(this.keys.weightData);if(null==a)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=(0,o.n7)(a),t}}g.URL_SCHEME="localstorage://";const x=e=>{return(0,r.OB)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(g.URL_SCHEME)?(t=e.slice(g.URL_SCHEME.length),new g(t)):null;var t};a.U3.registerSaveRouter(x),a.U3.registerLoadRouter(x);class v{constructor(){(0,s.assert)((0,r.OB)().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),(0,s.assert)("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=u+i,n=i+l;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);s.startsWith(t)&&s.endsWith(n)&&(e[m(s)]=JSON.parse(this.LS.getItem(s)))}return e}async removeModel(e){var t;const n=f(e=(t=e).startsWith(g.URL_SCHEME)?t.slice(g.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return this.LS.removeItem(n.info),this.LS.removeItem(n.topology),this.LS.removeItem(n.weightSpecs),this.LS.removeItem(n.weightData),r}}},90780:(e,t,n)=>{"use strict";n.d(t,{xQ:()=>s});var r=n(59155);class s{constructor(){this.managers={}}static getInstance(){return null==s.instance&&(s.instance=new s),s.instance}static registerManager(e,t){(0,r.assert)(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),(0,r.assert)(e.length>0,(()=>"scheme must not be an empty string."));const n=s.getInstance();(0,r.assert)(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}},86737:(e,t,n)=>{"use strict";n.d(t,{b:()=>s});var r=n(59155);function s(e,t,n,s){!function(e){(0,r.assert)(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){(0,r.assert)(e>=0&&e<=1,(()=>"Progress fraction must be in range [0, 1], but got startFraction "+e)),(0,r.assert)(t>=0&&t<=1,(()=>"Progress fraction must be in range [0, 1], but got endFraction "+t)),(0,r.assert)(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction `+t))}(n=null==n?0:n,s=null==s?1:s);let o=0;return Promise.all(e.map((r=>(r.then((r=>{const a=n+ ++o/e.length*(s-n);return t(a),r})),r))))}},36493:(e,t,n)=>{"use strict";n.d(t,{U3:()=>r});class r{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==r.instance&&(r.instance=new r),r.instance}static registerSaveRouter(e){r.getInstance().saveRouters.push(e)}static registerLoadRouter(e){r.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return r.getHandlers(e,"save")}static getLoadHandlers(e,t){return r.getHandlers(e,"load",t)}static getHandlers(e,t,n){const s=[];return("load"===t?r.getInstance().loadRouters:r.getInstance().saveRouters).forEach((t=>{const r=t(e,n);null!==r&&s.push(r)})),s}}},75771:(e,t,n)=>{},93120:(e,t,n)=>{"use strict";n.d(t,{aV:()=>o});var r=n(22885),s=(n(91989),n(86737));async function o(e,t){null==t&&(t={});const n=null==t.fetchFunc?(0,r.OB)().platform.fetch:t.fetchFunc,o=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),a=(null==t.onProgress?await Promise.all(o):await(0,s.b)(o,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(a):await(0,s.b)(a,t.onProgress,.5,1)}n(75771)},29121:(e,t,n)=>{"use strict";n.d(t,{SY:()=>r,VG:()=>s,Sp:()=>o,mm:()=>a,Xz:()=>i,oT:()=>u,IK:()=>l,sJ:()=>c,aJ:()=>d,M2:()=>h,qw:()=>p,jM:()=>f,Oy:()=>m,QC:()=>g,Jh:()=>x,xt:()=>v,_k:()=>b,DC:()=>y,XL:()=>w,zw:()=>k,Ly:()=>I,RF:()=>C,gJ:()=>$,xn:()=>S,Zz:()=>R,Eh:()=>E,mh:()=>T,wU:()=>A,wm:()=>_,x1:()=>N,o2:()=>F,ik:()=>D,mc:()=>B,TR:()=>O,iH:()=>M,Vc:()=>P,T0:()=>L,ci:()=>V,sL:()=>W,y7:()=>z,p4:()=>U,ek:()=>H,Vn:()=>G,ZC:()=>X,SX:()=>q,HE:()=>K,Om:()=>j,hd:()=>Y,NE:()=>Q,Y0:()=>J,vw:()=>Z,de:()=>ee,Uy:()=>te,OR:()=>ne,je:()=>re,sH:()=>se,qi:()=>oe,iZ:()=>ae,Ac:()=>ie,iJ:()=>ue,Qg:()=>le,J_:()=>ce,av:()=>de,iW:()=>he,r7:()=>pe,vt:()=>fe,CA:()=>me,Zb:()=>ge,kU:()=>xe,PY:()=>ve,Vf:()=>be,MZ:()=>ye,qC:()=>we,eZ:()=>ke,vI:()=>Ie,Yo:()=>Ce,BM:()=>$e,mT:()=>Se,Gv:()=>Re,OA:()=>Ee,f:()=>Te,vF:()=>Ae,c1:()=>_e,q8:()=>Ne,Vb:()=>Fe,wY:()=>De,L0:()=>Be,yQ:()=>Oe,uv:()=>Me,cy:()=>Pe,W0:()=>Le,qW:()=>Ve,we:()=>We,ly:()=>ze,pe:()=>Ue,o0:()=>He,Dl:()=>Ge,e6:()=>Xe,xJ:()=>qe,$H:()=>Ke,qk:()=>je,HZ:()=>Ye,dp:()=>Qe,Hm:()=>Je,_Y:()=>Ze,zb:()=>et,Sb:()=>tt,mK:()=>nt,e0:()=>rt,bV:()=>st,xc:()=>ot,oF:()=>at,p2:()=>it,RQ:()=>ut,w3:()=>lt,i5:()=>ct,a5:()=>dt,MR:()=>ht,FK:()=>pt,GB:()=>ft,TQ:()=>mt,L8:()=>gt,Gc:()=>xt,_t:()=>vt,bK:()=>bt,Tr:()=>yt,jQ:()=>wt,sE:()=>kt,MI:()=>It,n9:()=>Ct,cW:()=>$t,G3:()=>St,kp:()=>Rt,To:()=>Et,Qv:()=>Tt,Ru:()=>At,h8:()=>_t,eB:()=>Nt,b9:()=>Ft});const r="Abs",s="Acos",o="Acosh",a="Add",i="AddN",u="All",l="Any",c="ArgMax",d="ArgMin",h="Asin",p="Asinh",f="Atan",m="Atanh",g="Atan2",x="AvgPool",v="AvgPoolBackprop",b="AvgPool3D",y="AvgPool3DBackprop",w="BatchMatMul",k="BatchToSpaceND",I="BroadcastTo",C="Cast",$="Ceil",S="ClipByValue",R="Complex",E="Concat",T="Conv2D",A="Conv2DBackpropFilter",_="Conv2DBackpropInput",N="Conv3D",F="Conv3DBackpropFilterV2",D="Conv3DBackpropInputV2",B="Cos",O="Cosh",M="Cumsum",P="CropAndResize",L="DepthToSpace",V="DepthwiseConv2dNative",W="DepthwiseConv2dNativeBackpropFilter",z="DepthwiseConv2dNativeBackpropInput",U="Dilation2D",H="Dilation2DBackpropInput",G="Dilation2DBackpropFilter",X="Div",q="Elu",K="EluGrad",j="Erf",Y="Equal",Q="Exp",J="Expm1",Z="FFT",ee="Fill",te="FlipLeftRight",ne="Floor",re="FloorDiv",se="FusedBatchNorm",oe="GatherV2",ae="Greater",ie="GreaterEqual",ue="Identity",le="IFFT",ce="Imag",de="IsFinite",he="IsInf",pe="IsNan",fe="Less",me="LessEqual",ge="Log",xe="Log1p",ve="LogicalAnd",be="LogicalNot",ye="LogicalOr",we="LogSoftmax",ke="LRN",Ie="LRNBackprop",Ce="Max",$e="Maximum",Se="MaxPool",Re="MaxPoolBackprop",Ee="MaxPool3D",Te="MaxPool3DBackprop",Ae="MaxPoolWithArgmax",_e="Min",Ne="Minimum",Fe="Mod",De="Multiply",Be="Negate",Oe="NotEqual",Me="NonMaxSuppressionV3",Pe="NonMaxSuppressionV4",Le="NonMaxSuppressionV5",Ve="OnesLike",We="OneHot",ze="PadV2",Ue="Pow",He="Prelu",Ge="Prod",Xe="Range",qe="Real",Ke="Reciprocal",je="Relu",Ye="Reshape",Qe="ResizeNearestNeighbor",Je="ResizeNearestNeighborGrad",Ze="ResizeBilinear",et="ResizeBilinearGrad",tt="Relu6",nt="Reverse",rt="Round",st="Rsqrt",ot="SelectV2",at="Selu",it="Slice",ut="Sin",lt="Sinh",ct="Sign",dt="Sigmoid",ht="Softplus",pt="Sqrt",ft="Sum",mt="SpaceToBatchND",gt="SplitV",xt="Softmax",vt="SquaredDifference",bt="Square",yt="Sub",wt="StridedSlice",kt="Tan",It="Tanh",Ct="Tile",$t="TopK",St="Transpose",Rt="Unique",Et="Unpack",Tt="UnsortedSegmentSum",At="ZerosLike",_t="Step",Nt="FromPixels",Ft="RotateWithOffset"},26151:(e,t,n)=>{"use strict";n.d(t,{pI:()=>i,uk:()=>u,tr:()=>l,wC:()=>c,Li:()=>d});var r=n(22885),s=n(55938);const o=(0,s.R)("kernelRegistry",(()=>new Map)),a=(0,s.R)("gradRegistry",(()=>new Map));function i(e,t){const n=h(e,t);return o.get(n)}function u(e){return a.get(e)}function l(e){const t=o.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[o,a]=s,[i]=o.split("_");i===e&&n.push(a)}return n}function c(e){const{kernelName:t,backendName:n}=e,r=h(t,n);o.has(r)&&console.warn(`The kernel '${t}' for backend '${n}' is already registered`),o.set(r,e)}function d(e){const{kernelName:t}=e;a.has(t)&&(0,r.OB)().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${t}'`),a.set(t,e)}function h(e,t){return`${t}_${e}`}},64706:(e,t,n)=>{"use strict";n.d(t,{Z:()=>s,c:()=>o});var r=n(22885);function s(...e){(0,r.OB)().getBool("IS_TEST")||console.warn(...e)}function o(...e){(0,r.OB)().getBool("IS_TEST")||console.log(...e)}},96235:(e,t,n)=>{"use strict";n.d(t,{W:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({abs_:function(e){const t=(0,o._1)(e,"x","abs"),n={x:t};return r.BV.runKernelFunc(((e,n)=>(n([t]),"complex64"===t.dtype?e.complexAbs(t):e.abs(t))),n,null,s.SY)}})},17839:(e,t,n)=>{"use strict";n.d(t,{K:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({acos_:function(e){const t=(0,o._1)(e,"x","acos"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.acos(t);return n([t]),r}),n,null,s.VG)}})},91470:(e,t,n)=>{"use strict";n.d(t,{_:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({acosh_:function(e){const t=(0,o._1)(e,"x","acosh"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.acosh(t);return n([t]),r}),n,null,s.Sp)}})},56407:(e,t,n)=>{"use strict";n.d(t,{I:()=>i});var r=n(23926),s=n(29121),o=n(80747),a=n(43740);const i=(0,n(2668).op)({add_:function(e,t){let n=(0,a._1)(e,"a","add"),i=(0,a._1)(t,"b","add");[n,i]=(0,o.makeTypesMatch)(n,i);const u={a:n,b:i};return r.BV.runKernelFunc(((e,t)=>{const r=e.add(n,i);return t([n,i]),r}),u,null,s.mm)}})},90781:(e,t,n)=>{"use strict";n.d(t,{$:()=>d});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(83591),u=n(2668),l=n(4968),c=n(89065);const d=(0,u.op)({all_:function(e,t=null,n=!1){let u=(0,o._1)(e,"x","all","bool");const d={x:u},h={axis:t,keepDims:n};return r.BV.runKernelFunc((e=>{const r=(0,a.parseAxisParam)(t,u.shape);let s=r;const o=(0,i.Q3)(s,u.rank);null!=o&&(u=(0,c.p)(u,o),s=(0,i.sY)(s.length,u.rank));const d=e.all(u,s);if(n){const e=(0,i.rv)(d.shape,r);return(0,l.X)(d,e)}return d}),d,null,s.oT,h)}})},92998:(e,t,n)=>{"use strict";n.d(t,{Y:()=>d});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(83591),u=n(2668),l=n(4968),c=n(89065);const d=(0,u.op)({any_:function(e,t=null,n=!1){let u=(0,o._1)(e,"x","any","bool");const d={x:u},h={axis:t,keepDims:n};return r.BV.runKernelFunc((e=>{const r=(0,a.parseAxisParam)(t,u.shape);let s=r;const o=(0,i.Q3)(s,u.rank);null!=o&&(u=(0,c.p)(u,o),s=(0,i.sY)(s.length,u.rank));const d=e.any(u,s);if(n){const e=(0,i.rv)(d.shape,r);return(0,l.X)(d,e)}return d}),d,null,s.IK,h)}})},40047:(e,t,n)=>{"use strict";n.d(t,{N:()=>c});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(83591),u=n(2668),l=n(89065);const c=(0,u.op)({argMax_:function(e,t=0){let n=(0,o._1)(e,"x","argMax");const u={x:n},c={axis:t};return r.BV.runKernelFunc(((e,r)=>{r([n]);let s=a.parseAxisParam(t,n.shape);const o=i.Q3(s,n.rank);return null!=o&&(n=(0,l.p)(n,o),s=i.sY(s.length,n.rank)),e.argMax(n,s[0])}),u,null,s.sJ,c)}})},27394:(e,t,n)=>{"use strict";n.d(t,{v:()=>c});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(83591),u=n(2668),l=n(89065);const c=(0,u.op)({argMin_:function(e,t=0){let n=(0,o._1)(e,"x","argMin");const u={x:n},c={axis:t};return r.BV.runKernelFunc(((e,r)=>{r([n]),null==t&&(t=0);let s=a.parseAxisParam(t,n.shape);const o=i.Q3(s,n.rank);return null!=o&&(n=(0,l.p)(n,o),s=i.sY(s.length,n.rank)),e.argMin(n,s[0])}),u,null,s.aJ,c)}})},87199:(e,t,n)=>{"use strict";function r(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)s=s.concat([e[r+1]/t[r],t[r]]);s=s.concat(e.slice(n+1))}return s}function s(e,t,n=!0){const r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{const n=[],s=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?s.push(r):n.push(r);r.push(...n),r.push(0),r.push(...s)}return r}function o(e,t,n,r=!0){const s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let n=1;n<e.length;++n)n<=t.length?r?s.push(t[n-1]*e[n]):s.push(e[n]/t[n-1]):s.push(e[n]);return s}function a(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function i(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}n.d(t,{R7:()=>r,xw:()=>s,TK:()=>o,oP:()=>a,qX:()=>i})},72421:(e,t,n)=>{"use strict";n.d(t,{Z:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({asin_:function(e){const t=(0,o._1)(e,"x","asin"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.asin(t);return n([t]),r}),n,null,s.M2)}})},21891:(e,t,n)=>{"use strict";n.d(t,{V:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({asinh_:function(e){const t=(0,o._1)(e,"x","asinh"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.asinh(t);return n([t]),r}),n,null,s.qw)}})},77037:(e,t,n)=>{"use strict";n.d(t,{z:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({atan_:function(e){const t=(0,o._1)(e,"x","atan"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.atan(t);return n([t]),r}),n,null,s.jM)}})},29812:(e,t,n)=>{"use strict";n.d(t,{f:()=>i});var r=n(23926),s=n(29121),o=n(80747),a=n(43740);const i=(0,n(2668).op)({atan2_:function(e,t){let n=(0,a._1)(e,"a","atan2"),i=(0,a._1)(t,"b","atan2");[n,i]=(0,o.makeTypesMatch)(n,i);const u={a:n,b:i};return r.BV.runKernelFunc(((e,t)=>{const r=e.atan2(n,i);return t([n,i]),r}),u,null,s.QC)}})},80369:(e,t,n)=>{"use strict";n.d(t,{C:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({atanh_:function(e){const t=(0,o._1)(e,"x","atanh"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.atanh(t);return n([t]),r}),n,null,s.Oy)}})},15176:(e,t,n)=>{"use strict";n.d(t,{w:()=>d});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(62271),u=n(2582),l=n(2668),c=n(4968);const d=(0,l.op)({avgPool_:function(e,t,n,l,d){const h=(0,o._1)(e,"x","avgPool","float32");a.assert(u.jT(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let p=h,f=!1;3===h.rank&&(f=!0,p=(0,c.X)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),a.assert(4===p.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${p.rank}.`)),null!=d&&a.assert(a.isInt(l),(()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${d} but got pad ${l}.`));const m={x:p},g={filterSize:t,strides:n,pad:l,dimRoundingMode:d};let x=r.BV.runKernelFunc(((e,r)=>{const s=u.Xw(p.shape,t,n,1,l,d);return r([p]),1===s.filterWidth&&1===s.filterHeight&&a.arraysEqual(s.inShape,s.outShape)?p.clone():e.avgPool(p,s)}),m,null,s.Jh,g);return x=(0,i.p)(x,h.dtype),f?(0,c.X)(x,[x.shape[1],x.shape[2],x.shape[3]]):x}})},809:(e,t,n)=>{"use strict";n.d(t,{V:()=>c});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(2582),u=n(2668),l=n(4968);const c=(0,u.op)({avgPool3dBackprop_:function(e,t,n,u,c=[1,1,1],d,h){const p=(0,o._1)(e,"dy","avgPool3dBackprop"),f=(0,o._1)(t,"input","avgPool3dBackprop");let m=p,g=f,x=!1;4===f.rank&&(x=!0,m=(0,l.X)(p,[1,p.shape[0],p.shape[1],p.shape[2],p.shape[3]]),g=(0,l.X)(f,[1,f.shape[0],f.shape[1],f.shape[2],f.shape[3]])),a.assert(5===m.rank,(()=>"Error in avgPool3dBackprop: dy must be rank 5 but got rank "+m.rank+".")),a.assert(5===g.rank,(()=>"Error in avgPool3dBackprop: input must be rank 5 but got rank "+g.rank+".")),a.assert(i.jT(u,c),(()=>`Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides ${u} and dilations '${c}'`)),null!=h&&a.assert(a.isInt(d),(()=>`Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ${h} but got pad ${d}.`));const v={dy:m,input:g},b={filterSize:n,strides:u,dilations:c,pad:d,dimRoundingMode:h},y=r.BV.runKernelFunc((e=>{const t=i.pl(g.shape,n,u,c,d,h);return e.avgPool3dBackprop(m,g,t)}),v,null,s.DC,b);return x?(0,l.X)(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}})},21486:(e,t,n)=>{"use strict";n.d(t,{T:()=>c});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(2582),u=n(2668),l=n(4968);const c=(0,u.op)({avgPoolBackprop_:function(e,t,n,u,c){const d=(0,o._1)(e,"dy","avgPoolBackprop"),h=(0,o._1)(t,"input","avgPoolBackprop");a.assert(h.rank===d.rank,(()=>`Rank of input (${h.rank}) does not match rank of dy (${d.rank})`));let p=h,f=d,m=!1;3===h.rank&&(m=!0,p=(0,l.X)(h,[1,h.shape[0],h.shape[1],h.shape[2]]),f=(0,l.X)(d,[1,d.shape[0],d.shape[1],d.shape[2]])),a.assert(4===f.rank,(()=>"Error in avgPoolBackprop: dy must be rank 4 but got rank "+f.rank+".")),a.assert(4===p.rank,(()=>"Error in avgPoolBackprop: input must be rank 4 but got rank "+p.rank+"."));const g={dy:f,input:p},x={filterSize:n,strides:u,pad:c},v=r.BV.runKernelFunc((e=>{const t=i.Xw(p.shape,n,u,1,c);return e.avgPoolBackprop(f,p,t)}),g,null,s.xt,x);return m?(0,l.X)(v,[v.shape[1],v.shape[2],v.shape[3]]):v}})},83591:(e,t,n)=>{"use strict";n.d(t,{YB:()=>s,Vh:()=>o,kz:()=>a,rv:()=>i,lB:()=>u,Q3:()=>l,LJ:()=>c,sY:()=>d});var r=n(59155);function s(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function o(e,t,n){const r=e.length+t.length,s=[];let o=0,a=0;for(let i=0;i<r;i++)-1===n.indexOf(i)?s.push(e[o++]):s.push(t[a++]);return s}function a(e,t){const n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map((t=>e[t]))]}function i(e,t){return o(e,t.map((e=>1)),t)}function u(e,t,n){r.assert(s(t,n),(()=>e+" supports only inner-most axes for now. "+`Got axes ${t} and rank-${n} input.`))}function l(e,t){if(s(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function c(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function d(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}},28441:(e,t,n)=>{"use strict";n.d(t,{E:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(59155);const i=(0,n(2668).op)({batchToSpaceND_:function(e,t,n){const i=(0,o._1)(e,"x","batchToSpaceND"),u=t.reduce(((e,t)=>e*t));a.assert(i.rank>=1+t.length,(()=>`input rank is ${i.rank} but should be > than blockShape.length ${t.length}`)),a.assert(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),a.assert(i.shape[0]%u==0,(()=>`input tensor batch is ${i.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${u}`));const l={x:i},c={blockShape:t,crops:n};return r.BV.runKernelFunc((e=>e.batchToSpaceND(i,t,n)),l,null,s.zw,c)}})},7399:(e,t,n)=>{"use strict";n.d(t,{t:()=>d});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(77545),u=n(2668),l=n(4968);function c(e){return null==e?null:0===e.rank?(0,l.X)(e,[e.size]):1===e.rank?e:2===e.rank?(0,l.X)(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?(0,l.X)(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e}const d=(0,u.op)({batchNorm_:function(e,t,n,u,d,h){null==h&&(h=.001);const p=(0,o._1)(e,"x","batchNorm"),f=(0,o._1)(t,"mean","batchNorm"),m=(0,o._1)(n,"variance","batchNorm");let g,x;null!=d&&(g=(0,o._1)(d,"scale","batchNorm")),null!=u&&(x=(0,o._1)(u,"offset","batchNorm")),a.assert(f.rank===m.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),a.assert(null==x||f.rank===x.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),a.assert(null==g||f.rank===g.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const v=(0,i.v)(p),b={x:v,scale:g,offset:x,mean:f,variance:m},y={varianceEpsilon:h},w=r.BV.runKernelFunc(((e,t)=>(t([v,f,m,g]),e.batchNorm(v,c(f),c(m),c(x),c(g),h))),b,null,s.sH,y);return(0,l.X)(w,p.shape)}})},77545:(e,t,n)=>{"use strict";n.d(t,{v:()=>s});var r=n(4968);function s(e){let t;return t=0===e.rank||1===e.rank?(0,r.X)(e,[1,1,1,e.size]):2===e.rank?(0,r.X)(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?(0,r.X)(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}},87536:(e,t,n)=>{"use strict";n.d(t,{zq:()=>g,sz:()=>x,_j:()=>v,Wz:()=>b,Ir:()=>y,NT:()=>w,Lf:()=>k,r7:()=>I,UL:()=>C});var r=n(4368),s=n(43740),o=n(59155),a=n(56407),i=n(41274),u=n(80632),l=n(24513),c=n(85228),d=n(24841),h=n(2668),p=n(33453),f=n(15265),m=n(70827);const g=(0,h.op)({addStrict_:function(e,t){(0,r.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,s._1)(e,"a","addStrict"),i=(0,s._1)(t,"b","addStrict");return o.assertShapesMatch(n.shape,i.shape,"Error in addStrict: "),(0,a.I)(n,i)}}),x=(0,h.op)({divStrict_:function(e,t){(0,r.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,s._1)(e,"a","div"),a=(0,s._1)(t,"b","div");return o.assertShapesMatch(n.shape,a.shape,"Error in divideStrict: "),(0,i.h)(n,a)}}),v=(0,h.op)({maximumStrict_:function(e,t){(0,r.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,s._1)(e,"a","maximumStrict"),a=(0,s._1)(t,"b","maximumStrict");return o.assertShapesMatch(n.shape,a.shape,"Error in maximumStrict: "),(0,u.g)(n,a)}}),b=(0,h.op)({minimumStrict_:function(e,t){(0,r.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,s._1)(e,"a","minimumStrict"),a=(0,s._1)(t,"b","minimumStrict");return o.assertShapesMatch(n.shape,a.shape,"Error in minimumStrict: "),(0,l.L)(n,a)}}),y=(0,h.op)({modStrict_:function(e,t){(0,r.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,s._1)(e,"a","modStrict"),a=(0,s._1)(t,"b","modStrict");return o.assertShapesMatch(n.shape,a.shape,"Error in modStrict: "),(0,c.w)(n,a)}}),w=(0,h.op)({mulStrict_:function(e,t){(0,r.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,s._1)(e,"a","mul"),a=(0,s._1)(t,"b","mul");return o.assertShapesMatch(n.shape,a.shape,"Error in multiplyStrict: "),(0,d.d)(n,a)}}),k=(0,h.op)({powStrict_:function(e,t){return(0,r.MX)("strict variants of ops have been deprecated and will be removed in future"),o.assertShapesMatch(e.shape,t.shape,"Error in powStrict: "),(0,p.s)(e,t)}}),I=(0,h.op)({squaredDifferenceStrict_:function(e,t){(0,r.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,s._1)(e,"a","squaredDifferenceStrict"),a=(0,s._1)(t,"b","squaredDifferenceStrict");return o.assertShapesMatch(n.shape,a.shape,"Error in squaredDifferenceStrict: "),(0,f.$)(n,a)}}),C=(0,h.op)({subStrict_:function(e,t){(0,r.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,s._1)(e,"a","subStrict"),a=(0,s._1)(t,"b","subStrict");return o.assertShapesMatch(n.shape,a.shape,"Error in subStrict: "),(0,m.l)(n,a)}})},68247:(e,t,n)=>{"use strict";n.d(t,{U:()=>l});var r=n(23926),s=n(29121),o=n(43740),a=n(8723),i=n(2668),u=n(4968);const l=(0,i.op)({broadcastTo_:function(e,t){let n=(0,o._1)(e,"broadcastTo","x");const i=n.shape;if(t.some((e=>!(e>0)||e%1!=0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=(0,u.X)(n,e)}const l=n.shape,c=Array.from(t);for(let e=t.length-1;e>=0;e--)if(l[e]===t[e])c[e]=1;else if(1!==n.shape[e])throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${t}].`);if(0===c.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return(0,a.d)(n);const d={x:n},h={shape:t,inputShape:l};return r.BV.runKernelFunc((e=>e.tile(n,c)),d,null,s.Ly,h)}})},72200:(e,t,n)=>{"use strict";function r(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const o=n-1-s,a=e[o]||1;(t[t.length-1-s]||1)>1&&1===a&&r.unshift(o)}return r}function s(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],o=t.length-r-1,a=t[o];(null==s||1===s&&a>1)&&n.unshift(o)}return n}function o(e,t){const n=[],r=Math.max(e.length,t.length);for(let s=0;s<r;s++){let r=e[e.length-s-1];null==r&&(r=1);let o=t[t.length-s-1];if(null==o&&(o=1),1===r)n.unshift(o);else if(1===o)n.unshift(r);else{if(r!==o)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);n.unshift(r)}}return n}n.d(t,{XF:()=>r,RR:()=>s,$N:()=>o})},72657:(e,t,n)=>{"use strict";n.d(t,{f:()=>o});var r=n(73327),s=n(59155);function o(e,t="float32",n){return t=t||"float32",s.assertNonNegativeIntegerDimensions(e),new r.YD(e,t,n)}},62271:(e,t,n)=>{"use strict";n.d(t,{p:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(59155);const i=(0,n(2668).op)({cast_:function(e,t){const n=(0,o._1)(e,"x","cast");if(!a.isValidDtype(t))throw new Error("Failed to cast to unknown dtype "+t);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const i={x:n},u={dtype:t};return r.BV.runKernelFunc((e=>e.cast(n,t)),i,null,s.RF,u)}})},6825:(e,t,n)=>{"use strict";n.d(t,{m:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({ceil_:function(e){const t=(0,o._1)(e,"x","ceil"),n={x:t};return r.BV.runKernelFunc((e=>e.ceil(t)),n,null,s.gJ)}})},42279:(e,t,n)=>{"use strict";n.d(t,{i:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(59155);const i=(0,n(2668).op)({clipByValue_:function(e,t,n){const i=(0,o._1)(e,"x","clipByValue");a.assert(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`));const u={x:i},l={clipValueMin:t,clipValueMax:n};return r.BV.runKernelFunc(((e,r)=>{const s=e.clip(i,t,n);return r([i]),s}),u,null,s.xn,l)}})},8723:(e,t,n)=>{"use strict";n.d(t,{d:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({clone_:function(e){const t=(0,o._1)(e,"x","clone",null),n={x:t};return r.BV.runKernelFunc((()=>r.BV.makeTensorFromDataId(t.dataId,t.shape,t.dtype)),n,null,s.iJ)}})},43334:(e,t,n)=>{"use strict";n.d(t,{zV:()=>p,bZ:()=>f,g1:()=>m,SF:()=>g,O_:()=>x,FG:()=>v});var r=n(4368),s=n(43740),o=n(59155),a=n(26477),i=n(20636),u=n(17630),l=n(86573),c=n(50624),d=n(16500),h=n(2668);const p=(0,h.op)({equalStrict_:function(e,t){(0,r.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,s._1)(e,"a","equalStrict"),i=(0,s._1)(t,"b","equalStrict");return(0,o.assertShapesMatch)(n.shape,i.shape,"Error in equalStrict: "),(0,a.D)(n,i)}}),f=(0,h.op)({greaterEqualStrict_:function(e,t){(0,r.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,s._1)(e,"a","greaterEqualStrict"),a=(0,s._1)(t,"b","greaterEqualStrict");return(0,o.assertShapesMatch)(n.shape,a.shape,"Error in greaterEqualStrict: "),(0,u.b)(n,a)}}),m=(0,h.op)({greaterStrict_:function(e,t){(0,r.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,s._1)(e,"a","greaterStrict"),a=(0,s._1)(t,"b","greaterStrict");return(0,o.assertShapesMatch)(n.shape,a.shape,"Error in greaterStrict: "),(0,i.p)(n,a)}}),g=(0,h.op)({lessEqualStrict_:function(e,t){(0,r.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,s._1)(e,"a","lessEqualStrict"),a=(0,s._1)(t,"b","lessEqualStrict");return(0,o.assertShapesMatch)(n.shape,a.shape,"Error in lessEqualStrict: "),(0,c.z)(n,a)}}),x=(0,h.op)({lessStrict_:function(e,t){(0,r.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,s._1)(e,"a","lessStrict"),a=(0,s._1)(t,"b","lessStrict");return(0,o.assertShapesMatch)(n.shape,a.shape,"Error in lessStrict: "),(0,l.d)(n,a)}}),v=(0,h.op)({notEqualStrict_:function(e,t){(0,r.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,s._1)(e,"a","notEqualStrict"),a=(0,s._1)(t,"b","notEqualStrict");return(0,o.assertShapesMatch)(n.shape,a.shape,"Error in notEqualStrict: "),(0,d.Q)(n,a)}})},61661:(e,t,n)=>{"use strict";n.d(t,{P:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(59155);const i=(0,n(2668).op)({complex_:function(e,t){const n=(0,o._1)(e,"real","complex"),i=(0,o._1)(t,"imag","complex");a.assertShapesMatch(n.shape,i.shape,`real and imag shapes, ${n.shape} and ${i.shape}, must match in call to tf.complex().`);const u={real:n,imag:i};return r.BV.runKernelFunc((e=>e.complex(n,i)),u,null,s.Zz)}})},46884:(e,t,n)=>{"use strict";n.d(t,{z:()=>c});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(30398),u=n(2668),l=n(10701);const c=(0,u.op)({concat_:function(e,t=0){(0,a.assert)(e.length>=1,(()=>"Pass at least one tensor to concat"));let n=(0,o.sI)(e,"tensors","concat");"complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)}));const u=n,c={axis:t};return r.BV.runKernelFunc(((e,r)=>{const s=(0,a.parseAxisParam)(t,n[0].shape)[0],o=(0,i.N)(n.map((e=>e.shape)),s);if(0===(0,a.sizeFromShape)(o))return(0,l.X)([],o);if(n=n.filter((e=>e.size>0)),1===n.length)return n[0];const u=n.map((e=>e.shape));(0,i.o)(u,s);const c=e.concat(n,s);return r(n),c}),u,null,s.Eh,c)}})},30398:(e,t,n)=>{"use strict";n.d(t,{o:()=>s,N:()=>o});var r=n(59155);function s(e,t){const n=e[0].length;e.forEach(((e,t)=>{r.assert(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),r.assert(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const s=e[0];e.forEach(((e,o)=>{for(let a=0;a<n;a++)r.assert(a===t||e[a]===s[a],(()=>`Error in concat${n}D: Shape of tensors[${o}] (${e}) does not match the shape of the rest (${s}) along the non-concatenated axis ${o}.`))}))}function o(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}},11355:(e,t,n)=>{"use strict";n.d(t,{P:()=>l});var r=n(43740),s=n(59155),o=n(64794),a=n(2582),i=n(2668),u=n(4968);const l=(0,i.op)({conv1d_:function(e,t,n,i,l="NWC",c=1,d){const h=(0,r._1)(e,"x","conv1d"),p=(0,r._1)(t,"filter","conv1d");let f=h,m=!1;2===h.rank&&(m=!0,f=(0,u.X)(h,[1,h.shape[0],h.shape[1]])),s.assert(3===f.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${f.rank}.`)),s.assert(3===p.rank,(()=>"Error in conv1d: filter must be rank 3, but got rank "+p.rank+".")),null!=d&&s.assert(s.isInt(i),(()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${d} but got pad ${i}.`)),s.assert(f.shape[2]===p.shape[1],(()=>`Error in conv1d: depth of input (${f.shape[2]}) must match input depth for filter ${p.shape[1]}.`)),s.assert(a.jT(n,c),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${c}'`)),s.assert("NWC"===l,(()=>`Error in conv1d: got dataFormat of ${l} but only NWC is currently supported.`));const g=(0,u.X)(p,[1,p.shape[0],p.shape[1],p.shape[2]]),x=(0,u.X)(f,[f.shape[0],1,f.shape[1],f.shape[2]]),v=[1,n],b=[1,c],y=(0,o.T)(x,g,v,i,"NHWC",b,d);return m?(0,u.X)(y,[y.shape[2],y.shape[3]]):(0,u.X)(y,[y.shape[0],y.shape[2],y.shape[3]])}})},64794:(e,t,n)=>{"use strict";n.d(t,{T:()=>c});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(2582),u=n(2668),l=n(4968);const c=(0,u.op)({conv2d_:function(e,t,n,u,c="NHWC",d=[1,1],h){const p=(0,o._1)(e,"x","conv2d"),f=(0,o._1)(t,"filter","conv2d");let m=p,g=!1;3===p.rank&&(g=!0,m=(0,l.X)(p,[1,p.shape[0],p.shape[1],p.shape[2]])),a.assert(4===m.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${m.rank}.`)),a.assert(4===f.rank,(()=>"Error in conv2d: filter must be rank 4, but got rank "+f.rank+".")),null!=h&&a.assert(a.isInt(u),(()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${h} but got pad ${u}.`));const x="NHWC"===c?m.shape[3]:m.shape[1];a.assert(x===f.shape[2],(()=>`Error in conv2d: depth of input (${x}) must match input depth for filter ${f.shape[2]}.`)),a.assert(i.jT(n,d),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${d}'`));const v={x:m,filter:f},b={strides:n,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h},y=r.BV.runKernelFunc(((e,t)=>{const r=i.sl(c),s=i.Ix(m.shape,f.shape,n,d,u,h,!1,r),o=e.conv2d(m,f,s);return t([m,f]),o}),v,null,s.mh,b);return g?(0,l.X)(y,[y.shape[1],y.shape[2],y.shape[3]]):y}})},36013:(e,t,n)=>{"use strict";n.d(t,{p:()=>l});var r=n(23926),s=n(29121),o=n(59155),a=n(2582),i=n(2668),u=n(4968);const l=(0,i.op)({conv2DBackpropFilter_:function(e,t,n,i,l,c="NHWC",d){let h=e;3===e.rank&&(h=(0,u.X)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let p=t;3===p.rank&&(p=(0,u.X)(t,[1,t.shape[0],t.shape[1],t.shape[2]])),o.assert(4===h.rank,(()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+h.shape+".")),o.assert(4===p.rank,(()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+p.shape+".")),o.assert(4===n.length,(()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+n+"."));const f="NHWC"===c?h.shape[3]:h.shape[1],m="NHWC"===c?p.shape[3]:p.shape[1];o.assert(f===n[2],(()=>`Error in conv2dDerFilter: depth of input ${f}) must match input depth in filter (${n[2]}.`)),o.assert(m===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${m}) must match output depth for filter (${n[3]}).`)),null!=d&&o.assert(o.isInt(l),(()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${d} but got pad ${l}.`));const g={x:h,dy:p},x={strides:i,pad:l,dataFormat:c,dimRoundingMode:d};return r.BV.runKernelFunc((e=>{const t=a.sl(c),r=a.Ix(h.shape,n,i,1,l,d,!1,t);return e.conv2dDerFilter(h,p,r)}),g,null,s.wU,x)}})},39832:(e,t,n)=>{"use strict";n.d(t,{_:()=>l});var r=n(23926),s=n(29121),o=n(59155),a=n(2582),i=n(2668),u=n(4968);const l=(0,i.op)({conv2DBackpropInput_:function(e,t,n,i,l,c="NHWC",d){o.assert(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let h=e,p=t,f=!1;3===t.rank&&(f=!0,p=(0,u.X)(t,[1,t.shape[0],t.shape[1],t.shape[2]]),h=[1,e[0],e[1],e[2]]),o.assert(4===h.length,(()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+h.length+".")),o.assert(4===p.rank,(()=>"Error in conv2dDerInput: dy must be rank 4, but got rank "+p.rank)),o.assert(4===n.rank,(()=>"Error in conv2dDerInput: filter must be rank 4, but got rank "+n.rank));const m="NHWC"===c?h[3]:h[1],g="NHWC"===c?p.shape[3]:p.shape[1];o.assert(m===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${m}) must match input depth for filter ${n.shape[2]}.`)),o.assert(g===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${g}) must match output depth for filter ${n.shape[3]}.`)),null!=d&&o.assert(o.isInt(l),(()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${d} but got pad ${l}.`));const x={dy:p,filter:n},v={strides:i,pad:l,dataFormat:c,dimRoundingMode:d,inputShape:h},b=r.BV.runKernelFunc(((e,t)=>{const r=a.sl(c),s=a.Ix(h,n.shape,i,1,l,d,!1,r),o=e.conv2dDerInput(p,n,s);return t([p,n]),o}),x,null,s.wm,v);return f?(0,u.X)(b,[b.shape[1],b.shape[2],b.shape[3]]):b}})},71405:(e,t,n)=>{"use strict";n.d(t,{b:()=>o});var r=n(43740),s=n(39832);const o=(0,n(2668).op)({conv2dTranspose_:function(e,t,n,o,a,i){const u=(0,r._1)(e,"x","conv2dTranspose"),l=(0,r._1)(t,"filter","conv2dTranspose");return(0,s._)(n,u,l,o,a,"NHWC",i)}})},3365:(e,t,n)=>{"use strict";n.d(t,{s:()=>l});var r=n(23926),s=n(29121),o=n(59155),a=n(2582),i=n(2668),u=n(4968);const l=(0,i.op)({conv3DBackpropFilter_:function(e,t,n,i,l){let c=e;4===e.rank&&(c=(0,u.X)(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let d=t;4===d.rank&&(d=(0,u.X)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),o.assert(5===c.rank,(()=>"Error in conv3dDerFilter: input must be rank 5, but got shape "+c.shape+".")),o.assert(5===d.rank,(()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape "+d.shape+".")),o.assert(5===n.length,(()=>"Error in conv3dDerFilter: filterShape must be length 5, but got "+n+".")),o.assert(c.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${c.shape[4]}) must match input depth in filter (${n[3]}.`)),o.assert(d.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${d.shape[4]}) must match output depth for filter (${n[4]}).`));const h={x:c,y:d},p={strides:i,pad:l};return r.BV.runKernelFunc((e=>{const t=a.jw(c.shape,n,i,1,l);return e.conv3dDerFilter(c,d,t)}),h,null,s.o2,p)}})},97594:(e,t,n)=>{"use strict";n.d(t,{_:()=>l});var r=n(23926),s=n(29121),o=n(59155),a=n(2582),i=n(2668),u=n(4968);const l=(0,i.op)({conv3DBackpropInput_:function(e,t,n,i,l){o.assert(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let c=e,d=t,h=!1;4===t.rank&&(h=!0,d=(0,u.X)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),c=[1,e[0],e[1],e[2],e[3]]);const p=c[4],f=d.shape[4];o.assert(5===c.length,(()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+c.length+".")),o.assert(5===d.rank,(()=>"Error in conv3dDerInput: dy must be rank 5, but got rank "+d.rank)),o.assert(5===n.rank,(()=>"Error in conv3dDerInput: filter must be rank 5, but got rank "+n.rank)),o.assert(p===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${p}) must match input depth for filter ${n.shape[3]}.`)),o.assert(f===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${f}) must match output depth for filter ${n.shape[4]}.`));const m={dy:d},g={pad:l},x=r.BV.runKernelFunc((e=>{const t=a.jw(c,n.shape,i,1,l);return e.conv3dDerInput(d,n,t)}),m,null,s.ik,g);return h?(0,u.X)(x,[x.shape[1],x.shape[2],x.shape[3],x.shape[4]]):x}})},2582:(e,t,n)=>{"use strict";n.d(t,{Rf:()=>s,Xw:()=>o,pl:()=>a,Ix:()=>i,jw:()=>u,aO:()=>l,I0:()=>f,jT:()=>m,sl:()=>g});var r=n(59155);function s(e,t,n,r,s="NHWC",o){return i(e,[...t,e[3]],n,o,r,null,null,g(s))}function o(e,t,n,r,s,o,a="channelsLast"){const[u,l]=c(t);let d;if("channelsLast"===a)d=[u,l,e[3],e[3]];else{if("channelsFirst"!==a)throw new Error("Unknown dataFormat "+a);d=[u,l,e[1],e[1]]}return i(e,d,n,r,s,o,!1,a)}function a(e,t,n,r,s,o,a="NDHWC"){const[i,l,c]=d(t);let h,p;if("NDHWC"===a)p="channelsLast",h=[i,l,c,e[4],e[4]];else{if("NCDHW"!==a)throw new Error("Unknown dataFormat "+a);p="channelsFirst",h=[i,l,c,e[1],e[1]]}return u(e,h,n,r,s,!1,p,o)}function i(e,t,n,s,o,a,i=!1,u="channelsLast"){let[d,f,m,g]=[-1,-1,-1,-1];if("channelsLast"===u)[d,f,m,g]=e;else{if("channelsFirst"!==u)throw new Error("Unknown dataFormat "+u);[d,g,f,m]=e}const[x,v,,b]=t,[y,w]=c(n),[k,I]=c(s),C=h(x,k),$=h(v,I),{padInfo:S,outHeight:R,outWidth:E}=function(e,t,n,s,o,a,i,u,c){let d,h,f;if("number"==typeof e){d={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const o=function(e,t,n,s,o){null==s&&(s=l(e,t,n));const a=e[1],i=p((e[0]-t+2*s)/n+1,o);r.assert(r.isInt(i),(()=>`The output # of rows (${i}) must be an integer. Change the stride and/or zero pad parameters`));const u=p((a-t+2*s)/n+1,o);return r.assert(r.isInt(u),(()=>`The output # of columns (${u}) must be an integer. Change the stride and/or zero pad parameters`)),[i,u]}([t,n],a,s,e,u);h=o[0],f=o[1]}else if("same"===e){h=Math.ceil(t/s),f=Math.ceil(n/o);const e=Math.max(0,(h-1)*s+a-t),r=Math.max(0,(f-1)*o+i-n),u=Math.floor(e/2),l=e-u,c=Math.floor(r/2);d={top:u,bottom:l,left:c,right:r-c,type:"SAME"}}else if("valid"===e)d={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((t-a+1)/s),f=Math.ceil((n-i+1)/o);else{if("object"!=typeof e)throw Error("Unknown padding parameter: "+e);{const r="channelsLast"===c?e[1][0]:e[2][0],l="channelsLast"===c?e[1][1]:e[2][1],m="channelsLast"===c?e[2][0]:e[3][0],g="channelsLast"===c?e[2][1]:e[3][1];d={top:r,bottom:l,left:m,right:g,type:0===r&&0===l&&0===m&&0===g?"VALID":"EXPLICIT"},h=p((t-a+r+l)/s+1,u),f=p((n-i+m+g)/o+1,u)}}return{padInfo:d,outHeight:h,outWidth:f}}(o,f,m,y,w,C,$,a,u),T=i?b*g:b;let A;return"channelsFirst"===u?A=[d,T,R,E]:"channelsLast"===u&&(A=[d,R,E,T]),{batchSize:d,dataFormat:u,inHeight:f,inWidth:m,inChannels:g,outHeight:R,outWidth:E,outChannels:T,padInfo:S,strideHeight:y,strideWidth:w,filterHeight:x,filterWidth:v,effectiveFilterHeight:C,effectiveFilterWidth:$,dilationHeight:k,dilationWidth:I,inShape:e,outShape:A,filterShape:t}}function u(e,t,n,s,o,a=!1,i="channelsLast",u){let[c,f,m,g,x]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[c,f,m,g,x]=e;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat "+i);[c,x,f,m,g]=e}const[v,b,y,,w]=t,[k,I,C]=d(n),[$,S,R]=d(s),E=h(v,$),T=h(b,S),A=h(y,R),{padInfo:_,outDepth:N,outHeight:F,outWidth:D}=function(e,t,n,s,o,a,i,u,c,d,h){let f,m,g,x;if("number"==typeof e){f={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const a=function(e,t,n,s,o,a){null==o&&(o=l(e,t,s));const i=e[1],u=e[2],c=p((e[0]-t+2*o)/s+1,a);r.assert(r.isInt(c),(()=>`The output # of depths (${c}) must be an integer. Change the stride and/or zero pad parameters`));const d=p((i-t+2*o)/s+1,a);r.assert(r.isInt(d),(()=>`The output # of rows (${d}) must be an integer. Change the stride and/or zero pad parameters`));const h=p((u-t+2*o)/s+1,a);return r.assert(r.isInt(h),(()=>`The output # of columns (${h}) must be an integer. Change the stride and/or zero pad parameters`)),[c,d,h,1]}([t,n,s,1],u,0,o,e,h);m=a[0],g=a[1],x=a[2]}else if("same"===e){m=Math.ceil(t/o),g=Math.ceil(n/a),x=Math.ceil(s/i);const e=(m-1)*o+u-t,r=(g-1)*a+c-n,l=(x-1)*i+d-s,h=Math.floor(e/2),p=e-h,v=Math.floor(r/2),b=r-v,y=Math.floor(l/2);f={top:v,bottom:b,left:y,right:l-y,front:h,back:p,type:"SAME"}}else{if("valid"!==e)throw Error("Unknown padding parameter: "+e);f={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},m=Math.ceil((t-u+1)/o),g=Math.ceil((n-c+1)/a),x=Math.ceil((s-d+1)/i)}return{padInfo:f,outDepth:m,outHeight:g,outWidth:x}}(o,f,m,g,k,I,C,E,T,A,u),B=a?w*x:w;let O;return"channelsFirst"===i?O=[c,B,N,F,D]:"channelsLast"===i&&(O=[c,N,F,D,B]),{batchSize:c,dataFormat:i,inDepth:f,inHeight:m,inWidth:g,inChannels:x,outDepth:N,outHeight:F,outWidth:D,outChannels:B,padInfo:_,strideDepth:k,strideHeight:I,strideWidth:C,filterDepth:v,filterHeight:b,filterWidth:y,effectiveFilterDepth:E,effectiveFilterHeight:T,effectiveFilterWidth:A,dilationDepth:$,dilationHeight:S,dilationWidth:R,inShape:e,outShape:O,filterShape:t}}function l(e,t,n,r=1){const s=h(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function c(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function d(e){return"number"==typeof e?[e,e,e]:e}function h(e,t){return t<=1?e:e+(e-1)*(t-1)}function p(e,t){if(!t)return e;switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error("Unknown roundingMode "+t)}}function f(e){const[t,n,r]=c(e);return 1===t&&1===n&&1===r}function m(e,t){return f(e)||f(t)}function g(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error("Unknown dataFormat "+e)}},70173:(e,t,n)=>{"use strict";n.d(t,{m:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({cos_:function(e){const t=(0,o._1)(e,"x","cos"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.cos(t);return n([t]),r}),n,null,s.mc)}})},2699:(e,t,n)=>{"use strict";n.d(t,{f:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({cosh_:function(e){const t=(0,o._1)(e,"x","cosh"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.cosh(t);return n([t]),r}),n,null,s.TR)}})},37405:(e,t,n)=>{"use strict";n.d(t,{z:()=>l});var r=n(23926),s=n(29121),o=n(43740),a=n(83591),i=n(2668),u=n(89065);const l=(0,i.op)({cumsum_:function(e,t=0,n=!1,i=!1){const l=(0,o._1)(e,"x","cumsum"),c={x:l},d={axis:t,exclusive:n,reverse:i};return r.BV.runKernelFunc(((e,r)=>{const s=(0,a.Q3)([t],l.rank);let o=l;null!=s&&(o=(0,u.p)(l,s));const c=(0,a.sY)(1,l.rank)[0];let d=e.cumsum(o,c,n,i);if(r([l]),null!=s){const e=(0,a.LJ)(s);d=(0,u.p)(d,e)}return d}),c,null,s.iH,d)}})},89112:(e,t,n)=>{"use strict";n.d(t,{n:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(59155);const i=(0,n(2668).op)({depthToSpace_:function(e,t,n="NHWC"){const i=(0,o._1)(e,"x","depthToSpace"),u="NHWC"===n?i.shape[1]:i.shape[2],l="NHWC"===n?i.shape[2]:i.shape[3],c="NHWC"===n?i.shape[3]:i.shape[1];a.assert(u*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${u} and ${t}  for depthToSpace with input shape\n    ${i.shape}`)),a.assert(l*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${l} and ${t} for depthToSpace with input shape\n        ${i.shape}`)),a.assert(c%(t*t)==0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${c} for depthToSpace with input shape ${i.shape}`));const d={x:i},h={blockSize:t,dataFormat:n};return r.BV.runKernelFunc((e=>e.depthToSpace(i,t,n)),d,null,s.T0,h)}})},64718:(e,t,n)=>{"use strict";n.d(t,{B:()=>c});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(2582),u=n(2668),l=n(4968);const c=(0,u.op)({depthwiseConv2d_:function(e,t,n,u,c="NHWC",d=[1,1],h){const p=(0,o._1)(e,"x","depthwiseConv2d"),f=(0,o._1)(t,"filter","depthwiseConv2d");let m=p,g=!1;3===p.rank&&(g=!0,m=(0,l.X)(p,[1,p.shape[0],p.shape[1],p.shape[2]])),a.assert(4===m.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${m.rank}.`)),a.assert(4===f.rank,(()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+f.rank+".")),a.assert(m.shape[3]===f.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${m.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`)),null!=h&&a.assert(a.isInt(u),(()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${h} but got pad ${u}.`));const x={x:m,filter:f},v={strides:n,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h},b=r.BV.runKernelFunc(((e,t)=>{null==d&&(d=[1,1]),a.assert(i.jT(n,d),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${d}'`));const r=i.Ix(m.shape,f.shape,n,d,u,h,!0),s=e.depthwiseConv2D(m,f,r);return t([m,f]),s}),x,null,s.ci,v);return g?(0,l.X)(b,[b.shape[1],b.shape[2],b.shape[3]]):b}})},88098:(e,t,n)=>{"use strict";n.d(t,{z:()=>i});var r=n(23926),s=n(29121),o=n(2668),a=n(4968);const i=(0,o.op)({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,o){let i=e;3===e.rank&&(i=(0,a.X)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;3===u.rank&&(u=(0,a.X)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={x:i,dy:u};return r.BV.runKernelFunc((e=>e.depthwiseConv2DDerFilter(i,u,o)),l,null,s.sL)}})},54375:(e,t,n)=>{"use strict";n.d(t,{v:()=>i});var r=n(23926),s=n(29121),o=n(2668),a=n(4968);const i=(0,o.op)({depthwiseConv2dNativeBackpropInput_:function(e,t,n,o){let i=t,u=!1;3===t.rank&&(u=!0,i=(0,a.X)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={dy:i},c=r.BV.runKernelFunc((e=>e.depthwiseConv2DDerInput(i,n,o)),l,null,s.y7);return u?(0,a.X)(c,[c.shape[1],c.shape[2],c.shape[3]]):c}})},70557:(e,t,n)=>{"use strict";n.d(t,{W:()=>l});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(2668),u=n(4968);const l=(0,i.op)({dilation2d_:function(e,t,n,i,l=[1,1],c="NHWC"){const d=(0,o._1)(e,"x","dilation2d"),h=(0,o._1)(t,"filter","dilation2d");a.assert(3===d.rank||4===d.rank,(()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+d.rank+".")),a.assert(3===h.rank,(()=>"Error in dilation2d: filter must be rank 3, but got rank "+h.rank+".")),a.assert("NHWC"===c,(()=>"Error in dilation2d: Only NHWC is currently supported, but got dataFormat of "+c));let p=d,f=!1;3===d.rank&&(p=(0,u.X)(d,[1,d.shape[0],d.shape[1],d.shape[2]]),f=!0);const m={x:p,filter:h},g={strides:n,pad:i,dilations:l},x=r.BV.runKernel(s.p4,m,g);return f?(0,u.X)(x,[x.shape[1],x.shape[2],x.shape[3]]):x}})},41274:(e,t,n)=>{"use strict";n.d(t,{h:()=>u});var r=n(23926),s=n(29121),o=n(80747),a=n(43740),i=n(9165);const u=(0,n(2668).op)({div_:function(e,t){let n=(0,a._1)(e,"a","div"),u=(0,a._1)(t,"b","div");if([n,u]=(0,o.makeTypesMatch)(n,u),"int32"===n.dtype&&"int32"===u.dtype)return(0,i.q)(n,u);const l={a:n,b:u};return r.BV.runKernelFunc(((e,t)=>{const r=e.realDivide(n,u);return t([n,u]),r}),l,null,s.ZC,{})}})},49322:(e,t,n)=>{"use strict";n.d(t,{N:()=>c});var r=n(80747),s=n(43740),o=n(41274),a=n(26477),i=n(2668),u=n(95912),l=n(6577);const c=(0,i.op)({divNoNan_:function(e,t){let n=(0,s._1)(e,"a","div"),i=(0,s._1)(t,"b","div");[n,i]=(0,r.makeTypesMatch)(n,i);const c=(0,o.h)(n,i),d=(0,l.P)(c),h=(0,a.D)(i,d);return(0,u.a)(h,d,c)}})},30548:(e,t,n)=>{"use strict";n.d(t,{A:()=>u});var r=n(43740),s=n(59155),o=n(28687),a=n(2668),i=n(4968);const u=(0,a.op)({dot_:function(e,t){const n=(0,r._1)(e,"t1","dot"),a=(0,r._1)(t,"t2","dot");s.assert(!(1!==n.rank&&2!==n.rank||1!==a.rank&&2!==a.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${a.rank}.`));const u=1===n.rank?n.size:n.shape[1],l=1===a.rank?a.size:a.shape[0];if(s.assert(u===l,(()=>`Error in dot: inner dimensions of inputs must match, but got ${u} and ${l}.`)),1===n.rank&&1===a.rank){const e=(0,i.X)(n,[1,-1]),t=(0,i.X)(a,[-1,1]),r=(0,o.O)(e,t);return(0,i.X)(r,[])}if(1===n.rank&&2===a.rank){const e=(0,i.X)(n,[1,-1]),t=(0,i.X)(a,[a.shape[0],a.shape[1]]),r=(0,o.O)(e,t);return(0,i.X)(r,[r.size])}if(2===n.rank&&1===a.rank){const e=(0,i.X)(a,[-1,1]),t=(0,o.O)(n,e);return(0,i.X)(t,[t.size])}{const e=(0,i.X)(a,[a.shape[0],a.shape[1]]);return(0,o.O)(n,e)}}})},83233:(e,t,n)=>{"use strict";n.d(t,{p:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({elu_:function(e){const t=(0,o._1)(e,"x","elu"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.elu(t);return n([r]),r}),n,null,s.SX)}})},26477:(e,t,n)=>{"use strict";n.d(t,{D:()=>u});var r=n(23926),s=n(29121),o=n(80747),a=n(43740),i=n(72200);const u=(0,n(2668).op)({equal_:function(e,t){let n=(0,a._1)(e,"a","equal"),u=(0,a._1)(t,"b","equal");[n,u]=(0,o.makeTypesMatch)(n,u),(0,i.$N)(n.shape,u.shape);const l={a:n,b:u};return r.BV.runKernelFunc((e=>e.equal(n,u)),l,null,s.hd)}})},34650:(e,t,n)=>{"use strict";n.d(t,{q:()=>u});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(62271);const u=(0,n(2668).op)({erf_:function(e){let t=(0,o._1)(e,"x","erf");a.assert("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=(0,i.p)(t,"float32"));const n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.erf(t);return n([t]),r}),n,null,s.Om)}})},52176:(e,t,n)=>{"use strict";n.d(t,{IA:()=>r,Aj:()=>s,py:()=>o,Kh:()=>a,Qy:()=>i,eh:()=>u});const r=.3275911,s=.254829592,o=-.284496736,a=1.421413741,i=-1.453152027,u=1.061405429},44842:(e,t,n)=>{"use strict";n.d(t,{Q:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({exp_:function(e){const t=(0,o._1)(e,"x","exp"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.exp(t);return n([r]),r}),n,null,s.NE)}})},81300:(e,t,n)=>{"use strict";n.d(t,{d:()=>i});var r=n(43740),s=n(59155),o=n(2668),a=n(4968);const i=(0,o.op)({expandDims_:function(e,t=0){const n=(0,r._1)(e,"x","expandDims",null);s.assert(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const o=n.shape.slice();return t<0&&(s.assert(-(n.rank+1)<=t,(()=>`Axis must be in the interval [${-(n.rank+1)}, ${n.rank}]`)),t=n.rank+t+1),o.splice(t,0,1),(0,a.X)(n,o)}})},53426:(e,t,n)=>{"use strict";n.d(t,{t:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({expm1_:function(e){const t=(0,o._1)(e,"x","expm1"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.expm1(t);return n([t]),r}),n,null,s.Y0)}})},66557:(e,t,n)=>{"use strict";n.d(t,{i:()=>u});var r=n(72657),s=n(81300),o=n(2668),a=n(4968),i=n(47501);const u=(0,o.op)({eye_:function(e,t,n,o="float32"){null==t&&(t=e);const u=(0,r.f)([e,t],o),l=e<=t?e:t;for(let e=0;e<l;++e)u.set(1,e,e);const c=(0,a.X)(u.toTensor(),[e,t]);if(null==n)return c;if(1===n.length)return(0,i.G)((0,s.d)(c,0),[n[0],1,1]);if(2===n.length)return(0,i.G)((0,s.d)((0,s.d)(c,0),0),[n[0],n[1],1,1]);if(3===n.length)return(0,i.G)((0,s.d)((0,s.d)((0,s.d)(c,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}})},14006:(e,t,n)=>{"use strict";n.d(t,{h:()=>o});var r=n(23926),s=n(29121);function o(e,t,n){const o={shape:e,value:t,dtype:n};return r.BV.runKernelFunc((r=>r.fill(e,t,n)),{},null,s.de,o)}},26943:(e,t,n)=>{"use strict";n.d(t,{G:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({floor_:function(e){const t=(0,o._1)(e,"x","floor"),n={x:t};return r.BV.runKernelFunc((e=>e.floor(t)),n,null,s.OR)}})},9165:(e,t,n)=>{"use strict";n.d(t,{q:()=>i});var r=n(23926),s=n(29121),o=n(80747),a=n(43740);const i=(0,n(2668).op)({floorDiv_:function(e,t){let n=(0,a._1)(e,"a","floorDiv"),i=(0,a._1)(t,"b","floorDiv");[n,i]=(0,o.makeTypesMatch)(n,i);const u={a:n,b:i};return r.BV.runKernelFunc(((e,t)=>{const r=e.floorDiv(n,i);return t([n,i]),r}),u,null,s.je)}})},19323:(e,t,n)=>{"use strict";n.d(t,{Fr:()=>h,pf:()=>p,QH:()=>f,uy:()=>m});var r=n(72200),s=n(83233),o=n(24841),a=n(98151),i=n(7409),u=n(83582),l=n(4968),c=n(71901),d=n(15475);function h(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return(0,o.d)(e,(0,c.N)(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function p(e,t){let n=t;const s=r.RR(e.shape,t.shape);return s.length>0&&(n=(0,d.S)(n,s)),(0,l.X)(n,e.shape)}function f(e,t,n){if("linear"===t)return e;if("relu"===t)return(0,i.U)(e);if("elu"===t)return(0,s.p)(e);if("relu6"===t)return(0,u.b)(e);if("prelu"===t)return(0,a.A)(e,n);throw new Error(`Unknown fused activation ${t}.`)}const m=(e,t)=>!(e>0)||"linear"===t},24926:(e,t,n)=>{"use strict";n.d(t,{I:()=>c});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(2668),u=n(4968),l=n(14931);const c=(0,i.op)({gather_:function(e,t,n=0){const i=(0,o._1)(e,"x","gather"),c=(0,o._1)(t,"indices","gather","int32"),d={x:i,indices:c},h={axis:n};return r.BV.runKernelFunc(((e,t)=>{const r=(0,a.parseAxisParam)(n,i.shape)[0],s=(0,l.collectGatherOpShapeInfo)(i,c,r),o=e.gather(i,(0,u.X)(c,[c.size]),r);return t([i,c]),(0,u.X)(o,s.outputShape)}),d,null,s.qi,h)}})},37410:(e,t,n)=>{"use strict";n.d(t,{prepareAndValidate:()=>s});var r=n(59155);function s(e,t){if(e.rank<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[t.rank-1]>e.rank)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[t.rank-1]} vs. ${e.rank}`);if(0===e.size)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const n=t.shape,s=n[n.length-1];let o=1;for(let e=0;e<n.length-1;++e)o*=n[e];const a=e.shape,i=n.slice();i.pop();let u=1;for(let t=s;t<e.rank;++t)u*=a[t],i.push(a[t]);const l=[...(0,r.computeStrides)(e.shape).map((e=>e/u)),1].slice(0,s);return[i,o,u,l]}},20636:(e,t,n)=>{"use strict";n.d(t,{p:()=>u});var r=n(23926),s=n(29121),o=n(80747),a=n(43740),i=n(72200);const u=(0,n(2668).op)({greater_:function(e,t){let n=(0,a._1)(e,"a","greater"),u=(0,a._1)(t,"b","greater");[n,u]=(0,o.makeTypesMatch)(n,u),(0,i.$N)(n.shape,u.shape);const l={a:n,b:u};return r.BV.runKernelFunc((e=>e.greater(n,u)),l,null,s.iZ)}})},17630:(e,t,n)=>{"use strict";n.d(t,{b:()=>u});var r=n(23926),s=n(29121),o=n(80747),a=n(43740),i=n(72200);const u=(0,n(2668).op)({greaterEqual_:function(e,t){let n=(0,a._1)(e,"a","greaterEqual"),u=(0,a._1)(t,"b","greaterEqual");[n,u]=(0,o.makeTypesMatch)(n,u),(0,i.$N)(n.shape,u.shape);const l={a:n,b:u};return r.BV.runKernelFunc(((e,t)=>{const r=e.greaterEqual(n,u);return t([n,u]),r}),l,null,s.Ac)}})},64386:(e,t,n)=>{"use strict";n.d(t,{a:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({imag_:function(e){const t=(0,o._1)(e,"input","imag"),n={input:t};return r.BV.runKernelFunc((e=>e.imag(t)),n,null,s.J_)}})},61066:(e,t,n)=>{"use strict";n.d(t,{B:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(59155);const i=(0,n(2668).op)({cropAndResize_:function(e,t,n,i,u,l){const c=(0,o._1)(e,"image","cropAndResize"),d=(0,o._1)(t,"boxes","cropAndResize","float32"),h=(0,o._1)(n,"boxInd","cropAndResize","int32");u=u||"bilinear",l=l||0;const p=d.shape[0];a.assert(4===c.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${c.rank}.`)),a.assert(2===d.rank&&4===d.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${p},4] but had shape ${d.shape}.`)),a.assert(1===h.rank&&h.shape[0]===p,(()=>`Error in cropAndResize: boxInd must be have size [${p}] but had shape ${d.shape}.`)),a.assert(2===i.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${i.length}.`)),a.assert(i[0]>=1&&i[1]>=1,(()=>"cropSize must be atleast [1,1], but was "+i)),a.assert("bilinear"===u||"nearest"===u,(()=>"method must be bilinear or nearest, but was "+u));const f={image:c,boxes:d,boxInd:h},m={method:u,extrapolationValue:l,cropSize:i};return r.BV.runKernelFunc((e=>e.cropAndResize(c,d,h,i,u,l)),f,null,s.Vc,m)}})},90824:(e,t,n)=>{"use strict";n.d(t,{V:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(59155);const i=(0,n(2668).op)({flipLeftRight_:function(e){const t=(0,o._1)(e,"image","flipLeftRight","float32");a.assert(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return r.BV.runKernel(s.Uy,n,{})}})},99009:(e,t,n)=>{"use strict";n.d(t,{o:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(69869);const i=(0,n(2668).op)({nonMaxSuppression_:function(e,t,n,i=.5,u=Number.NEGATIVE_INFINITY){const l=(0,o._1)(e,"boxes","nonMaxSuppression"),c=(0,o._1)(t,"scores","nonMaxSuppression"),d=(0,a.e)(l,c,n,i,u);n=d.maxOutputSize,i=d.iouThreshold,u=d.scoreThreshold;const h={maxOutputSize:n,iouThreshold:i,scoreThreshold:u};return r.BV.runKernelFunc((e=>e.nonMaxSuppression(l,c,n,i,u)),{boxes:l,scores:c},null,s.uv,h)}})},56526:(e,t,n)=>{"use strict";n.d(t,{V:()=>a});var r=n(12667),s=n(43740),o=n(69869);const a=async function(e,t,n,a=.5,i=Number.NEGATIVE_INFINITY){const u=(0,s._1)(e,"boxes","nonMaxSuppressionAsync"),l=(0,s._1)(t,"scores","nonMaxSuppressionAsync"),c=(0,o.e)(u,l,n,a,i);n=c.maxOutputSize,a=c.iouThreshold,i=c.scoreThreshold;const d=await Promise.all([u.data(),l.data()]),h=d[0],p=d[1],f=(0,r.GP)(h,p,n,a,i);return u!==e&&u.dispose(),l!==t&&l.dispose(),f}},63765:(e,t,n)=>{"use strict";n.d(t,{q:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(69869);const i=(0,n(2668).op)({nonMaxSuppressionPadded_:function(e,t,n,i=.5,u=Number.NEGATIVE_INFINITY,l=!1){const c=(0,o._1)(e,"boxes","nonMaxSuppression"),d=(0,o._1)(t,"scores","nonMaxSuppression"),h=(0,a.e)(c,d,n,i,u,null),p={boxes:c,scores:d},f={maxOutputSize:h.maxOutputSize,iouThreshold:h.iouThreshold,scoreThreshold:h.scoreThreshold,padToMaxOutputSize:l},m=r.BV.runKernel(s.cy,p,f);return{selectedIndices:m[0],validOutputs:m[1]}}})},88500:(e,t,n)=>{"use strict";n.d(t,{N:()=>a});var r=n(12667),s=n(43740),o=n(69869);const a=async function(e,t,n,a=.5,i=Number.NEGATIVE_INFINITY,u=!1){const l=(0,s._1)(e,"boxes","nonMaxSuppressionAsync"),c=(0,s._1)(t,"scores","nonMaxSuppressionAsync"),d=(0,o.e)(l,c,n,a,i,null),h=d.maxOutputSize,p=d.iouThreshold,f=d.scoreThreshold,[m,g]=await Promise.all([l.data(),c.data()]),x=(0,r.qP)(m,g,h,p,f,u);return l!==e&&l.dispose(),c!==t&&c.dispose(),x}},91424:(e,t,n)=>{"use strict";n.d(t,{t:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(69869);const i=(0,n(2668).op)({nonMaxSuppressionWithScore_:function(e,t,n,i=.5,u=Number.NEGATIVE_INFINITY,l=0){const c=(0,o._1)(e,"boxes","nonMaxSuppression"),d=(0,o._1)(t,"scores","nonMaxSuppression"),h=(0,a.e)(c,d,n,i,u,l),p={boxes:c,scores:d},f={maxOutputSize:n=h.maxOutputSize,iouThreshold:i=h.iouThreshold,scoreThreshold:u=h.scoreThreshold,softNmsSigma:l=h.softNmsSigma},m=r.BV.runKernel(s.W0,p,f);return{selectedIndices:m[0],selectedScores:m[1]}}})},18135:(e,t,n)=>{"use strict";n.d(t,{B:()=>a});var r=n(12667),s=n(43740),o=n(69869);const a=async function(e,t,n,a=.5,i=Number.NEGATIVE_INFINITY,u=0){const l=(0,s._1)(e,"boxes","nonMaxSuppressionAsync"),c=(0,s._1)(t,"scores","nonMaxSuppressionAsync"),d=(0,o.e)(l,c,n,a,i,u);n=d.maxOutputSize,a=d.iouThreshold,i=d.scoreThreshold,u=d.softNmsSigma;const h=await Promise.all([l.data(),c.data()]),p=h[0],f=h[1],m=(0,r.pA)(p,f,n,a,i,u);return l!==e&&l.dispose(),c!==t&&c.dispose(),m}},13305:(e,t,n)=>{"use strict";n.d(t,{I:()=>l});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(2668),u=n(4968);const l=(0,i.op)({resizeBilinear_:function(e,t,n=!1){const i=(0,o._1)(e,"images","resizeBilinear");a.assert(3===i.rank||4===i.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`)),a.assert(2===t.length,(()=>"Error in resizeBilinear: new shape must 2D, but got shape "+t+"."));let l=i,c=!1;3===i.rank&&(c=!0,l=(0,u.X)(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const[d,h]=t,p={images:l},f={alignCorners:n,size:t},m=r.BV.runKernelFunc(((e,t)=>(t([l]),e.resizeBilinear(l,d,h,n))),p,null,s._Y,f);return c?(0,u.X)(m,[m.shape[1],m.shape[2],m.shape[3]]):m}})},95098:(e,t,n)=>{"use strict";n.d(t,{j:()=>l});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(2668),u=n(4968);const l=(0,i.op)({resizeNearestNeighbor_:function(e,t,n=!1){const i=(0,o._1)(e,"images","resizeNearestNeighbor");a.assert(3===i.rank||4===i.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`)),a.assert(2===t.length,(()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+t+".")),a.assert("float32"===i.dtype||"int32"===i.dtype,(()=>"`images` must have `int32` or `float32` as dtype"));let l=i,c=!1;3===i.rank&&(c=!0,l=(0,u.X)(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const[d,h]=t,p={images:l},f={alignCorners:n,size:t},m=r.BV.runKernelFunc(((e,t)=>(t([l]),e.resizeNearestNeighbor(l,d,h,n))),p,null,s.dp,f);return c?(0,u.X)(m,[m.shape[1],m.shape[2],m.shape[3]]):m}})},26466:(e,t,n)=>{"use strict";n.d(t,{f:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(59155);const i=(0,n(2668).op)({rotateWithOffset_:function(e,t,n=0,i=.5){const u=(0,o._1)(e,"image","rotateWithOffset","float32");a.assert(4===u.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${u.rank}.`));const l={image:u},c={radians:t,fillValue:n,center:i};return r.BV.runKernel(s.b9,l,c)}})},13963:(e,t,n)=>{"use strict";n.d(t,{x:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({isFinite_:function(e){const t=(0,o._1)(e,"x","isFinite"),n={x:t};return r.BV.runKernelFunc((e=>e.isFinite(t)),n,null,s.av)}})},4365:(e,t,n)=>{"use strict";n.d(t,{U:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({isInf_:function(e){const t=(0,o._1)(e,"x","isInf"),n={x:t};return r.BV.runKernelFunc((e=>e.isInf(t)),n,null,s.iW)}})},96230:(e,t,n)=>{"use strict";n.d(t,{i:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({isNaN_:function(e){const t=(0,o._1)(e,"x","isNaN"),n={x:t};return r.BV.runKernelFunc((e=>e.isNaN(t)),n,null,s.r7)}})},99133:(e,t,n)=>{"use strict";n.d(t,{h:()=>u});var r=n(43740),s=n(80632),o=n(24841),a=n(2668),i=n(99494);const u=(0,a.op)({leakyRelu_:function(e,t=.2){const n=(0,r._1)(e,"x","leakyRelu");return(0,s.g)((0,o.d)((0,i.i)(t),n),n)}})},86573:(e,t,n)=>{"use strict";n.d(t,{d:()=>u});var r=n(23926),s=n(29121),o=n(80747),a=n(43740),i=n(72200);const u=(0,n(2668).op)({less_:function(e,t){let n=(0,a._1)(e,"a","less"),u=(0,a._1)(t,"b","less");[n,u]=(0,o.makeTypesMatch)(n,u),(0,i.$N)(n.shape,u.shape);const l={a:n,b:u};return r.BV.runKernelFunc((e=>e.less(n,u)),l,null,s.vt)}})},50624:(e,t,n)=>{"use strict";n.d(t,{z:()=>u});var r=n(23926),s=n(29121),o=n(80747),a=n(43740),i=n(72200);const u=(0,n(2668).op)({lessEqual_:function(e,t){let n=(0,a._1)(e,"a","lessEqual"),u=(0,a._1)(t,"b","lessEqual");[n,u]=(0,o.makeTypesMatch)(n,u),(0,i.$N)(n.shape,u.shape);const l={a:n,b:u};return r.BV.runKernelFunc(((e,t)=>{const r=e.lessEqual(n,u);return t([n,u]),r}),l,null,s.CA)}})},601:(e,t,n)=>{"use strict";n.d(t,{P:()=>x});var r=n(43740),s=n(59155),o=n(17630),a=n(50624),i=n(2856),u=n(2668),l=n(47245),c=n(4968),d=n(99494),h=n(82991),p=n(70827),f=n(24136),m=n(95912),g=n(59640);const x=(0,u.op)({bandPart_:function(e,t,n){(0,s.assert)(t%1==0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),(0,s.assert)(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`));const u=(0,r._1)(e,"a","bandPart");(0,s.assert)(u.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${u.rank}.`));const x=u.shape,[v,b]=u.shape.slice(-2);if(!(t<=v))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${v}).`);if(!(n<=b))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${b}).`);t<0&&(t=v),n<0&&(n=b);const y=(0,c.X)((0,l.w)(0,v,1,"int32"),[-1,1]),w=(0,l.w)(0,b,1,"int32"),k=(0,p.l)(y,w),I=(0,i.H)((0,a.z)(k,(0,d.i)(+t,"int32")),(0,o.b)(k,(0,d.i)(-n,"int32"))),C=(0,g.l)([v,b],u.dtype);return(0,c.X)((0,h.k)((0,f.H)((0,c.X)(u,[-1,v,b])).map((e=>(0,m.a)(I,e,C)))),x)}})},25453:(e,t,n)=>{"use strict";n.d(t,{G:()=>f});var r=n(23926),s=n(59155),o=n(41274),a=n(24841),i=n(3561),u=n(2668),l=n(28644),c=n(79590),d=n(82991),h=n(70827),p=n(15475);const f=(0,u.op)({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,(0,s.assert)(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)(0,s.assert)(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=(0,l.V)(e,e.shape[0],0).map((e=>(0,c.L)(e,[0])));(0,s.assert)(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],u=e;for(let t=0;t<e.length;++t)n.push(r.BV.tidy((()=>{let e=u[t];if(t>0)for(let r=0;r<t;++r){const t=(0,a.d)((0,p.S)((0,a.d)(n[r],e)),n[r]);e=(0,h.l)(e,t)}return(0,o.h)(e,(0,i.K)(e,"euclidean"))})));return t?(0,d.k)(n,0):n}})},32512:(e,t,n)=>{"use strict";n.d(t,{qr:()=>$});var r=n(23926),s=n(4368),o=n(59155),a=n(8723),i=n(46884),u=n(41274),l=n(66557),c=n(20636),d=n(28687),h=n(24841),p=n(17370),f=n(3561),m=n(2668),g=n(4968),x=n(22676),v=n(82991),b=n(70827),y=n(24376),w=n(89065),k=n(24136),I=n(95912);function C(e,t=!1){return r.BV.tidy((()=>{(0,o.assert)(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],m=e.shape[1];let g=(0,l.i)(n),v=(0,a.d)(e);const k=(0,y.o)([[1]],[1,1]);let C=(0,a.d)(k);const $=n>=m?m:n;for(let e=0;e<$;++e){const t=v,o=C,l=g;[C,v,g]=r.BV.tidy((()=>{const t=(0,x.t)(v,[e,e],[n-e,1]),r=(0,f.K)(t),s=(0,x.t)(v,[e,e],[1,1]),o=(0,I.a)((0,c.p)(s,0),(0,y.o)([[-1]]),(0,y.o)([[1]])),l=(0,b.l)(s,(0,h.d)(o,r)),$=(0,u.h)(t,l);C=1===$.shape[0]?(0,a.d)(k):(0,i.z)([k,(0,x.t)($,[1,0],[$.shape[0]-1,$.shape[1]])],0);const S=(0,p.W)((0,u.h)((0,d.O)(o,l),r)),R=(0,x.t)(v,[e,0],[n-e,m]),E=(0,h.d)(S,C),T=(0,w.p)(C);if(0===e)v=(0,b.l)(R,(0,d.O)(E,(0,d.O)(T,R)));else{const t=(0,b.l)(R,(0,d.O)(E,(0,d.O)(T,R)));v=(0,i.z)([(0,x.t)(v,[0,0],[e,m]),t],0)}const A=(0,w.p)(E),_=(0,x.t)(g,[0,e],[n,g.shape[1]-e]);if(0===e)g=(0,b.l)(_,(0,d.O)((0,d.O)(_,C),A));else{const t=(0,b.l)(_,(0,d.O)((0,d.O)(_,C),A));g=(0,i.z)([(0,x.t)(g,[0,0],[n,e]),t],1)}return[C,v,g]})),(0,s.B9)([t,o,l])}return!t&&n>m&&(g=(0,x.t)(g,[0,0],[n,m]),v=(0,x.t)(v,[0,0],[m,m])),[g,v]}))}const $=(0,m.op)({qr_:function(e,t=!1){if((0,o.assert)(e.rank>=2,(()=>"qr() requires input tensor to have a rank >= 2, but got rank "+e.rank)),2===e.rank)return C(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=(0,k.H)((0,g.X)(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],o=[];return r.forEach((e=>{const[n,r]=C(e,t);s.push(n),o.push(r)})),[(0,g.X)((0,v.k)(s,0),e.shape),(0,g.X)((0,v.k)(o,0),e.shape)]}}})},79648:(e,t,n)=>{"use strict";n.d(t,{G:()=>l});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(2668),u=n(4968);const l=(0,i.op)({localResponseNormalization_:function(e,t=5,n=1,i=1,l=.5){const c=(0,o._1)(e,"x","localResponseNormalization");a.assert(4===c.rank||3===c.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${c.rank}.`)),a.assert(a.isInt(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let d=c,h=!1;3===c.rank&&(h=!0,d=(0,u.X)(c,[1,c.shape[0],c.shape[1],c.shape[2]]));const p={x:d},f={depthRadius:t,bias:n,alpha:i,beta:l},m=r.BV.runKernelFunc(((e,r)=>{const s=e.localResponseNormalization4D(d,t,n,i,l);return r([d,s]),s}),p,null,s.eZ,f);return h?(0,u.X)(m,[m.shape[1],m.shape[2],m.shape[3]]):m}})},69369:(e,t,n)=>{"use strict";n.d(t,{Y:()=>o});var r=n(23926),s=n(29121);const o=(0,n(2668).op)({localResponseNormalizationBackprop_:function(e,t,n,o=5,a=1,i=1,u=.5){const l={x:e,y:t,dy:n},c={depthRadius:o,bias:a,alpha:i,beta:u};return r.BV.runKernelFunc((r=>r.LRNGrad(n,e,t,o,a,i,u)),l,null,s.vI,c)}})},82597:(e,t,n)=>{"use strict";n.d(t,{c:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({log_:function(e){const t=(0,o._1)(e,"x","log"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.log(t);return n([t]),r}),n,null,s.Zb)}})},17474:(e,t,n)=>{"use strict";n.d(t,{K:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({log1p_:function(e){const t=(0,o._1)(e,"x","log1p"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.log1p(t);return n([t]),r}),n,null,s.kU)}})},13888:(e,t,n)=>{"use strict";n.d(t,{e:()=>c});var r=n(30633),s=n(43740),o=n(24841),a=n(17370),i=n(2668),u=n(30625),l=n(3694);const c=(0,i.op)({logSigmoid_:function(e){const t=(0,s._1)(e,"x","logSigmoid");return(0,r.cb)((e=>({value:(0,a.W)((0,l.W)((0,a.W)(e))),gradFunc:t=>(0,o.d)(t,(0,u.X)((0,a.W)(e)))})))(t)}})},31510:(e,t,n)=>{"use strict";n.d(t,{C:()=>p});var r=n(23926),s=n(29121),o=n(43740),a=n(62271),i=n(44842),u=n(82597),l=n(83307),c=n(2668),d=n(70827),h=n(15475);const p=(0,c.op)({logSoftmax_:function(e,t=-1){const n=(0,o._1)(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);const c={logits:n},p={axis:t};return r.BV.runKernelFunc(((n,r)=>{const s=(0,l.F)(e,t,!0),o=(0,d.l)(e,s),c=(0,d.l)((0,a.p)(o,"float32"),(0,u.c)((0,h.S)((0,i.Q)(o),t,!0)));return r([c]),c}),c,null,s.qC,p)}})},11391:(e,t,n)=>{"use strict";n.d(t,{l:()=>f});var r=n(43740),s=n(59155),o=n(56407),a=n(83591),i=n(44842),u=n(82597),l=n(83307),c=n(2668),d=n(4968),h=n(70827),p=n(15475);const f=(0,c.op)({logSumExp_:function(e,t=null,n=!1){const c=(0,r._1)(e,"x","logSumExp"),f=(0,s.parseAxisParam)(t,c.shape),m=(0,l.F)(c,f,!0),g=(0,h.l)(c,m),x=(0,i.Q)(g),v=(0,p.S)(x,f),b=(0,u.c)(v),y=(0,o.I)((0,d.X)(m,b.shape),b);if(n){const e=(0,a.rv)(y.shape,f);return(0,d.X)(y,e)}return y}})},2856:(e,t,n)=>{"use strict";n.d(t,{H:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(72200);const i=(0,n(2668).op)({logicalAnd_:function(e,t){const n=(0,o._1)(e,"a","logicalAnd","bool"),i=(0,o._1)(t,"b","logicalAnd","bool");(0,a.$N)(n.shape,i.shape);const u={a:n,b:i};return r.BV.runKernelFunc((e=>e.logicalAnd(n,i)),u,null,s.PY)}})},38651:(e,t,n)=>{"use strict";n.d(t,{h:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({logicalNot_:function(e){const t=(0,o._1)(e,"x","logicalNot","bool"),n={x:t};return r.BV.runKernelFunc((e=>e.logicalNot(t)),n,null,s.Vf)}})},15750:(e,t,n)=>{"use strict";n.d(t,{K:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(72200);const i=(0,n(2668).op)({logicalOr_:function(e,t){const n=(0,o._1)(e,"a","logicalOr","bool"),i=(0,o._1)(t,"b","logicalOr","bool");(0,a.$N)(n.shape,i.shape);const u={a:n,b:i};return r.BV.runKernelFunc((e=>e.logicalOr(n,i)),u,null,s.MZ)}})},10596:(e,t,n)=>{"use strict";n.d(t,{e:()=>u});var r=n(43740),s=n(72200),o=n(2856),a=n(38651),i=n(15750);const u=(0,n(2668).op)({logicalXor_:function(e,t){const n=(0,r._1)(e,"a","logicalXor","bool"),u=(0,r._1)(t,"b","logicalXor","bool");return(0,s.$N)(n.shape,u.shape),(0,o.H)((0,i.K)(e,t),(0,a.h)((0,o.H)(e,t)))}})},49876:(e,t,n)=>{"use strict";var r;n.d(t,{I:()=>r}),function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(r||(r={}))},41326:(e,t,n)=>{"use strict";n.d(t,{O:()=>c});var r=n(43740),s=n(59155),o=n(96235),a=n(49876),i=n(2668),u=n(70827),l=n(36142);const c=(0,i.op)({absoluteDifference_:function(e,t,n,i=a.I.SUM_BY_NONZERO_WEIGHTS){const c=(0,r._1)(e,"labels","absoluteDifference"),d=(0,r._1)(t,"predictions","absoluteDifference");let h=null;null!=n&&(h=(0,r._1)(n,"weights","absoluteDifference")),(0,s.assertShapesMatch)(c.shape,d.shape,"Error in absoluteDifference: ");const p=(0,o.W)((0,u.l)(c,d));return(0,l.m)(p,h,i)}})},36142:(e,t,n)=>{"use strict";n.d(t,{m:()=>f});var r=n(43740),s=n(62271),o=n(41274),a=n(49876),i=n(75130),u=n(24841),l=n(16500),c=n(44917),d=n(2668),h=n(99494),p=n(15475);const f=(0,d.op)({computeWeightedLoss_:function(e,t,n=a.I.SUM_BY_NONZERO_WEIGHTS){const d=(0,r._1)(e,"losses","computeWeightedLoss");let f=null;null!=t&&(f=(0,r._1)(t,"weights","computeWeightedLoss"));const m=null==f?d:(0,u.d)(d,f);if(n===a.I.NONE)return m;if(n===a.I.SUM)return(0,p.S)(m);if(n===a.I.MEAN){if(null==f)return(0,i.J)(m);{const e=d.size/f.size,t=(0,o.h)((0,p.S)(m),(0,p.S)(f));return e>1?(0,o.h)(t,(0,h.i)(e)):t}}if(n===a.I.SUM_BY_NONZERO_WEIGHTS){if(null==f)return(0,o.h)((0,p.S)(m),(0,h.i)(d.size));{const e=(0,u.d)(f,(0,c.i)(d.shape)),t=(0,s.p)((0,p.S)((0,l.Q)(e,(0,h.i)(0))),"float32");return(0,o.h)((0,p.S)(m),t)}}throw Error("Unknown reduction: "+n)}})},77789:(e,t,n)=>{"use strict";n.d(t,{Z:()=>h});var r=n(43740),s=n(59155),o=n(49876),a=n(24841),i=n(2668),u=n(99494),l=n(70827),c=n(15475),d=n(36142);const h=(0,i.op)({cosineDistance_:function(e,t,n,i,h=o.I.SUM_BY_NONZERO_WEIGHTS){const p=(0,r._1)(e,"labels","cosineDistance"),f=(0,r._1)(t,"predictions","cosineDistance");let m=null;null!=i&&(m=(0,r._1)(i,"weights","cosineDistance")),(0,s.assertShapesMatch)(p.shape,f.shape,"Error in cosineDistance: ");const g=(0,u.i)(1),x=(0,l.l)(g,(0,c.S)((0,a.d)(p,f),n,!0));return(0,d.m)(x,m,h)}})},29599:(e,t,n)=>{"use strict";n.d(t,{O:()=>h});var r=n(43740),s=n(59155),o=n(49876),a=n(24841),i=n(2668),u=n(7409),l=n(99494),c=n(70827),d=n(36142);const h=(0,i.op)({hingeLoss_:function(e,t,n,i=o.I.SUM_BY_NONZERO_WEIGHTS){let h=(0,r._1)(e,"labels","hingeLoss");const p=(0,r._1)(t,"predictions","hingeLoss");let f=null;null!=n&&(f=(0,r._1)(n,"weights","hingeLoss")),(0,s.assertShapesMatch)(h.shape,p.shape,"Error in hingeLoss: ");const m=(0,l.i)(1);h=(0,c.l)((0,a.d)((0,l.i)(2),h),m);const g=(0,u.U)((0,c.l)(m,(0,a.d)(h,p)));return(0,d.m)(g,f,i)}})},95317:(e,t,n)=>{"use strict";n.d(t,{H:()=>m});var r=n(43740),s=n(59155),o=n(96235),a=n(56407),i=n(49876),u=n(24513),l=n(24841),c=n(2668),d=n(99494),h=n(50248),p=n(70827),f=n(36142);const m=(0,c.op)({huberLoss_:function(e,t,n,c=1,m=i.I.SUM_BY_NONZERO_WEIGHTS){const g=(0,r._1)(e,"labels","huberLoss"),x=(0,r._1)(t,"predictions","huberLoss");let v=null;null!=n&&(v=(0,r._1)(n,"weights","huberLoss")),(0,s.assertShapesMatch)(g.shape,x.shape,"Error in huberLoss: ");const b=(0,d.i)(c),y=(0,o.W)((0,p.l)(x,g)),w=(0,u.L)(y,b),k=(0,p.l)(y,w),I=(0,a.I)((0,l.d)((0,d.i)(.5),(0,h.h)(w)),(0,l.d)(b,k));return(0,f.m)(I,v,m)}})},4824:(e,t,n)=>{"use strict";n.d(t,{g:()=>f});var r=n(43740),s=n(59155),o=n(56407),a=n(82597),i=n(49876),u=n(24841),l=n(17370),c=n(2668),d=n(99494),h=n(70827),p=n(36142);const f=(0,c.op)({logLoss_:function(e,t,n,c=1e-7,f=i.I.SUM_BY_NONZERO_WEIGHTS){const m=(0,r._1)(e,"labels","logLoss"),g=(0,r._1)(t,"predictions","logLoss");let x=null;null!=n&&(x=(0,r._1)(n,"weights","logLoss")),(0,s.assertShapesMatch)(m.shape,g.shape,"Error in logLoss: ");const v=(0,d.i)(1),b=(0,d.i)(c),y=(0,l.W)((0,u.d)(m,(0,a.c)((0,o.I)(g,b)))),w=(0,u.d)((0,h.l)(v,m),(0,a.c)((0,o.I)((0,h.l)(v,g),b))),k=(0,h.l)(y,w);return(0,p.m)(k,x,f)}})},42695:(e,t,n)=>{"use strict";n.d(t,{F:()=>l});var r=n(43740),s=n(59155),o=n(49876),a=n(2668),i=n(15265),u=n(36142);const l=(0,a.op)({meanSquaredError_:function(e,t,n,a=o.I.SUM_BY_NONZERO_WEIGHTS){const l=(0,r._1)(e,"labels","meanSquaredError"),c=(0,r._1)(t,"predictions","meanSquaredError");let d=null;null!=n&&(d=(0,r._1)(n,"weights","meanSquaredError")),(0,s.assertShapesMatch)(l.shape,c.shape,"Error in meanSquaredError: ");const h=(0,i.$)(l,c);return(0,u.m)(h,d,a)}})},75706:(e,t,n)=>{"use strict";n.d(t,{f:()=>x});var r=n(43740),s=n(59155),o=n(96235),a=n(56407),i=n(44842),u=n(17474),l=n(49876),c=n(24841),d=n(17370),h=n(2668),p=n(7409),f=n(99494),m=n(70827),g=n(36142);const x=(0,h.op)({sigmoidCrossEntropy_:function(e,t,n,h=0,x=l.I.SUM_BY_NONZERO_WEIGHTS){let v=(0,r._1)(e,"multiClassLabels","sigmoidCrossEntropy");const b=(0,r._1)(t,"logits","sigmoidCrossEntropy");let y=null;if(null!=n&&(y=(0,r._1)(n,"weights","sigmoidCrossEntropy")),(0,s.assertShapesMatch)(v.shape,b.shape,"Error in sigmoidCrossEntropy: "),h>0){const e=(0,f.i)(h),t=(0,f.i)(1),n=(0,f.i)(.5);v=(0,a.I)((0,c.d)(v,(0,m.l)(t,e)),(0,c.d)(n,e))}const w=function(e,t){const n=(0,r._1)(e,"labels","sigmoidCrossEntropyWithLogits"),l=(0,r._1)(t,"logits","sigmoidCrossEntropyWithLogits");(0,s.assertShapesMatch)(n.shape,l.shape,"Error in sigmoidCrossEntropyWithLogits: ");const h=(0,p.U)(l),f=(0,c.d)(l,n),g=(0,u.K)((0,i.Q)((0,d.W)((0,o.W)(l))));return(0,a.I)((0,m.l)(h,f),g)}(v,b);return(0,g.m)(w,y,x)}})},67740:(e,t,n)=>{"use strict";n.d(t,{E:()=>w});var r=n(30633),s=n(43740),o=n(59155),a=n(56407),i=n(83591),u=n(62271),l=n(41274),c=n(44842),d=n(11391),h=n(49876),p=n(24841),f=n(17370),m=n(2668),g=n(4968),x=n(99494),v=n(70827),b=n(15475),y=n(36142);const w=(0,m.op)({softmaxCrossEntropy_:function(e,t,n,m=0,w=h.I.SUM_BY_NONZERO_WEIGHTS){let k=(0,s._1)(e,"onehotLabels","softmaxCrossEntropy");const I=(0,s._1)(t,"logits","softmaxCrossEntropy");let C=null;if(null!=n&&(C=(0,s._1)(n,"weights","softmaxCrossEntropy")),(0,o.assertShapesMatch)(k.shape,I.shape,"Error in softmaxCrossEntropy: "),m>0){const e=(0,x.i)(m),t=(0,x.i)(1),n=(0,x.i)(k.shape[1]);k=(0,a.I)((0,p.d)(k,(0,v.l)(t,e)),(0,l.h)(e,n))}const $=function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was `+n);return(0,r.cb)(((e,t,r)=>{const s=(0,d.l)(t,[n],!0),o=(0,v.l)((0,u.p)(t,"float32"),s);r([e,o]);const a=(0,f.W)((0,p.d)(o,e));return{value:(0,b.S)(a,[n]),gradFunc:(e,t)=>{const[r,s]=t,o=(0,i.rv)(e.shape,[n]);return[(0,p.d)((0,g.X)(e,o),(0,v.l)((0,u.p)(r,"float32"),(0,c.Q)(s))),(0,p.d)((0,g.X)(e,o),(0,v.l)((0,c.Q)(s),(0,u.p)(r,"float32")))]}}}))(e,t)}(k,I);return(0,y.m)($,C,w)}})},28687:(e,t,n)=>{"use strict";n.d(t,{O:()=>c});var r=n(23926),s=n(29121),o=n(80747),a=n(43740),i=n(59155),u=n(2668),l=n(4968);const c=(0,u.op)({matMul_:function(e,t,n=!1,u=!1){let c=(0,a._1)(e,"a","matMul"),d=(0,a._1)(t,"b","matMul");[c,d]=(0,o.makeTypesMatch)(c,d),i.assert(c.rank>=2&&d.rank>=2&&c.rank===d.rank,(()=>`Error in matMul: inputs must have the same rank of at least 2, got ranks ${c.rank} and ${d.rank}.`));const h=n?c.shape[c.rank-2]:c.shape[c.rank-1],p=u?d.shape[d.rank-1]:d.shape[d.rank-2],f=n?c.shape[c.rank-1]:c.shape[c.rank-2],m=u?d.shape[d.rank-2]:d.shape[d.rank-1],g=c.shape.slice(0,-2),x=d.shape.slice(0,-2),v=i.sizeFromShape(g),b=i.sizeFromShape(x);i.assert(i.arraysEqual(g,x),(()=>`Error in matMul: outer dimensions (${g}) and (${x}) of Tensors with shapes ${c.shape} and `+d.shape+" must match.")),i.assert(h===p,(()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${c.shape} and ${d.shape} and transposeA=${n} and transposeB=${u} must match.`));const y=c.shape.slice(0,-2).concat([f,m]),w=n?(0,l.X)(c,[v,h,f]):(0,l.X)(c,[v,f,h]),k=u?(0,l.X)(d,[b,m,p]):(0,l.X)(d,[b,p,m]),I={a:w,b:k},C={transposeA:n,transposeB:u},$=r.BV.runKernelFunc(((e,t)=>(t([w,k]),e.batchMatMul(w,k,n,u))),I,null,s.XL,C);return(0,l.X)($,y)}})},83307:(e,t,n)=>{"use strict";n.d(t,{F:()=>d});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(83591),u=n(2668),l=n(4968),c=n(89065);const d=(0,u.op)({max_:function(e,t=null,n=!1){const u=(0,o._1)(e,"x","max"),d={x:u},h={reductionIndices:t,keepDims:n};return r.BV.runKernelFunc(((e,r)=>{let s=a.parseAxisParam(t,u.shape);const o=i.Q3(s,u.rank);let d=u;null!=o&&(d=(0,c.p)(u,o),s=i.sY(s.length,d.rank));const h=e.max(d,s);null!=o&&d.dispose();let p=h;if(n){const e=i.rv(p.shape,a.parseAxisParam(t,u.shape));p=(0,l.X)(p,e),h.dispose()}return r([u,p]),p}),d,null,s.Yo,h)}})},21174:(e,t,n)=>{"use strict";n.d(t,{_:()=>c});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(2582),u=n(2668),l=n(4968);const c=(0,u.op)({maxPool_:function(e,t,n,u,c){const d=(0,o._1)(e,"x","maxPool");let h=d,p=!1;3===d.rank&&(p=!0,h=(0,l.X)(d,[1,d.shape[0],d.shape[1],d.shape[2]])),a.assert(4===h.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${h.rank}.`)),a.assert(i.jT(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),null!=c&&a.assert(a.isInt(u),(()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${c} but got pad ${u}.`));const f={x:h},m={filterSize:t,strides:n,pad:u,dimRoundingMode:c},g=r.BV.runKernelFunc(((e,r)=>{const s=i.Xw(h.shape,t,n,1,u,c);let o;return o=1===s.filterWidth&&1===s.filterHeight&&a.arraysEqual(s.inShape,s.outShape)?h.clone():e.maxPool(h,s),r([h,o]),o}),f,null,s.mT,m);return p?(0,l.X)(g,[g.shape[1],g.shape[2],g.shape[3]]):g}})},75257:(e,t,n)=>{"use strict";n.d(t,{O:()=>c});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(2582),u=n(2668),l=n(4968);const c=(0,u.op)({maxPool3dBackprop_:function(e,t,n,u,c,d=[1,1,1],h,p){const f=(0,o._1)(e,"dy","maxPool3dBackprop"),m=(0,o._1)(t,"input","maxPool3dBackprop"),g=(0,o._1)(n,"output","maxPool3dBackprop");let x=f,v=m,b=g,y=!1;4===m.rank&&(y=!0,x=(0,l.X)(f,[1,f.shape[0],f.shape[1],f.shape[2],f.shape[3]]),v=(0,l.X)(m,[1,m.shape[0],m.shape[1],m.shape[2],m.shape[3]]),b=(0,l.X)(g,[1,g.shape[0],g.shape[1],g.shape[2],g.shape[3]])),a.assert(5===x.rank,(()=>"Error in maxPool3dBackprop: dy must be rank 5 but got rank "+x.rank+".")),a.assert(5===v.rank,(()=>"Error in maxPool3dBackprop: input must be rank 5 but got rank "+v.rank+".")),a.assert(5===b.rank,(()=>"Error in maxPool3dBackprop: output must be rank 5 but got rank "+b.rank+".")),a.assert(i.jT(c,d),(()=>`Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides ${c} and dilations '${d}'`)),null!=p&&a.assert(a.isInt(h),(()=>`Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ${p} but got pad ${h}.`));const w={dy:x,input:v,output:b},k={filterSize:u,strides:c,dilations:d,pad:h,dimRoundingMode:p},I=r.BV.runKernelFunc((e=>{const t=i.pl(v.shape,u,c,d,h,p);return e.maxPool3dBackprop(x,v,b,t)}),w,null,s.f,k);return y?(0,l.X)(I,[I.shape[1],I.shape[2],I.shape[3],I.shape[4]]):I}})},67824:(e,t,n)=>{"use strict";n.d(t,{Z:()=>u});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(2582);const u=(0,n(2668).op)({maxPoolBackprop_:function(e,t,n,u,l,c,d){const h=(0,o._1)(e,"dy","maxPoolBackprop"),p=(0,o._1)(t,"input","maxPoolBackprop"),f=(0,o._1)(n,"output","maxPoolBackprop");a.assert(p.rank===h.rank,(()=>`Rank of input (${p.rank}) does not match rank of dy (${h.rank})`)),a.assert(4===h.rank,(()=>"Error in maxPoolBackprop: dy must be rank 4 but got rank "+h.rank+".")),a.assert(4===p.rank,(()=>"Error in maxPoolBackprop: input must be rank 4 but got rank "+p.rank+".")),null!=d&&a.assert(a.isInt(c),(()=>`Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode ${d} but got pad ${c}.`));const m={dy:h,input:p,output:f},g={filterSize:u,strides:l,pad:c,dimRoundingMode:d};return r.BV.runKernelFunc((e=>{const t=i.Xw(p.shape,u,l,1,c,d);return e.maxPoolBackprop(h,p,f,t)}),m,null,s.Gv,g)}})},80632:(e,t,n)=>{"use strict";n.d(t,{g:()=>l});var r=n(23926),s=n(29121),o=n(80747),a=n(43740),i=n(72200),u=n(62271);const l=(0,n(2668).op)({maximum_:function(e,t){let n=(0,a._1)(e,"a","maximum"),l=(0,a._1)(t,"b","maximum");[n,l]=(0,o.makeTypesMatch)(n,l),"bool"===n.dtype&&(n=(0,u.p)(n,"int32"),l=(0,u.p)(l,"int32")),(0,i.$N)(n.shape,l.shape);const c={a:n,b:l};return r.BV.runKernelFunc(((e,t)=>{const r=e.maximum(n,l);return t([n,l]),r}),c,null,s.BM)}})},75130:(e,t,n)=>{"use strict";n.d(t,{J:()=>m});var r=n(30633),s=n(43740),o=n(59155),a=n(83591),i=n(62271),u=n(41274),l=n(24841),c=n(44917),d=n(2668),h=n(4968),p=n(99494),f=n(15475);const m=(0,d.op)({mean_:function(e,t=null,n=!1){const d=(0,s._1)(e,"x","mean"),m=(0,o.parseAxisParam)(t,d.shape),g=(0,a.kz)(d.shape,m)[1],x=(0,o.sizeFromShape)(g);return(0,r.cb)((e=>{const r=(0,p.i)(x),s=r.dtype===e.dtype?e:(0,i.p)(e,r.dtype),o=(0,u.h)(s,r);return{value:(0,f.S)(o,t,n),gradFunc:t=>{const n=e.shape.slice();m.forEach((e=>{n[e]=1}));const r=(0,h.X)(t,n);return(0,u.h)((0,l.d)(r,(0,c.i)(e.shape,"float32")),x)}}}))(d)}})},25735:(e,t,n)=>{"use strict";n.d(t,{V:()=>d});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(83591),u=n(2668),l=n(4968),c=n(89065);const d=(0,u.op)({min_:function(e,t=null,n=!1){const u=(0,o._1)(e,"x","min"),d={x:u},h={axis:t,keepDims:n};return r.BV.runKernelFunc(((e,r)=>{const s=(0,a.parseAxisParam)(t,u.shape);let o=s;const d=i.Q3(o,u.rank);let h=u;null!=d&&(h=(0,c.p)(u,d),o=i.sY(o.length,u.rank));const p=e.min(h,o);null!=d&&h.dispose();let f=p;if(n){const e=i.rv(f.shape,s);f=(0,l.X)(p,e),p.dispose()}return r([u,f]),f}),d,null,s.c1,h)}})},24513:(e,t,n)=>{"use strict";n.d(t,{L:()=>l});var r=n(23926),s=n(29121),o=n(80747),a=n(43740),i=n(72200),u=n(62271);const l=(0,n(2668).op)({minimum_:function(e,t){let n=(0,a._1)(e,"a","minimum"),l=(0,a._1)(t,"b","minimum");[n,l]=(0,o.makeTypesMatch)(n,l),"bool"===n.dtype&&(n=(0,u.p)(n,"int32"),l=(0,u.p)(l,"int32")),(0,i.$N)(n.shape,l.shape);const c={a:n,b:l};return r.BV.runKernelFunc(((e,t)=>{const r=e.minimum(n,l);return t([n,l]),r}),c,null,s.q8)}})},85228:(e,t,n)=>{"use strict";n.d(t,{w:()=>i});var r=n(23926),s=n(29121),o=n(80747),a=n(43740);const i=(0,n(2668).op)({mod_:function(e,t){let n=(0,a._1)(e,"a","mod"),i=(0,a._1)(t,"b","mod");[n,i]=(0,o.makeTypesMatch)(n,i);const u={a:n,b:i};return r.BV.runKernelFunc(((e,t)=>{const r=e.mod(n,i);return t([n,i]),r}),u,null,s.Vb)}})},24841:(e,t,n)=>{"use strict";n.d(t,{d:()=>i});var r=n(23926),s=n(29121),o=n(80747),a=n(43740);const i=(0,n(2668).op)({mul_:function(e,t){let n=(0,a._1)(e,"a","mul"),i=(0,a._1)(t,"b","mul");[n,i]=(0,o.makeTypesMatch)(n,i);const u={a:n,b:i};return r.BV.runKernelFunc(((e,t)=>{const r=e.multiply(n,i);return t([n,i]),r}),u,null,s.wY)}})},17370:(e,t,n)=>{"use strict";n.d(t,{W:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({neg_:function(e){const t=(0,o._1)(e,"x","neg"),n={x:t};return r.BV.runKernelFunc((e=>e.neg(t)),n,null,s.L0)}})},69869:(e,t,n)=>{"use strict";n.d(t,{e:()=>s});var r=n(59155);function s(e,t,n,s,o,a){null==s&&(s=.5),null==o&&(o=Number.NEGATIVE_INFINITY),null==a&&(a=0);const i=e.shape[0];return n=Math.min(n,i),r.assert(0<=s&&s<=1,(()=>`iouThreshold must be in [0, 1], but was '${s}'`)),r.assert(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),r.assert(4===e.shape[1],(()=>"boxes must have 4 columns, but 2nd dimension was "+e.shape[1])),r.assert(1===t.rank,(()=>"scores must be a 1D tensor")),r.assert(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was `+t.shape[0])),r.assert(0<=a&&a<=1,(()=>`softNmsSigma must be in [0, 1], but was '${a}'`)),{maxOutputSize:n,iouThreshold:s,scoreThreshold:o,softNmsSigma:a}}},3561:(e,t,n)=>{"use strict";n.d(t,{K:()=>x});var r=n(43740),s=n(59155),o=n(96235),a=n(83591),i=n(83307),u=n(25735),l=n(2668),c=n(33453),d=n(4968),h=n(99494),p=n(13261),f=n(50248),m=n(15475);function g(e,t,n=null){if(0===e.rank)return(0,o.W)(e);if(1!==e.rank&&null===n)return g((0,d.X)(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return(0,m.S)((0,o.W)(e),n);if(t===1/0)return(0,i.F)((0,o.W)(e),n);if(t===-1/0)return(0,u.V)((0,o.W)(e),n);if("euclidean"===t||2===t)return(0,p._)((0,m.S)((0,c.s)((0,o.W)(e),(0,h.i)(2,"int32")),n));throw new Error("Error in norm: invalid ord value: "+t)}if(Array.isArray(n)&&2===n.length){if(1===t)return(0,i.F)((0,m.S)((0,o.W)(e),n[0]),n[1]-1);if(t===1/0)return(0,i.F)((0,m.S)((0,o.W)(e),n[1]),n[0]);if(t===-1/0)return(0,u.V)((0,m.S)((0,o.W)(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return(0,p._)((0,m.S)((0,f.h)(e),n));throw new Error("Error in norm: invalid ord value: "+t)}throw new Error("Error in norm: invalid axis: "+n)}const x=(0,l.op)({norm_:function(e,t="euclidean",n=null,o=!1){const i=g(e=(0,r._1)(e,"x","norm"),t,n);let u=i.shape;if(o){const t=(0,s.parseAxisParam)(n,e.shape);u=a.rv(i.shape,t)}return(0,d.X)(i,u)}})},16500:(e,t,n)=>{"use strict";n.d(t,{Q:()=>u});var r=n(23926),s=n(29121),o=n(80747),a=n(43740),i=n(72200);const u=(0,n(2668).op)({notEqual_:function(e,t){let n=(0,a._1)(e,"a","notEqual"),u=(0,a._1)(t,"b","notEqual");[n,u]=(0,o.makeTypesMatch)(n,u),(0,i.$N)(n.shape,u.shape);const l={a:n,b:u};return r.BV.runKernelFunc((e=>e.notEqual(n,u)),l,null,s.yQ)}})},76708:(e,t,n)=>{"use strict";n.d(t,{l:()=>u});var r=n(23926),s=n(29121),o=n(43740),a=n(2668),i=n(4968);const u=(0,a.op)({oneHot_:function(e,t,n=1,a=0){if(t<2)throw new Error("Error in oneHot: depth must be >=2, but it is "+t);const u=(0,o._1)(e,"indices","oneHot","int32"),l=[...u.shape,t],c={indices:u},d={depth:t,onValue:n,offValue:a};return r.BV.runKernelFunc(((e,r)=>(r([u]),(0,i.X)(e.oneHot((0,i.X)(u,[u.size]),t,n,a),l))),c,null,s.we,d)}})},44917:(e,t,n)=>{"use strict";n.d(t,{i:()=>i});var r=n(23926),s=n(59155),o=n(61661),a=n(59640);function i(e,t="float32"){if("complex64"===t){const t=i(e,"float32"),n=(0,a.l)(e,"float32");return(0,o.P)(t,n)}const n=(0,s.makeOnesTypedArray)((0,s.sizeFromShape)(e),t);return r.BV.makeTensor(n,e,t)}},7846:(e,t,n)=>{"use strict";n.d(t,{J:()=>d});var r=n(23926),s=n(29121),o=n(43740),a=n(61661),i=n(64386),u=n(2668),l=n(60766),c=n(6577);const d=(0,u.op)({onesLike_:function(e){const t=(0,o._1)(e,"x","onesLike"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{if("complex64"===t.dtype){const e=d((0,l.k)(t)),n=(0,c.P)((0,i.a)(t));return(0,a.P)(e,n)}return e.onesLike(t)}),n,null,s.qW)}})},2668:(e,t,n)=>{"use strict";n.d(t,{op:()=>s});var r=n(23926);function s(e){const t=Object.keys(e);if(1!==t.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+t.length+" keys.");let n=t[0];const s=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const o=(...e)=>{r.BV.startScope(n);try{const t=s(...e);return t instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r.BV.endScope(t),t}catch(e){throw r.BV.endScope(null),e}};return Object.defineProperty(o,"name",{value:n,configurable:!0}),o}},77912:(e,t,n)=>{"use strict";n.d(t,{IHx:()=>r.I,f3b:()=>s.f,PYB:()=>o.P,hiC:()=>a.h,pyx:()=>i.p,DgJ:()=>u.D,Qqt:()=>l.Q,asL:()=>c.a,Fp7:()=>d.F,dC7:()=>h.d,w6H:()=>p.w,kwC:()=>f.k,XLQ:()=>m.X,iD$:()=>g.i,tPi:()=>x.t,XAC:()=>v.X,knu:()=>b.k,luU:()=>y.l,XeE:()=>w.X,odF:()=>k.o,yXz:()=>I.y,lls:()=>C.l,p4s:()=>$.p});var r=n(56407),s=n(72657),o=n(61661),a=n(41274),i=n(83233),u=n(26477),l=n(44842),c=n(64386),d=n(83307),h=n(24841),p=n(47245),f=n(60766),m=n(4968),g=n(99494),x=n(22676),v=n(80682),b=n(82991),y=n(70827),w=n(10701),k=n(24376),I=n(89450),C=n(59640),$=n(89065),S=n(13710),R=n(7020),E=n(88447),T=n(84415),A=n(42975),_=n(97107),N=n(85078),F=n(52415),D=n(61066),B=n(90824),O=n(26466),M=n(99009),P=n(56526),L=n(91424),V=n(18135),W=n(63765),z=n(88500),U=n(13305),H=n(95098),G=n(601),X=n(25453),q=n(32512),K=n(41326),j=n(36142),Y=n(77789),Q=n(29599),J=n(95317),Z=n(4824),ee=n(42695),te=n(75706),ne=n(67740);R.k,E.S,S.Q,T.w,A.f,_.l,N.W,F.Z,B.V,H.j,U.I,O.f,D.B,M.o,P.V,L.t,V.B,W.q,z.N,G.P,X.G,q.qr,K.O,j.m,Y.Z,Q.O,J.H,Z.g,ee.F,te.f,ne.E},39682:(e,t,n)=>{"use strict";n.d(t,{v:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({pad_:function(e,t,n=0){const a=(0,o._1)(e,"x","pad");if(0===a.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:t,constantValue:n},u={x:a};return r.BV.runKernelFunc(((e,r)=>(r([a]),e.pad(a,t,n))),u,null,s.ly,i)}})},85860:(e,t,n)=>{"use strict";n.d(t,{d:()=>h});var r=n(43740),s=n(59155),o=n(15176),a=n(28441),i=n(2582),u=n(21174),l=n(2668),c=n(4968),d=n(27918);const h=(0,l.op)({pool_:function(e,t,n,l,h,p){null==h&&(h=[1,1]),null==p&&(p=1),0===l&&(l="valid");const f=(0,r._1)(e,"x","maxPool");let m=f,g=!1;3===f.rank&&(g=!0,m=(0,c.X)(f,[1,f.shape[0],f.shape[1],f.shape[2]])),s.assert(i.jT(p,h),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${p} and dilations '${h}'`));const x=i.Xw(m.shape,t,p,h,l),v=[x.dilationHeight,x.dilationWidth];let b;b="same"===l?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))).map((e=>e-1)),r=n.map((e=>Math.floor(e/2))),s=n.map(((e,t)=>e-r[t]));return n.map(((e,t)=>[r[t],s[t]]))}([x.filterHeight,x.filterWidth],v):[[0,0],[0,0]];const y=1===v[0]&&1===v[1],[w,k]=function(e,t,n){const r=n.map((e=>e[0])),s=n.map((e=>e[1])),o=e.concat(r,s),a=t.map(((e,t)=>(e-o[t]%e)%e)),i=s.map(((e,t)=>e+a[t]));return[t.map(((e,t)=>[r[t],i[t]])),t.map(((e,t)=>[0,a[t]]))]}([x.inHeight,x.inWidth],v,b),I=y?l:"valid",C=y?m:(0,d.f)(m,v,w),$=("avg"===n?()=>(0,o.w)(C,t,p,I):()=>(0,u._)(C,t,p,I))(),S=y?$:(0,a.E)($,v,k);return g?(0,c.X)(S,[S.shape[1],S.shape[2],S.shape[3]]):S}})},33453:(e,t,n)=>{"use strict";n.d(t,{s:()=>i});var r=n(23926),s=n(29121),o=n(80747),a=n(43740);const i=(0,n(2668).op)({pow_:function(e,t){let n=(0,a._1)(e,"base","pow"),i=(0,a._1)(t,"exp","pow");[n,i]=(0,o.makeTypesMatch)(n,i);const u={a:n,b:i};return r.BV.runKernelFunc(((e,t)=>{const r=e.pow(n,i);return t([n,i,r]),r}),u,null,s.pe)}})},98151:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({prelu_:function(e,t){const n=(0,o._1)(e,"x","prelu"),a=(0,o._1)(t,"alpha","prelu"),i={x:n,alpha:a};return r.BV.runKernelFunc(((e,t)=>{const r=e.prelu(n,a);return t([n,a]),r}),i,null,s.o0)}})},29798:(e,t,n)=>{"use strict";function r(e,t=!1){console.log(e.toString(t))}n.d(t,{S:()=>r})},49451:(e,t,n)=>{"use strict";n.d(t,{W:()=>h});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(83591),u=n(62271),l=n(2668),c=n(4968),d=n(89065);const h=(0,l.op)({prod_:function(e,t=null,n=!1){let l=(0,o._1)(e,"x","prod");const h={x:l},p={axis:t,keepDims:n};return r.BV.runKernelFunc((e=>{"bool"===l.dtype&&(l=(0,u.p)(l,"int32"));const r=(0,a.parseAxisParam)(t,l.shape),s=(0,i.Q3)(r,l.rank);let o=r,h=l;null!=s&&(h=(0,d.p)(l,s),o=(0,i.sY)(o.length,l.rank));let p=e.prod(h,o);if(n){const e=(0,i.rv)(p.shape,r);p=(0,c.X)(p,e)}return p}),h,null,s.Dl,p)}})},47245:(e,t,n)=>{"use strict";n.d(t,{w:()=>u});var r=n(23926),s=n(29121),o=n(59155),a=n(46092),i=n(59640);function u(e,t,n=1,u="float32"){if(0===n)throw new Error("Cannot have a step of zero");const l={start:e,stop:t,step:n,dtype:u};return r.BV.runKernelFunc((()=>{if(e===t||e<t&&n<0||t<e&&n>1)return(0,i.l)([0],u);const r=Math.abs(Math.ceil((t-e)/n)),s=(0,o.makeZerosTypedArray)(r,u);t<e&&1===n&&(n=-1),s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+n;return(0,a.R)(s,u)}),{},null,s.e6,l)}},60766:(e,t,n)=>{"use strict";n.d(t,{k:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({real_:function(e){const t=(0,o._1)(e,"input","real"),n={input:t};return r.BV.runKernelFunc((e=>e.real(t)),n,null,s.xJ)}})},19036:(e,t,n)=>{"use strict";n.d(t,{M:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({reciprocal_:function(e){const t=(0,o._1)(e,"x","reciprocal"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.reciprocal(t);return n([t]),r}),n,null,s.$H)}})},25466:(e,t,n)=>{"use strict";n.d(t,{g:()=>s,A:()=>o});var r=n(59155);const s=30;function o(e){return e<=s?e:(0,r.nearestDivisor)(e,Math.floor(Math.sqrt(e)))}},7409:(e,t,n)=>{"use strict";n.d(t,{U:()=>u});var r=n(23926),s=n(29121),o=n(43740),a=n(2668),i=n(62271);const u=(0,a.op)({relu_:function(e){const t=(0,o._1)(e,"x","relu"),n={x:t};return r.BV.runKernelFunc(((e,n)=>(n([t]),"bool"===t.dtype?(0,i.p)(t,"int32"):e.relu(t))),n,null,s.qk)}})},83582:(e,t,n)=>{"use strict";n.d(t,{b:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(62271);const i=(0,n(2668).op)({relu6_:function(e){const t=(0,o._1)(e,"x","relu6"),n={x:t};return r.BV.runKernelFunc(((e,n)=>(n([t]),"bool"===t.dtype?(0,a.p)(t,"int32"):e.relu6(t))),n,null,s.Sb)}})},4968:(e,t,n)=>{"use strict";n.d(t,{X:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(59155);const i=(0,n(2668).op)({reshape_:function(e,t){const n=(0,o._1)(e,"x","reshape",null),i={x:n},u={shape:t};return r.BV.runKernelFunc(((e,r)=>(t=a.inferFromImplicitShape(t,n.size),a.assert(n.size===a.sizeFromShape(t),(()=>"new shape and old shape must have the same number of elements.")),r([n]),e.reshape(n,t))),i,null,s.HZ,u)}})},57486:(e,t,n)=>{"use strict";n.d(t,{G:()=>c});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(8723),u=n(2668),l=n(4968);const c=(0,u.op)({reverse_:function(e,t){const n=(0,o._1)(e,"x","reverse"),u={x:n},c={dims:t};return r.BV.runKernelFunc((e=>{const r=(0,a.parseAxisParam)(t,n.shape);if(0===n.rank)return(0,i.d)(n);const s=e.reverse(n,r);return(0,l.X)(s,n.shape)}),u,null,s.mK,c)}})},29645:(e,t,n)=>{"use strict";function r(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}n.d(t,{Q:()=>r})},97809:(e,t,n)=>{"use strict";n.d(t,{N:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({round_:function(e){const t=(0,o._1)(e,"x","round"),n={x:t};return r.BV.runKernelFunc((e=>e.round(t)),n,null,s.e0)}})},32634:(e,t,n)=>{"use strict";n.d(t,{b:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({rsqrt_:function(e){const t=(0,o._1)(e,"x","rsqrt"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.rsqrt(t);return n([t]),r}),n,null,s.bV)}})},99494:(e,t,n)=>{"use strict";n.d(t,{i:()=>o});var r=n(59155),s=n(57852);function o(e,t){if(((0,r.isTypedArray)(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&(0,r.isTypedArray)(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,s.H)(e,[],[],t)}},33028:(e,t,n)=>{"use strict";n.d(t,{validateUpdateShape:()=>s,validateInput:()=>o,calculateShapes:()=>a});var r=n(59155);function s(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,o="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+n.shape+`, indices.shape: ${t.shape}, shape: ${e}`+`, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(o+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(o+" Output shape length < "+(r+(n.rank-s)));if(n.rank!==s+e.length-r)throw new Error(o+" update.rank != "+(s+e.length-r));for(let e=0;e<s;++e)if(n.shape[e]!==t.shape[e])throw new Error(o+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-s;++t)if(n.shape[t+s]!==e[t+r])throw new Error(o+` updates.shape[${t+s}] (${n.shape[t+s]}) != shape[${t+s}] (${e[t+s]})`)}function o(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: "+t.dtype);if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+n);if(0===n.length){if(0===t.size)throw new Error("Indices specified for empty output. indices shape: "+t.shape);if(0===e.size)throw new Error("Updates specified for empty output. updates shape: "+e.shape)}s(n,t,e)}function a(e,t,n){const s=t.shape.length,o=s>1?t.shape[s-1]:1,a=n.length;let i=1;for(let e=o;e<a;++e)i*=n[e];const u=o<1?1:o;return{sliceRank:o,numUpdates:(0,r.sizeFromShape)(t.shape)/u,sliceSize:i,strides:[...(0,r.computeStrides)(n.slice(0,o)),1],outputSize:(0,r.sizeFromShape)(n)}}},14931:(e,t,n)=>{"use strict";n.r(t),n.d(t,{segOpComputeOptimalWindowSize:()=>o,computeOutShape:()=>a,collectGatherOpShapeInfo:()=>i});var r=n(59155),s=n(25466);function o(e,t){let n,o=!1;for(e<=s.g?(n=e,o=!0):n=(0,r.nearestDivisor)(e,Math.floor(Math.sqrt(e)));!o;)n>t||n===e?o=!0:n=(0,r.nearestDivisor)(e,n+1);return n}function a(e,t,n){const r=[],s=e.length;for(let o=0;o<s;o++)o!==t?r.push(e[o]):r.push(n);return r}function i(e,t,n){const r=e.shape[n],s=[];let o=1,a=1;for(let t=0;t<n;t++)s.push(e.shape[t]),o*=e.shape[t];for(let e=0;e<t.rank;e++)s.push(t.shape[e]);for(let t=n+1;t<e.rank;t++)s.push(e.shape[t]),a*=e.shape[t];return{batchSize:o,sliceSize:a,dimSize:r,outputShape:s}}},55503:(e,t,n)=>{"use strict";n.d(t,{U:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({selu_:function(e){const t=(0,o._1)(e,"x","selu"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.selu(t);return n([t]),r}),n,null,s.oF)}})},43179:(e,t,n)=>{"use strict";n.d(t,{y:()=>r,$:()=>s});const r=1.7580993408473768,s=1.0507009873554805},68678:(e,t,n)=>{"use strict";n.d(t,{U:()=>l});var r=n(43740),s=n(59155),o=n(64794),a=n(64718),i=n(2668),u=n(4968);const l=(0,i.op)({separableConv2d_:function(e,t,n,i,l,c=[1,1],d="NHWC"){const h=(0,r._1)(e,"x","separableConv2d"),p=(0,r._1)(t,"depthwiseFilter","separableConv2d"),f=(0,r._1)(n,"pointwiseFilter","separableConv2d");let m=h,g=!1;if(3===h.rank&&(g=!0,m=(0,u.X)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),"NCHW"===d)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");s.assert(4===m.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${m.rank}.`)),s.assert(4===p.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${p.rank}.`)),s.assert(4===f.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${p.rank}.`)),s.assert(1===f.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${f.shape[0]}.`)),s.assert(1===f.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${f.shape[1]}.`));const x=p.shape[2],v=p.shape[3];s.assert(f.shape[2]===x*v,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${x*v}, but got ${f.shape[2]}.`));const b=(0,a.B)(m,p,i,l,d,c),y=(0,o.T)(b,f,1,"valid",d);return g?(0,u.X)(y,[y.shape[1],y.shape[2],y.shape[3]]):y}})},30625:(e,t,n)=>{"use strict";n.d(t,{X:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({sigmoid_:function(e){const t=(0,o._1)(e,"x","sigmoid"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.sigmoid(t);return n([r]),r}),n,null,s.a5)}})},34434:(e,t,n)=>{"use strict";n.d(t,{X:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({sign_:function(e){const t=(0,o._1)(e,"x","sign"),n={x:t};return r.BV.runKernelFunc((e=>e.sign(t)),n,null,s.i5)}})},85078:(e,t,n)=>{"use strict";n.d(t,{W:()=>l});var r=n(46884),s=n(14006),o=n(2668),a=n(4968),i=n(22676),u=n(24376);const l=(0,o.op)({frame_:function(e,t,n,o=!1,l=0){let c=0;const d=[];for(;c+t<=e.size;)d.push((0,i.t)(e,c,t)),c+=n;if(o)for(;c<e.size;){const o=c+t-e.size,a=(0,r.z)([(0,i.t)(e,c,t-o),(0,s.h)([o],l)]);d.push(a),c+=n}return 0===d.length?(0,u.o)([],[0,t]):(0,a.X)((0,r.z)(d),[d.length,t])}})},42975:(e,t,n)=>{"use strict";n.d(t,{f:()=>o});var r=n(2668),s=n(1347);const o=(0,r.op)({hammingWindow_:function(e){return(0,s.m)(e,.54,.46)}})},97107:(e,t,n)=>{"use strict";n.d(t,{l:()=>o});var r=n(2668),s=n(1347);const o=(0,r.op)({hannWindow_:function(e){return(0,s.m)(e,.5,.5)}})},52415:(e,t,n)=>{"use strict";n.d(t,{Z:()=>d});var r=n(46884),s=n(24841),o=n(2668),a=n(1347),i=n(22676),u=n(13710),l=n(85078),c=n(97107);const d=(0,o.op)({stft_:function(e,t,n,o,d=c.l){null==o&&(o=(0,a.G)(t));const h=(0,l.W)(e,t,n),p=(0,s.d)(h,d(t)),f=[];for(let e=0;e<h.shape[0];e++)f.push((0,u.Q)((0,i.t)(p,[e,0],[1,t]),o));return(0,r.z)(f)}})},1347:(e,t,n)=>{"use strict";n.d(t,{G:()=>s,m:()=>o});var r=n(46092);function s(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function o(e,t,n){const s=1-e%2,o=new Float32Array(e);for(let r=0;r<e;++r){const a=2*Math.PI*r/(e+s-1);o[r]=t-n*Math.cos(a)}return(0,r.R)(o,"float32")}},99331:(e,t,n)=>{"use strict";n.d(t,{O:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({sin_:function(e){const t=(0,o._1)(e,"x","sin"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.sin(t);return n([t]),r}),n,null,s.RQ)}})},83254:(e,t,n)=>{"use strict";n.d(t,{R:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({sinh_:function(e){const t=(0,o._1)(e,"x","sinh"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.sinh(t);return n([t]),r}),n,null,s.w3)}})},22676:(e,t,n)=>{"use strict";n.d(t,{t:()=>u});var r=n(23926),s=n(29121),o=n(43740),a=n(2668),i=n(37650);const u=(0,a.op)({slice_:function(e,t,n){const a=(0,o._1)(e,"x","slice");if(0===a.rank)throw new Error("Slicing scalar is not possible");const u={x:a},l={begin:t,size:n};return r.BV.runKernelFunc(((e,r)=>{const[s,o]=i.parseSliceParams(a,t,n);return i.assertParamsValid(a,s,o),r([a]),e.slice(a,s,o)}),u,null,s.p2,l)}})},37650:(e,t,n)=>{"use strict";n.r(t),n.d(t,{assertParamsValid:()=>s,maskToAxes:()=>o,computeOutShape:()=>a,stridesWithElidedDims:()=>i,getNormalizedAxes:()=>c,startIndicesWithElidedDims:()=>d,stopIndicesWithElidedDims:()=>h,stridesForAxis:()=>p,startForAxis:()=>f,stopForAxis:()=>m,isSliceContinous:()=>g,computeFlatOffset:()=>x,parseSliceParams:()=>v});var r=n(59155);function s(e,t,n){const s=e.shape.length;r.assert(s===t.length,(()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`)),r.assert(s===n.length,(()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`));for(let o=0;o<s;++o)r.assert(t[o]+n[o]<=e.shape[o],(()=>`Error in slice${s}D: begin[${o}] + size[${o}] (${t[o]+n[o]}) would overflow input.shape[${o}] (${e.shape[o]})`))}function o(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function a(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function i(e,t,n,r){const s=[...e];for(let e=s.length;e<r.length;e++)s.push(1);for(let e=0;e<n;e++)0===e?s[t]=1:(s.splice(t,0,1),s.pop());return s}function u(e,t,n){return n<=e?n:n-(t-1)}function l(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function c(e,t,n,r,s,o,a,u,l){const c=e.length;let g=new Array(c),x=new Array(c),v=new Array(c);if(t.length&&n>0){const l=t[0],c=n+1;g=d(a,l,c,r,e),x=h(u,l,c,s,e),v=i(o,l,c,e)}else for(let t=0;t<c;t++)g[t]=f(a,r,o,e,t,l),x[t]=m(u,s,o,e,t,l),v[t]=p(o,t,l);return{begin:g,end:x,strides:v}}function d(e,t,n,r,s){const o=[...s],a=l(n,t);for(let s=0;s<o.length;s++)if(a.indexOf(s)>-1)o[s]=0;else{const a=u(t,n,s);let i=r[a];e&1<<a&&(i=0),o[s]=i}return o}function h(e,t,n,s,o){const a=[...o],i=l(n,t);for(let r=0;r<a.length;r++)if(i.indexOf(r)>-1)a[r]=Number.MAX_SAFE_INTEGER;else{const o=u(t,n,r);let i=s[o];e&1<<o&&(i=Number.MAX_SAFE_INTEGER),a[r]=i}for(let e=0;e<a.length;e++){const t=o[e];a[e]<0&&(a[e]+=t),a[e]=r.clamp(0,a[e],o[e])}return a}function p(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function f(e,t,n,s,o,a){let i=t[o];const u=n[o]||1;(e&1<<o||a&1<<o||null==i)&&(i=u>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=s[o];return i<0&&(i+=l),i=r.clamp(0,i,l-1),i}function m(e,t,n,s,o,a){let i=t[o];const u=n[o]||1;(e&1<<o||a&1<<o||null==i)&&(i=u>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=s[o];return i<0&&(i+=l),i=u>0?r.clamp(0,i,l):r.clamp(-1,i,l-1),i}function g(e,t,n){let r=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){r=e;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function x(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function v(e,t,n){let s;const o=e.shape.length;let a;return s="number"==typeof t?[t,...new Array(o-1).fill(0)]:t.length<o?t.concat(new Array(o-t.length).fill(0)):t.slice(),s.forEach((e=>{r.assert(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(o).fill(-1):"number"==typeof n?[n,...new Array(o-1).fill(-1)]:n.length<o?n.concat(new Array(o-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(r.assert(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-s[n]))),[s,a]}},80682:(e,t,n)=>{"use strict";n.d(t,{X:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({softmax_:function(e,t=-1){const n=(0,o._1)(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const a={logits:n},i={dim:t};return r.BV.runKernelFunc(((e,r)=>{const s=e.softmax(n,t);return r([s]),s}),a,null,s.Gc,i)}})},3694:(e,t,n)=>{"use strict";n.d(t,{W:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({softplus_:function(e){const t=(0,o._1)(e,"x","softplus"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.softplus(t);return n([t]),r}),n,null,s.MR)}})},27918:(e,t,n)=>{"use strict";n.d(t,{f:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(59155);const i=(0,n(2668).op)({spaceToBatchND_:function(e,t,n){const i=(0,o._1)(e,"x","spaceToBatchND");a.assert(i.rank>=1+t.length,(()=>`input rank ${i.rank} should be > than [blockShape] ${t.length}`)),a.assert(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),a.assert(i.shape.reduce(((e,r,s)=>s>0&&s<=t.length?e&&(r+n[s-1][0]+n[s-1][1])%t[s-1]==0:e),!0),(()=>`input spatial dimensions ${i.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const u={x:i},l={blockShape:t,paddings:n};return r.BV.runKernelFunc((e=>e.spaceToBatchND(i,t,n)),u,null,s.TQ,l)}})},7020:(e,t,n)=>{"use strict";n.d(t,{k:()=>a});var r=n(23926),s=n(29121),o=n(59155);const a=(0,n(2668).op)({fft_:function(e){(0,o.assert)("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return r.BV.runKernelFunc((t=>{const n=e.shape[e.shape.length-1],r=e.size/n,s=e.as2D(r,n);return t.fft(s).reshape(e.shape)}),t,null,s.vw)}})},88447:(e,t,n)=>{"use strict";n.d(t,{S:()=>u});var r=n(23926),s=n(29121),o=n(59155),a=n(2668),i=n(4968);const u=(0,a.op)({ifft_:function(e){(0,o.assert)("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return r.BV.runKernelFunc((t=>{const n=e.shape[e.shape.length-1],r=e.size/n,s=(0,i.X)(e,[r,n]),o=t.ifft(s);return(0,i.X)(o,e.shape)}),t,null,s.Qg)}})},84415:(e,t,n)=>{"use strict";n.d(t,{w:()=>f});var r=n(61661),s=n(46884),o=n(64386),a=n(24841),i=n(2668),u=n(60766),l=n(4968),c=n(57486),d=n(99494),h=n(22676),p=n(88447);const f=(0,i.op)({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let i;if(t<=2){const r=(0,l.X)(e,[n,t]);i=(0,p.S)(r)}else{const f=[n,2*(t-1)],m=(0,l.X)((0,u.k)(e),[n,t]),g=(0,l.X)((0,o.a)(e),[n,t]),x=(0,c.G)((0,h.t)(m,[0,1],[n,t-2]),1),v=(0,a.d)((0,c.G)((0,h.t)(g,[0,1],[n,t-2]),1),(0,d.i)(-1)),b=(0,s.z)([m,x],1),y=(0,s.z)([g,v],1),w=(0,l.X)((0,r.P)(b,y),[f[0],f[1]]);i=(0,p.S)(w)}if(i=(0,u.k)(i),3===e.rank&&0!==e.shape[0]){const t=i,n=e.shape[0];i=(0,l.X)(i,[n,i.shape[0]/n,i.shape[1]]),t.dispose()}return i}})},13710:(e,t,n)=>{"use strict";n.d(t,{Q:()=>m});var r=n(59155),s=n(61661),o=n(46884),a=n(64386),i=n(2668),u=n(60766),l=n(4968),c=n(22676),d=n(28644),h=n(59640),p=n(6577),f=n(7020);const m=(0,i.op)({rfft_:function(e,t){(0,r.assert)("float32"===e.dtype,(()=>"The dtype for rfft() must be real value but got "+e.dtype));let n=e.shape[e.shape.length-1];const i=e.size/n;let m;if(null!=t&&t<n){const r=e.shape.map((e=>0)),s=e.shape.map((e=>e));s[e.shape.length-1]=t,m=(0,c.t)(e,r,s),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,m=(0,o.z)([e,(0,h.l)(r)],e.shape.length-1),n=t}else m=e;const g=(0,p.P)(m),x=(0,l.X)((0,s.P)(m,g),[i,n]),v=(0,f.k)(x),b=Math.floor(n/2)+1,y=(0,u.k)(v),w=(0,a.a)(v),k=(0,d.V)(y,[b,n-b],y.shape.length-1),I=(0,d.V)(w,[b,n-b],w.shape.length-1),C=m.shape.slice();return C[m.shape.length-1]=b,(0,l.X)((0,s.P)(k[0],I[0]),C)}})},28644:(e,t,n)=>{"use strict";n.d(t,{V:()=>l});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(2668),u=n(34099);const l=(0,i.op)({split_:function(e,t,n=0){const i=(0,o._1)(e,"x","split"),l={x:i},c={numOrSizeSplits:t,axis:n};return r.BV.runKernelFunc(((e,r)=>{const s=(0,a.parseAxisParam)(n,i.shape)[0],o=(0,u.O)(i,t,s);return e.split(i,o,s)}),l,null,s.L8,c)}})},34099:(e,t,n)=>{"use strict";n.d(t,{O:()=>s});var r=n(59155);function s(e,t,n=0){let s=[];if("number"==typeof t)(0,r.assert)(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),s=new Array(t).fill(e.shape[n]/t);else{const o=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);(0,r.assert)(o<=1,(()=>"There should be only one negative value in split array."));const a=t.indexOf(-1);if(-1!==a){const r=t.reduce(((e,t)=>t>0?e+t:e));t[a]=e.shape[n]-r}(0,r.assert)(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),s=t}return s}},13261:(e,t,n)=>{"use strict";n.d(t,{_:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({sqrt_:function(e){const t=(0,o._1)(e,"x","sqrt"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.sqrt(t);return n([t]),r}),n,null,s.FK)}})},50248:(e,t,n)=>{"use strict";n.d(t,{h:()=>o});var r=n(23926),s=n(43740);const o=(0,n(2668).op)({square_:function(e){const t=(0,s._1)(e,"x","square"),n=[t];return r.BV.runKernelFunc(((e,n)=>(n([t]),e.square(t))),{x:t},null,"Square",{},n,[])}})},15265:(e,t,n)=>{"use strict";n.d(t,{$:()=>u});var r=n(23926),s=n(29121),o=n(80747),a=n(43740),i=n(72200);const u=(0,n(2668).op)({squaredDifference_:function(e,t){let n=(0,a._1)(e,"a","squaredDifference"),u=(0,a._1)(t,"b","squaredDifference");[n,u]=(0,o.makeTypesMatch)(n,u),(0,i.$N)(n.shape,u.shape);const l={a:n,b:u};return r.BV.runKernelFunc(((e,t)=>{const r=e.squaredDifference(n,u);return t([n,u]),r}),l,null,s._t,{})}})},79590:(e,t,n)=>{"use strict";n.d(t,{L:()=>i});var r=n(43740),s=n(59155),o=n(2668),a=n(4968);const i=(0,o.op)({squeeze_:function(e,t){const n=(0,r._1)(e,"x","squeeze");return(0,a.X)(n,(0,s.squeezeShape)(n.shape,t).newShape)}})},82991:(e,t,n)=>{"use strict";n.d(t,{k:()=>i});var r=n(43740),s=n(59155),o=n(46884),a=n(81300);const i=(0,n(2668).op)({stack_:function(e,t=0){const n=(0,r.sI)(e,"tensors","stack");if(s.assert(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),1===n.length)return(0,a.d)(n[0],t);const i=n[0].rank,u=n[0].shape,l=n[0].dtype;s.assert(t<=i,(()=>"Axis must be <= rank of the tensor")),n.forEach((e=>{s.assertShapesMatch(u,e.shape,"All tensors passed to stack must have matching shapes"),s.assert(l===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const c=n.map((e=>(0,a.d)(e,t)));return(0,o.z)(c,t)}})},71901:(e,t,n)=>{"use strict";n.d(t,{N:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({step_:function(e,t=0){const n=(0,o._1)(e,"x","step"),a={x:n},i={alpha:t};return r.BV.runKernelFunc((e=>e.step(n,t)),a,null,s.h8,i)}})},55158:(e,t,n)=>{"use strict";n.d(t,{N:()=>c});var r=n(23926),s=n(29121),o=n(43740),a=n(2668),i=n(4968),u=n(22676),l=n(37650);const c=(0,a.op)({stridedSlice_:function(e,t,n,a,c=0,d=0,h=0,p=0,f=0){let m=(0,o._1)(e,"x","stridedSlice");const g={x:m},x={begin:t,end:n,strides:a,beginMask:c,endMask:d,ellipsisMask:h,newAxisMask:p,shrinkAxisMask:f};return r.BV.runKernelFunc((e=>{null==a&&(a=new Array(t.length));const r=(0,l.maskToAxes)(h);if(r.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==h&&0!==p)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==h&&0!==f)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const s=m.rank-t.length,o=(0,l.maskToAxes)(p),g=m.shape.slice();o.forEach((e=>{t[e]=0,n[e]=1,g.splice(e,0,1)})),m=(0,i.X)(m,g);const{begin:x,end:v,strides:b}=(0,l.getNormalizedAxes)(m.shape,r,s,t,n,a,c,d,h);t=x,n=v,a=b;const y=(0,l.maskToAxes)(f);y.forEach((e=>{n[e]=t[e]+1,a[e]=1}));const w=(0,l.computeOutShape)(t,n,a),k=w.filter(((e,t)=>-1===y.indexOf(t)));if(a.every((e=>1===e)))return(0,i.X)((0,u.t)(m,t,w),k);const I=e.stridedSlice(m,t,n,a);return(0,i.X)(I,k)}),g,null,s.jQ,x)}})},70827:(e,t,n)=>{"use strict";n.d(t,{l:()=>i});var r=n(23926),s=n(29121),o=n(80747),a=n(43740);const i=(0,n(2668).op)({sub_:function(e,t){let n=(0,a._1)(e,"a","sub"),i=(0,a._1)(t,"b","sub");[n,i]=(0,o.makeTypesMatch)(n,i);const u={a:n,b:i};return r.BV.runKernelFunc(((e,t)=>{const r=e.subtract(n,i);return t([n,i]),r}),u,null,s.Tr)}})},15475:(e,t,n)=>{"use strict";n.d(t,{S:()=>h});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(83591),u=n(62271),l=n(2668),c=n(4968),d=n(89065);const h=(0,l.op)({sum_:function(e,t=null,n=!1){let l=(0,o._1)(e,"x","sum");"bool"===l.dtype&&(l=(0,u.p)(l,"int32"));const h={x:l},p={axis:t,keepDims:n};return r.BV.runKernelFunc(((e,r)=>{r([l]);const s=(0,a.parseAxisParam)(t,l.shape),o=(0,i.Q3)(s,l.rank);let u=s,h=l;null!=o&&(h=(0,d.p)(l,o),u=(0,i.sY)(u.length,l.rank));let p=e.sum(h,u);if(n){const e=(0,i.rv)(p.shape,s);p=(0,c.X)(p,e)}return p}),h,null,s.GB,p)}})},61173:(e,t,n)=>{"use strict";n.d(t,{O:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({tan_:function(e){const t=(0,o._1)(e,"x","tan"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.tan(t);return n([t]),r}),n,null,s.sE)}})},21869:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({tanh_:function(e){const t=(0,o._1)(e,"x","tanh"),n={x:t};return r.BV.runKernelFunc(((e,n)=>{const r=e.tanh(t);return n([r]),r}),n,null,s.MI)}})},10701:(e,t,n)=>{"use strict";n.d(t,{X:()=>o});var r=n(43740),s=n(57852);function o(e,t,n){const o=(0,r.C)(e,n);return(0,s.H)(e,t,o,n)}},46092:(e,t,n)=>{"use strict";n.d(t,{R:()=>a});var r=n(43740),s=n(59155),o=n(57852);function a(e,t){(0,s.assertNonNull)(e);const n=(0,r.C)(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,o.H)(e,null,n,t)}},24376:(e,t,n)=>{"use strict";n.d(t,{o:()=>a});var r=n(43740),s=n(59155),o=n(57852);function a(e,t,n){if((0,s.assertNonNull)(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const a=(0,r.C)(e,n);if(2!==a.length&&1!==a.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,o.H)(e,t,a,n)}},89450:(e,t,n)=>{"use strict";n.d(t,{y:()=>a});var r=n(43740),s=n(59155),o=n(57852);function a(e,t,n){if((0,s.assertNonNull)(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const a=(0,r.C)(e,n);if(4!==a.length&&1!==a.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return(0,o.H)(e,t,a,n)}},57852:(e,t,n)=>{"use strict";n.d(t,{H:()=>o});var r=n(23926),s=n(59155);function o(e,t,n,o){if(null==o&&(o=(0,s.inferDtype)(e)),"complex64"===o)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!(0,s.isTypedArray)(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){(0,s.assertNonNegativeIntegerDimensions)(t);const e=(0,s.sizeFromShape)(t),r=(0,s.sizeFromShape)(n);(0,s.assert)(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let e=0;e<n.length;++e){const r=n[e],o=e!==n.length-1||r!==(0,s.sizeFromShape)(t.slice(e));(0,s.assert)(n[e]===t[e]||!o,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return(0,s.isTypedArray)(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==o?(0,s.toTypedArray)(e,o):(0,s.flatten)(e,[],!0),r.BV.makeTensor(e,t,o)}},47501:(e,t,n)=>{"use strict";n.d(t,{G:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(59155);const i=(0,n(2668).op)({tile_:function(e,t){const n=(0,o._1)(e,"x","tile",null);a.assert(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const i=[n],u={x:n},l={reps:t};return r.BV.runKernelFunc(((e,r)=>{const s=e.tile(n,t);return r([n]),s}),u,null,s.n9,l,i)}})},43243:(e,t,n)=>{"use strict";n.d(t,{h:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({topk_:function(e,t=1,n=!0){const a=(0,o._1)(e,"x","topk");if(0===a.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const i=a.shape[a.shape.length-1];if(t>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got `+t);const u={x:a},l={k:t,sorted:n},[c,d]=r.BV.runKernelFunc((e=>e.topk(a,t,n)),u,null,s.cW,l);return{values:c,indices:d}}})},89065:(e,t,n)=>{"use strict";n.d(t,{p:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(59155);const i=(0,n(2668).op)({transpose_:function(e,t){const n=(0,o._1)(e,"x","transpose");if(null==t&&(t=n.shape.map(((e,t)=>t)).reverse()),a.assert(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`)),t.forEach((e=>{a.assert(e>=0&&e<n.rank,(()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+" but got "+t))})),n.rank<=1)return n.clone();const i={x:n},u={perm:t};return r.BV.runKernelFunc((e=>e.transpose(n,t)),i,null,s.G3,u)}})},49608:(e,t,n)=>{"use strict";n.d(t,{T:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(59155);const i=(0,n(2668).op)({unique_:function(e,t=0){const n=(0,o._1)(e,"x","unique",null);(0,a.assert)(n.rank>0,(()=>"The input tensor must be at least 1D"));const i={x:n},u={axis:t},[l,c]=r.BV.runKernel(s.kp,i,u);return{values:l,indices:c}}})},98749:(e,t,n)=>{"use strict";n.d(t,{p:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(59155);const i=(0,n(2668).op)({unsortedSegmentSum_:function(e,t,n){const i=(0,o._1)(e,"x","unsortedSegmentSum"),u=(0,o._1)(t,"segmentIds","unsortedSegmentSum","int32");(0,a.assert)((0,a.isInt)(n),(()=>"numSegments must be of dtype int"));const l={x:i,segmentIds:u},c={numSegments:n};return r.BV.runKernelFunc(((e,t)=>{const r=e.unsortedSegmentSum(i,u,n);return t([u]),r}),l,null,s.Qv,c)}})},24136:(e,t,n)=>{"use strict";n.d(t,{H:()=>i});var r=n(23926),s=n(29121),o=n(43740),a=n(59155);const i=(0,n(2668).op)({unstack_:function(e,t=0){const n=(0,o._1)(e,"x","unstack");a.assert(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`)),t<0&&(t+=n.shape.length);const i={value:n},u={axis:t};return r.BV.runKernelFunc((e=>e.unstack(n,t)),i,null,s.To,u)}})},95912:(e,t,n)=>{"use strict";n.d(t,{a:()=>l});var r=n(23926),s=n(29121),o=n(43740),a=n(59155),i=n(68247),u=n(72200);const l=(0,n(2668).op)({where_:function(e,t,n){const l=(0,o._1)(t,"a","where"),c=(0,o._1)(n,"b","where"),d=(0,o._1)(e,"condition","where","bool"),h=(0,u.$N)(l.shape,c.shape),p=(0,i.U)(l,h),f=(0,i.U)(c,h);1===d.rank&&(0,a.assert)(d.shape[0]===l.shape[0],(()=>"The first dimension of `a` must match the size of `condition`.")),1!==d.rank&&(0,a.assertShapesMatch)(d.shape,f.shape,"Error in where: ");const m={condition:d,t:p,e:f};return r.BV.runKernelFunc(((e,t)=>{const n=e.select(d,p,f);return t([d]),n}),m,null,s.xc)}})},59640:(e,t,n)=>{"use strict";n.d(t,{l:()=>a});var r=n(23926),s=n(59155),o=n(61661);function a(e,t="float32"){if("complex64"===t){const t=a(e,"float32"),n=a(e,"float32");return(0,o.P)(t,n)}const n=(0,s.makeZerosTypedArray)((0,s.sizeFromShape)(e),t);return r.BV.makeTensor(n,e,t)}},6577:(e,t,n)=>{"use strict";n.d(t,{P:()=>a});var r=n(23926),s=n(29121),o=n(43740);const a=(0,n(2668).op)({zerosLike_:function(e){const t=(0,o._1)(e,"x","zerosLike"),n={x:t};return r.BV.runKernelFunc((e=>e.zerosLike(t)),n,null,s.Ru)}})},26480:(e,t,n)=>{"use strict";n(79998);var r=n(22885),s=n(61044),o=n(28209),a=n(90780);class i{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Browser's encoder only supports utf-8, but got "+t);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if((0,r.OB)().get("IS_BROWSER")){(0,r.OB)().setPlatform("browser",new i);try{a.xQ.registerManager(o.Ew.URL_SCHEME,new o.JL)}catch(e){}try{a.xQ.registerManager(s.ns.URL_SCHEME,new s.y$)}catch(e){}}},35221:(e,t,n)=>{"use strict";var r=n(22885);let s;(0,r.OB)().get("IS_NODE")&&(0,r.OB)().setPlatform("node",new class{constructor(){this.util=n(61758),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=(0,r.OB)().global.fetch?(0,r.OB)().global.fetch(e,t):(null==s&&(s=n(78352)),s(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Node built-in encoder only supports utf-8, but got "+t);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}})},52368:(e,t,n)=>{"use strict";n.d(t,{Q1:()=>s});var r=n(59155);class s{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new a)}profileKernel(e,t,n){let r;const s=this.backendTimer.time((()=>{r=n()}));for(let t=0;t<r.length;t++){const n=r[t];n.data().then((t=>{o(t,n.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:s.then((e=>e.kernelMs)),extraInfo:s.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:o}=e;n.forEach((e=>{Promise.all([e.data(),r,o]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])}))}))}}function o(e,t,n){if("float32"!==t)return!1;for(let t=0;t<e.length;t++){const r=e[t];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class a{logKernelProfile(e,t,n,s,o,a){const i="number"==typeof s?r.rightPad(s+"ms",9):s.error,u=r.rightPad(e,25),l=t.rank,c=t.size,d=r.rightPad(t.shape.toString(),14);let h="";for(const e in o){const n=o[e];if(null!=n){const r=n.shape||t.shape,s=r.length;h+=`${e}: ${s}D ${s>0?r:""} `}}console.log(`%c${u}\t%c${i}\t%c${l}D ${d}\t%c${c}\t%c${h}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}},84941:(e,t,n)=>{"use strict";var r=n(96235);n(73327).es.prototype.abs=function(){return this.throwIfDisposed(),(0,r.W)(this)}},88154:(e,t,n)=>{"use strict";var r=n(17839);n(73327).es.prototype.acos=function(){return this.throwIfDisposed(),(0,r.K)(this)}},46885:(e,t,n)=>{"use strict";var r=n(91470);n(73327).es.prototype.acosh=function(){return this.throwIfDisposed(),(0,r._)(this)}},54878:(e,t,n)=>{"use strict";var r=n(56407);n(73327).es.prototype.add=function(e){return this.throwIfDisposed(),(0,r.I)(this,e)}},67049:(e,t,n)=>{"use strict";var r=n(87536);n(73327).es.prototype.addStrict=function(e){return this.throwIfDisposed(),(0,r.zq)(this,e)}},98824:(e,t,n)=>{"use strict";var r=n(90781);n(73327).es.prototype.all=function(e,t){return this.throwIfDisposed(),(0,r.$)(this,e,t)}},74342:(e,t,n)=>{"use strict";var r=n(92998);n(73327).es.prototype.any=function(e,t){return this.throwIfDisposed(),(0,r.Y)(this,e,t)}},21981:(e,t,n)=>{"use strict";var r=n(40047);n(73327).es.prototype.argMax=function(e){return this.throwIfDisposed(),(0,r.N)(this,e)}},53196:(e,t,n)=>{"use strict";var r=n(27394);n(73327).es.prototype.argMin=function(e){return this.throwIfDisposed(),(0,r.v)(this,e)}},99007:(e,t,n)=>{"use strict";var r=n(4968);n(73327).es.prototype.as1D=function(){return this.throwIfDisposed(),(0,r.X)(this,[this.size])}},67455:(e,t,n)=>{"use strict";var r=n(4968);n(73327).es.prototype.as2D=function(e,t){return this.throwIfDisposed(),(0,r.X)(this,[e,t])}},60480:(e,t,n)=>{"use strict";var r=n(4968);n(73327).es.prototype.as3D=function(e,t,n){return this.throwIfDisposed(),(0,r.X)(this,[e,t,n])}},26094:(e,t,n)=>{"use strict";var r=n(4968);n(73327).es.prototype.as4D=function(e,t,n,s){return this.throwIfDisposed(),(0,r.X)(this,[e,t,n,s])}},29596:(e,t,n)=>{"use strict";var r=n(4968);n(73327).es.prototype.as5D=function(e,t,n,s,o){return this.throwIfDisposed(),(0,r.X)(this,[e,t,n,s,o])}},91215:(e,t,n)=>{"use strict";var r=n(4968),s=n(73327),o=n(59155);s.es.prototype.asScalar=function(){return this.throwIfDisposed(),(0,o.assert)(1===this.size,(()=>"The array must have only 1 element.")),(0,r.X)(this,[])}},21572:(e,t,n)=>{"use strict";var r=n(62271);n(73327).es.prototype.asType=function(e){return this.throwIfDisposed(),(0,r.p)(this,e)}},69133:(e,t,n)=>{"use strict";var r=n(72421);n(73327).es.prototype.asin=function(){return this.throwIfDisposed(),(0,r.Z)(this)}},76656:(e,t,n)=>{"use strict";var r=n(21891);n(73327).es.prototype.asinh=function(){return this.throwIfDisposed(),(0,r.V)(this)}},54520:(e,t,n)=>{"use strict";var r=n(77037);n(73327).es.prototype.atan=function(){return this.throwIfDisposed(),(0,r.z)(this)}},14724:(e,t,n)=>{"use strict";var r=n(29812);n(73327).es.prototype.atan2=function(e){return this.throwIfDisposed(),(0,r.f)(this,e)}},57358:(e,t,n)=>{"use strict";var r=n(80369);n(73327).es.prototype.atanh=function(){return this.throwIfDisposed(),(0,r.C)(this)}},71923:(e,t,n)=>{"use strict";var r=n(15176);n(73327).es.prototype.avgPool=function(e,t,n,s){return this.throwIfDisposed(),(0,r.w)(this,e,t,n,s)}},67702:(e,t,n)=>{"use strict";var r=n(28441);n(73327).es.prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),(0,r.E)(this,e,t)}},42077:(e,t,n)=>{"use strict";var r=n(7399);n(73327).es.prototype.batchNorm=function(e,t,n,s,o){return this.throwIfDisposed(),(0,r.t)(this,e,t,n,s,o)}},93140:(e,t,n)=>{"use strict";var r=n(68247);n(73327).es.prototype.broadcastTo=function(e){return this.throwIfDisposed(),(0,r.U)(this,e)}},91625:(e,t,n)=>{"use strict";var r=n(62271);n(73327).es.prototype.cast=function(e){return this.throwIfDisposed(),(0,r.p)(this,e)}},34864:(e,t,n)=>{"use strict";var r=n(6825);n(73327).es.prototype.ceil=function(){return this.throwIfDisposed(),(0,r.m)(this)}},45242:(e,t,n)=>{"use strict";var r=n(42279);n(73327).es.prototype.clipByValue=function(e,t){return this.throwIfDisposed(),(0,r.i)(this,e,t)}},88035:(e,t,n)=>{"use strict";var r=n(46884),s=n(73327);s.es.prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof s.es&&(e=[e]),(0,r.z)([this,...e],t)}},55135:(e,t,n)=>{"use strict";var r=n(11355);n(73327).es.prototype.conv1d=function(e,t,n,s,o,a){return this.throwIfDisposed(),(0,r.P)(this,e,t,n,s,o,a)}},57145:(e,t,n)=>{"use strict";var r=n(64794);n(73327).es.prototype.conv2d=function(e,t,n,s,o,a){return this.throwIfDisposed(),(0,r.T)(this,e,t,n,s,o,a)}},45977:(e,t,n)=>{"use strict";var r=n(71405);n(73327).es.prototype.conv2dTranspose=function(e,t,n,s,o){return this.throwIfDisposed(),(0,r.b)(this,e,t,n,s,o)}},48540:(e,t,n)=>{"use strict";var r=n(70173);n(73327).es.prototype.cos=function(){return this.throwIfDisposed(),(0,r.m)(this)}},92220:(e,t,n)=>{"use strict";var r=n(2699);n(73327).es.prototype.cosh=function(){return this.throwIfDisposed(),(0,r.f)(this)}},34266:(e,t,n)=>{"use strict";var r=n(37405);n(73327).es.prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),(0,r.z)(this,e,t,n)}},20896:(e,t,n)=>{"use strict";var r=n(89112);n(73327).es.prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),(0,r.n)(this,e,t)}},53018:(e,t,n)=>{"use strict";var r=n(4368),s=n(64718);n(73327).es.prototype.depthwiseConv2D=function(e,t,n,o,a,i){return(0,r.MX)("depthwiseConv2D is deprecated, use depthwiseConv2d instead"),this.throwIfDisposed(),(0,s.B)(this,e,t,n,o,a,i)}},90293:(e,t,n)=>{"use strict";var r=n(64718);n(73327).es.prototype.depthwiseConv2d=function(e,t,n,s,o,a){return this.throwIfDisposed(),(0,r.B)(this,e,t,n,s,o,a)}},22134:(e,t,n)=>{"use strict";var r=n(70557);n(73327).es.prototype.dilation2d=function(e,t,n,s,o){return this.throwIfDisposed(),(0,r.W)(this,e,t,n,s,o)}},2655:(e,t,n)=>{"use strict";var r=n(41274);n(73327).es.prototype.div=function(e){return this.throwIfDisposed(),(0,r.h)(this,e)}},66583:(e,t,n)=>{"use strict";var r=n(49322);n(73327).es.prototype.divNoNan=function(e){return this.throwIfDisposed(),(0,r.N)(this,e)}},14151:(e,t,n)=>{"use strict";var r=n(87536);n(73327).es.prototype.divStrict=function(e){return this.throwIfDisposed(),(0,r.sz)(this,e)}},996:(e,t,n)=>{"use strict";var r=n(30548);n(73327).es.prototype.dot=function(e){return this.throwIfDisposed(),(0,r.A)(this,e)}},67991:(e,t,n)=>{"use strict";var r=n(83233);n(73327).es.prototype.elu=function(){return this.throwIfDisposed(),(0,r.p)(this)}},86041:(e,t,n)=>{"use strict";var r=n(26477);n(73327).es.prototype.equal=function(e){return this.throwIfDisposed(),(0,r.D)(this,e)}},25049:(e,t,n)=>{"use strict";var r=n(43334);n(73327).es.prototype.equalStrict=function(e){return this.throwIfDisposed(),(0,r.zV)(this,e)}},95483:(e,t,n)=>{"use strict";var r=n(34650);n(73327).es.prototype.erf=function(){return this.throwIfDisposed(),(0,r.q)(this)}},60767:(e,t,n)=>{"use strict";var r=n(44842);n(73327).es.prototype.exp=function(){return this.throwIfDisposed(),(0,r.Q)(this)}},87826:(e,t,n)=>{"use strict";var r=n(81300);n(73327).es.prototype.expandDims=function(e){return this.throwIfDisposed(),(0,r.d)(this,e)}},91987:(e,t,n)=>{"use strict";var r=n(53426);n(73327).es.prototype.expm1=function(){return this.throwIfDisposed(),(0,r.t)(this)}},23816:(e,t,n)=>{"use strict";var r=n(7020);n(73327).es.prototype.fft=function(){return this.throwIfDisposed(),(0,r.k)(this)}},17544:(e,t,n)=>{"use strict";var r=n(4968);n(73327).es.prototype.flatten=function(){return this.throwIfDisposed(),(0,r.X)(this,[this.size])}},42562:(e,t,n)=>{"use strict";var r=n(26943);n(73327).es.prototype.floor=function(){return this.throwIfDisposed(),(0,r.G)(this)}},76369:(e,t,n)=>{"use strict";var r=n(9165);n(73327).es.prototype.floorDiv=function(e){return this.throwIfDisposed(),(0,r.q)(this,e)}},17292:(e,t,n)=>{"use strict";var r=n(24926);n(73327).es.prototype.gather=function(e,t){return this.throwIfDisposed(),(0,r.I)(this,e,t)}},51032:(e,t,n)=>{"use strict";var r=n(20636);n(73327).es.prototype.greater=function(e){return this.throwIfDisposed(),(0,r.p)(this,e)}},95746:(e,t,n)=>{"use strict";var r=n(17630);n(73327).es.prototype.greaterEqual=function(e){return this.throwIfDisposed(),(0,r.b)(this,e)}},47313:(e,t,n)=>{"use strict";var r=n(43334);n(73327).es.prototype.greaterEqualStrict=function(e){return this.throwIfDisposed(),(0,r.bZ)(this,e)}},69118:(e,t,n)=>{"use strict";var r=n(43334);n(73327).es.prototype.greaterStrict=function(e){return this.throwIfDisposed(),(0,r.g1)(this,e)}},3170:(e,t,n)=>{"use strict";var r=n(88447);n(73327).es.prototype.ifft=function(){return this.throwIfDisposed(),(0,r.S)(this)}},63871:(e,t,n)=>{"use strict";var r=n(84415);n(73327).es.prototype.irfft=function(){return this.throwIfDisposed(),(0,r.w)(this)}},46139:(e,t,n)=>{"use strict";var r=n(13963);n(73327).es.prototype.isFinite=function(){return this.throwIfDisposed(),(0,r.x)(this)}},91738:(e,t,n)=>{"use strict";var r=n(4365);n(73327).es.prototype.isInf=function(){return this.throwIfDisposed(),(0,r.U)(this)}},97450:(e,t,n)=>{"use strict";var r=n(96230);n(73327).es.prototype.isNaN=function(){return this.throwIfDisposed(),(0,r.i)(this)}},52552:(e,t,n)=>{"use strict";var r=n(99133);n(73327).es.prototype.leakyRelu=function(e){return this.throwIfDisposed(),(0,r.h)(this,e)}},37209:(e,t,n)=>{"use strict";var r=n(86573);n(73327).es.prototype.less=function(e){return this.throwIfDisposed(),(0,r.d)(this,e)}},365:(e,t,n)=>{"use strict";var r=n(50624);n(73327).es.prototype.lessEqual=function(e){return this.throwIfDisposed(),(0,r.z)(this,e)}},66376:(e,t,n)=>{"use strict";var r=n(43334);n(73327).es.prototype.lessEqualStrict=function(e){return this.throwIfDisposed(),(0,r.SF)(this,e)}},10824:(e,t,n)=>{"use strict";var r=n(43334);n(73327).es.prototype.lessStrict=function(e){return this.throwIfDisposed(),(0,r.O_)(this,e)}},6395:(e,t,n)=>{"use strict";var r=n(79648);n(73327).es.prototype.localResponseNormalization=function(e,t,n,s){return this.throwIfDisposed(),(0,r.G)(this,e,t,n,s)}},88663:(e,t,n)=>{"use strict";var r=n(82597);n(73327).es.prototype.log=function(){return this.throwIfDisposed(),(0,r.c)(this)}},23886:(e,t,n)=>{"use strict";var r=n(17474);n(73327).es.prototype.log1p=function(){return this.throwIfDisposed(),(0,r.K)(this)}},43301:(e,t,n)=>{"use strict";var r=n(13888);n(73327).es.prototype.logSigmoid=function(){return this.throwIfDisposed(),(0,r.e)(this)}},8502:(e,t,n)=>{"use strict";var r=n(31510);n(73327).es.prototype.logSoftmax=function(e){return this.throwIfDisposed(),(0,r.C)(this,e)}},86365:(e,t,n)=>{"use strict";var r=n(11391);n(73327).es.prototype.logSumExp=function(e,t){return this.throwIfDisposed(),(0,r.l)(this,e,t)}},95561:(e,t,n)=>{"use strict";var r=n(2856);n(73327).es.prototype.logicalAnd=function(e){return this.throwIfDisposed(),(0,r.H)(this,e)}},7627:(e,t,n)=>{"use strict";var r=n(38651);n(73327).es.prototype.logicalNot=function(){return this.throwIfDisposed(),(0,r.h)(this)}},76806:(e,t,n)=>{"use strict";var r=n(15750);n(73327).es.prototype.logicalOr=function(e){return this.throwIfDisposed(),(0,r.K)(this,e)}},839:(e,t,n)=>{"use strict";var r=n(10596);n(73327).es.prototype.logicalXor=function(e){return this.throwIfDisposed(),(0,r.e)(this,e)}},6815:(e,t,n)=>{"use strict";var r=n(28687);n(73327).es.prototype.matMul=function(e,t,n){return this.throwIfDisposed(),(0,r.O)(this,e,t,n)}},9013:(e,t,n)=>{"use strict";var r=n(83307);n(73327).es.prototype.max=function(e,t){return this.throwIfDisposed(),(0,r.F)(this,e,t)}},20590:(e,t,n)=>{"use strict";var r=n(21174);n(73327).es.prototype.maxPool=function(e,t,n,s){return this.throwIfDisposed(),(0,r._)(this,e,t,n,s)}},90794:(e,t,n)=>{"use strict";var r=n(80632);n(73327).es.prototype.maximum=function(e){return this.throwIfDisposed(),(0,r.g)(this,e)}},80353:(e,t,n)=>{"use strict";var r=n(87536);n(73327).es.prototype.maximumStrict=function(e){return this.throwIfDisposed(),(0,r._j)(this,e)}},68221:(e,t,n)=>{"use strict";var r=n(75130);n(73327).es.prototype.mean=function(e,t){return this.throwIfDisposed(),(0,r.J)(this,e,t)}},2216:(e,t,n)=>{"use strict";var r=n(25735);n(73327).es.prototype.min=function(e,t){return this.throwIfDisposed(),(0,r.V)(this,e,t)}},23958:(e,t,n)=>{"use strict";var r=n(24513);n(73327).es.prototype.minimum=function(e){return this.throwIfDisposed(),(0,r.L)(this,e)}},91466:(e,t,n)=>{"use strict";var r=n(87536);n(73327).es.prototype.minimumStrict=function(e){return this.throwIfDisposed(),(0,r.Wz)(this,e)}},42102:(e,t,n)=>{"use strict";var r=n(85228);n(73327).es.prototype.mod=function(e){return this.throwIfDisposed(),(0,r.w)(this,e)}},78340:(e,t,n)=>{"use strict";var r=n(87536);n(73327).es.prototype.modStrict=function(e){return this.throwIfDisposed(),(0,r.Ir)(this,e)}},64695:(e,t,n)=>{"use strict";var r=n(24841);n(73327).es.prototype.mul=function(e){return this.throwIfDisposed(),(0,r.d)(this,e)}},2742:(e,t,n)=>{"use strict";var r=n(87536);n(73327).es.prototype.mulStrict=function(e){return this.throwIfDisposed(),(0,r.NT)(this,e)}},32571:(e,t,n)=>{"use strict";var r=n(17370);n(73327).es.prototype.neg=function(){return this.throwIfDisposed(),(0,r.W)(this)}},17744:(e,t,n)=>{"use strict";var r=n(3561);n(73327).es.prototype.norm=function(e,t,n){return this.throwIfDisposed(),(0,r.K)(this,e,t,n)}},11684:(e,t,n)=>{"use strict";var r=n(16500);n(73327).es.prototype.notEqual=function(e){return this.throwIfDisposed(),(0,r.Q)(this,e)}},46234:(e,t,n)=>{"use strict";var r=n(43334);n(73327).es.prototype.notEqualStrict=function(e){return this.throwIfDisposed(),(0,r.FG)(this,e)}},89825:(e,t,n)=>{"use strict";var r=n(76708);n(73327).es.prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),(0,r.l)(this,e,t,n)}},70188:(e,t,n)=>{"use strict";var r=n(7846);n(73327).es.prototype.onesLike=function(){return this.throwIfDisposed(),(0,r.J)(this)}},29709:(e,t,n)=>{"use strict";var r=n(39682);n(73327).es.prototype.pad=function(e,t){return this.throwIfDisposed(),(0,r.v)(this,e,t)}},32845:(e,t,n)=>{"use strict";var r=n(85860);n(73327).es.prototype.pool=function(e,t,n,s,o){return this.throwIfDisposed(),(0,r.d)(this,e,t,n,s,o)}},19739:(e,t,n)=>{"use strict";var r=n(33453);n(73327).es.prototype.pow=function(e){return this.throwIfDisposed(),(0,r.s)(this,e)}},60700:(e,t,n)=>{"use strict";var r=n(87536);n(73327).es.prototype.powStrict=function(e){return this.throwIfDisposed(),(0,r.Lf)(this,e)}},89760:(e,t,n)=>{"use strict";var r=n(98151);n(73327).es.prototype.prelu=function(e){return this.throwIfDisposed(),(0,r.A)(this,e)}},91643:(e,t,n)=>{"use strict";var r=n(49451);n(73327).es.prototype.prod=function(e,t){return this.throwIfDisposed(),(0,r.W)(this,e,t)}},21101:(e,t,n)=>{"use strict";var r=n(19036);n(73327).es.prototype.reciprocal=function(){return this.throwIfDisposed(),(0,r.M)(this)}},64642:(e,t,n)=>{"use strict";n(84941),n(88154),n(46885),n(67049),n(54878),n(98824),n(74342),n(21981),n(53196),n(91215),n(21572),n(99007),n(67455),n(60480),n(26094),n(29596),n(69133),n(76656),n(54520),n(14724),n(57358),n(71923),n(67702),n(42077),n(93140),n(91625),n(34864),n(45242),n(88035),n(55135),n(45977),n(57145),n(48540),n(92220),n(34266),n(20896),n(53018),n(90293),n(22134),n(66583),n(14151),n(2655),n(996),n(67991),n(25049),n(86041),n(95483),n(60767),n(87826),n(91987),n(23816),n(17544),n(42562),n(76369),n(17292),n(47313),n(95746),n(69118),n(51032),n(3170),n(63871),n(46139),n(91738),n(97450),n(52552),n(66376),n(365),n(10824),n(37209),n(6395),n(43301),n(8502),n(86365),n(88663),n(23886),n(95561),n(7627),n(76806),n(839),n(6815),n(20590),n(9013),n(80353),n(90794),n(68221),n(2216),n(91466),n(23958),n(78340),n(42102),n(2742),n(64695),n(32571),n(17744),n(46234),n(11684),n(89825),n(70188),n(29709),n(32845),n(60700),n(19739),n(89760),n(91643),n(21101),n(81870),n(57079),n(54018),n(45599),n(60652),n(99577),n(80059),n(5589),n(57876),n(16638),n(15048),n(48925),n(26001),n(49999),n(49460),n(87841),n(36038),n(46677),n(95940),n(86894),n(98671),n(59683),n(55947),n(32184),n(51534),n(36872),n(22149),n(95105),n(10995),n(37657),n(71262),n(58123),n(84519),n(14890),n(78601),n(78092),n(44012),n(76709),n(33324),n(97617),n(49351),n(71535),n(87222),n(12310),n(30765)},81870:(e,t,n)=>{"use strict";var r=n(7409);n(73327).es.prototype.relu=function(){return this.throwIfDisposed(),(0,r.U)(this)}},57079:(e,t,n)=>{"use strict";var r=n(83582);n(73327).es.prototype.relu6=function(){return this.throwIfDisposed(),(0,r.b)(this)}},45599:(e,t,n)=>{"use strict";var r=n(4968);n(73327).es.prototype.reshape=function(e){return this.throwIfDisposed(),(0,r.X)(this,e)}},54018:(e,t,n)=>{"use strict";var r=n(4968);n(73327).es.prototype.reshapeAs=function(e){return this.throwIfDisposed(),(0,r.X)(this,e.shape)}},60652:(e,t,n)=>{"use strict";var r=n(13305);n(73327).es.prototype.resizeBilinear=function(e,t){return this.throwIfDisposed(),(0,r.I)(this,e,t)}},99577:(e,t,n)=>{"use strict";var r=n(95098);n(73327).es.prototype.resizeNearestNeighbor=function(e,t){return this.throwIfDisposed(),(0,r.j)(this,e,t)}},80059:(e,t,n)=>{"use strict";var r=n(57486);n(73327).es.prototype.reverse=function(e){return this.throwIfDisposed(),(0,r.G)(this,e)}},5589:(e,t,n)=>{"use strict";var r=n(13710);n(73327).es.prototype.rfft=function(){return this.throwIfDisposed(),(0,r.Q)(this)}},57876:(e,t,n)=>{"use strict";var r=n(97809);n(73327).es.prototype.round=function(){return this.throwIfDisposed(),(0,r.N)(this)}},16638:(e,t,n)=>{"use strict";var r=n(32634);n(73327).es.prototype.rsqrt=function(){return this.throwIfDisposed(),(0,r.b)(this)}},15048:(e,t,n)=>{"use strict";var r=n(55503);n(73327).es.prototype.selu=function(){return this.throwIfDisposed(),(0,r.U)(this)}},48925:(e,t,n)=>{"use strict";var r=n(68678);n(73327).es.prototype.separableConv2d=function(e,t,n,s,o,a){return this.throwIfDisposed(),(0,r.U)(this,e,t,n,s,o,a)}},26001:(e,t,n)=>{"use strict";var r=n(30625);n(73327).es.prototype.sigmoid=function(){return this.throwIfDisposed(),(0,r.X)(this)}},49999:(e,t,n)=>{"use strict";var r=n(34434);n(73327).es.prototype.sign=function(){return this.throwIfDisposed(),(0,r.X)(this)}},49460:(e,t,n)=>{"use strict";var r=n(99331);n(73327).es.prototype.sin=function(){return this.throwIfDisposed(),(0,r.O)(this)}},87841:(e,t,n)=>{"use strict";var r=n(83254);n(73327).es.prototype.sinh=function(){return this.throwIfDisposed(),(0,r.R)(this)}},36038:(e,t,n)=>{"use strict";var r=n(22676);n(73327).es.prototype.slice=function(e,t){return this.throwIfDisposed(),(0,r.t)(this,e,t)}},46677:(e,t,n)=>{"use strict";var r=n(80682);n(73327).es.prototype.softmax=function(e){return this.throwIfDisposed(),(0,r.X)(this,e)}},95940:(e,t,n)=>{"use strict";var r=n(3694);n(73327).es.prototype.softplus=function(){return this.throwIfDisposed(),(0,r.W)(this)}},86894:(e,t,n)=>{"use strict";var r=n(27918);n(73327).es.prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),(0,r.f)(this,e,t)}},98671:(e,t,n)=>{"use strict";var r=n(28644);n(73327).es.prototype.split=function(e,t){return this.throwIfDisposed(),(0,r.V)(this,e,t)}},59683:(e,t,n)=>{"use strict";var r=n(13261);n(73327).es.prototype.sqrt=function(){return this.throwIfDisposed(),(0,r._)(this)}},55947:(e,t,n)=>{"use strict";var r=n(50248);n(73327).es.prototype.square=function(){return this.throwIfDisposed(),(0,r.h)(this)}},32184:(e,t,n)=>{"use strict";var r=n(15265);n(73327).es.prototype.squaredDifference=function(e){return this.throwIfDisposed(),(0,r.$)(this,e)}},51534:(e,t,n)=>{"use strict";var r=n(87536);n(73327).es.prototype.squaredDifferenceStrict=function(e){return this.throwIfDisposed(),(0,r.r7)(this,e)}},36872:(e,t,n)=>{"use strict";var r=n(79590);n(73327).es.prototype.squeeze=function(e){return this.throwIfDisposed(),(0,r.L)(this,e)}},22149:(e,t,n)=>{"use strict";var r=n(82991),s=n(73327);s.es.prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof s.es?[this,e]:[this,...e];return(0,r.k)(n,t)}},95105:(e,t,n)=>{"use strict";var r=n(71901);n(73327).es.prototype.step=function(e){return this.throwIfDisposed(),(0,r.N)(this,e)}},10995:(e,t,n)=>{"use strict";var r=n(55158);n(73327).es.prototype.stridedSlice=function(e,t,n,s,o,a,i,u){return this.throwIfDisposed(),(0,r.N)(this,e,t,n,s,o,a,i,u)}},71262:(e,t,n)=>{"use strict";var r=n(70827);n(73327).es.prototype.sub=function(e){return this.throwIfDisposed(),(0,r.l)(this,e)}},37657:(e,t,n)=>{"use strict";var r=n(87536);n(73327).es.prototype.subStrict=function(e){return this.throwIfDisposed(),(0,r.UL)(this,e)}},58123:(e,t,n)=>{"use strict";var r=n(15475);n(73327).es.prototype.sum=function(e,t){return this.throwIfDisposed(),(0,r.S)(this,e,t)}},84519:(e,t,n)=>{"use strict";var r=n(61173);n(73327).es.prototype.tan=function(){return this.throwIfDisposed(),(0,r.O)(this)}},14890:(e,t,n)=>{"use strict";var r=n(21869);n(73327).es.prototype.tanh=function(){return this.throwIfDisposed(),(0,r.A)(this)}},78601:(e,t,n)=>{"use strict";var r=n(47501);n(73327).es.prototype.tile=function(e){return this.throwIfDisposed(),(0,r.G)(this,e)}},78092:(e,t,n)=>{"use strict";var r=n(62271);n(73327).es.prototype.toBool=function(){return this.throwIfDisposed(),(0,r.p)(this,"bool")}},44012:(e,t,n)=>{"use strict";var r=n(62271);n(73327).es.prototype.toFloat=function(){return this.throwIfDisposed(),(0,r.p)(this,"float32")}},76709:(e,t,n)=>{"use strict";var r=n(62271);n(73327).es.prototype.toInt=function(){return this.throwIfDisposed(),(0,r.p)(this,"int32")}},33324:(e,t,n)=>{"use strict";var r=n(43243);n(73327).es.prototype.topk=function(e,t){return this.throwIfDisposed(),(0,r.h)(this,e,t)}},97617:(e,t,n)=>{"use strict";var r=n(89065);n(73327).es.prototype.transpose=function(e){return this.throwIfDisposed(),(0,r.p)(this,e)}},49351:(e,t,n)=>{"use strict";var r=n(49608);n(73327).es.prototype.unique=function(e){return this.throwIfDisposed(),(0,r.T)(this,e)}},71535:(e,t,n)=>{"use strict";var r=n(98749);n(73327).es.prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),(0,r.p)(this,e,t)}},87222:(e,t,n)=>{"use strict";var r=n(24136);n(73327).es.prototype.unstack=function(e){return this.throwIfDisposed(),(0,r.H)(this,e)}},12310:(e,t,n)=>{"use strict";var r=n(95912);n(73327).es.prototype.where=function(e,t){return this.throwIfDisposed(),(0,r.a)(e,this,t)}},30765:(e,t,n)=>{"use strict";var r=n(6577);n(73327).es.prototype.zerosLike=function(){return this.throwIfDisposed(),(0,r.P)(this)}},88940:(e,t,n)=>{"use strict";var r=n(32259),s=n(35589),o=n(10629),a=n(18707),i=n(42724),u=n(64017),l=n(67851),c=n(20080),d=n(11669),h=n(55535),p=n(23755),f=n(87242),m=n(92153),g=n(24254),x=n(9742),v=n(3477),b=n(27914),y=n(42680),w=n(49467),k=n(57777),I=n(54565),C=n(45396),$=n(9920),S=n(77355),R=n(77528),E=n(61763),T=n(12090),A=n(303),_=n(62207),N=n(45449),F=n(29479),D=n(82221),B=n(15833),O=n(72087),M=n(30782),P=n(18284),L=n(38905),V=n(66568),W=n(3258),z=n(91603),U=n(13079),H=n(8474),G=n(48971),X=n(74937),q=n(72486),K=n(7759),j=n(54488),Y=n(62850),Q=n(25241),J=n(7400),Z=n(32282),ee=n(22735),te=n(50629),ne=n(74812),re=n(75508),se=n(8899),oe=n(30154),ae=n(63668),ie=n(99),ue=n(45370),le=n(96587),ce=n(60006),de=n(76179),he=n(15938),pe=n(15997),fe=n(55253),me=n(84998),ge=n(95906),xe=n(30027),ve=n(37699),be=n(47738),ye=n(82606),we=n(45777),ke=n(80125),Ie=n(94936),Ce=n(77145),$e=n(22154),Se=n(82232),Re=n(71372),Ee=n(18558),Te=n(32439),Ae=n(30595),_e=n(40521),Ne=n(79719),Fe=n(81554),De=n(9460),Be=n(14574),Oe=n(83933),Me=n(47320),Pe=n(272),Le=n(22625),Ve=n(23489),We=n(52679),ze=n(51466),Ue=n(26151);const He=[r.Q,s.K,o.M,a.m,i.C,u.C,l.Q,c.V,d.f,h.H,p.A,f.q,m.Y,g.v,x.C,v.s,b.O,y.D,w.t,k.v,I.x,$.F,C.S,S.w,R.L,E.a,T.g,A.v,_.T,N.Z,F.q,D.j,B.K,O.g,P.T,M.G,L.c,V.t,W.i,z.w,U.Y,H.i,G.W,X.P,q.X,K.K,j.e,Y.J,Y.J,Q.R,J.J,Z.f,ee.j,te.c,ne.E,re.q,se.$,oe.p,ae.N,ie.G,ie.G,ue.i,le.d,ce.a,de.d,he.T,pe.H,fe.G,me.S,ge.T,xe.O,ve.C,be.B,ye.W,we.E,ke.Q,Ie._,Ce.m,$e.M,Se.J,Re.H,Ee.a,Ee.a,Te.n,Te.n,Ae.C,Ne.k,_e.t,Fe.l,De.h,Be.y,Oe.w,Me.W,Pe.x,Le.j,Ve.T,We.x,ze.a];for(const e of He)(0,Ue.Li)(e)},50223:(e,t,n)=>{"use strict";n.d(t,{C:()=>s,_:()=>o});var r=n(59155);function s(e,t,n){const r={},s={};for(let e=0;e<t.length;e++)r[t[e].id]=!0;for(let n=0;n<e.length;n++){const o=e[n],a=o.inputs;for(const e in a){const n=a[e];let i=!1;for(let e=0;e<t.length;e++)if(r[n.id]){o.outputs.forEach((e=>r[e.id]=!0)),i=!0,s[o.id]=!0;break}if(i)break}}const o={};o[n.id]=!0;const a={};for(let t=e.length-1;t>=0;t--){const n=e[t],r=n.inputs;for(let e=0;e<n.outputs.length;e++)if(o[n.outputs[e].id]){for(const e in r)o[r[e].id]=!0,a[n.id]=!0;break}}const i=[];for(let t=0;t<e.length;t++){const n=e[t];if(s[n.id]&&a[n.id]){const e={};for(const t in n.inputs){const s=n.inputs[t];r[s.id]&&(e[t]=s)}const t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,i.push(t)}}return i}function o(e,t,n,s){for(let o=t.length-1;o>=0;o--){const a=t[o],i=[];if(a.outputs.forEach((t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)})),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const u=a.gradient(i);for(const t in a.inputs){if(!(t in u))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(u)}.`);const o=n((()=>u[t]()));if("float32"!==o.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${o.dtype}'`);const i=a.inputs[t];if(!r.arraysEqual(o.shape,i.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${o.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=o;else{const t=e[i.id];e[i.id]=s(t,o),t.dispose()}}}}},73327:(e,t,n)=>{"use strict";n.d(t,{YD:()=>o,Vi:()=>l,Vp:()=>c,FZ:()=>d,es:()=>h,_w:()=>p});var r=n(62488),s=n(59155);class o{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=s.sizeFromShape(e),null!=n){const e=n.length;s.assert(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||s.getArrayFromDType(t,this.size),this.strides=(0,s.computeStrides)(e)}set(e,...t){0===t.length&&(t=[0]),s.assert(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const n of e){if(n<0||n>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=`+this.shape;throw new Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return a().makeTensor(this.values,this.shape,this.dtype)}}let a=null,i=null,u=null;function l(e){a=e}function c(e){i=e}function d(e){u=e}class h{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=s.sizeFromShape(e),this.strides=(0,s.computeStrides)(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return i.buffer(this.shape,this.dtype,e)}bufferSync(){return i.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return(0,s.toNestedArray)(this.shape,e)}arraySync(){return(0,s.toNestedArray)(this.shape,this.dataSync())}async data(){this.throwIfDisposed();const e=a().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map((e=>s.decodeString(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataSync(){this.throwIfDisposed();const e=a().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>s.decodeString(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await a().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(a().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return i.print(this,e)}clone(){return this.throwIfDisposed(),i.clone(this)}toString(e=!1){const t=this.dataSync();return(0,r.H)(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),i.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),a().makeVariable(this,e,t,n)}}Object.defineProperty(h,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed});class p extends h{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!s.arraysEqual(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);a().disposeTensor(this),this.dataId=e.dataId,a().incRef(this,null)}dispose(){a().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(p,Symbol.hasInstance,{value:e=>e instanceof h&&null!=e.assign&&e.assign instanceof Function})},62488:(e,t,n)=>{"use strict";n.d(t,{H:()=>s});var r=n(59155);function s(e,t,n,s){const a=(0,r.computeStrides)(t),l=function(e,t,n,s){const a=(0,r.sizeFromShape)(t),i=s[s.length-1],l=new Array(i).fill(0),c=t.length,d="complex64"===n?u(e):e;if(c>1)for(let e=0;e<a/i;e++){const t=e*i;for(let e=0;e<i;e++)l[e]=Math.max(l[e],o(d[t+e],0,n).length)}return l}(e,t,n,a),c=t.length,d=i(e,t,n,a,l),h=["Tensor"];return s&&(h.push("  dtype: "+n),h.push("  rank: "+c),h.push(`  shape: [${t}]`),h.push("  values:")),h.push(d.map((e=>"    "+e)).join("\n")),h.join("\n")}function o(e,t,n){let s;return s=Array.isArray(e)?parseFloat(e[0].toFixed(7))+" + "+parseFloat(e[1].toFixed(7))+"j":(0,r.isString)(e)?`'${e}'`:"bool"===n?a(e):parseFloat(e.toFixed(7)).toString(),(0,r.rightPad)(s,t)}function a(e){return 0===e?"false":"true"}function i(e,t,n,r,s,l=!0){const c="complex64"===n?2:1,d=t[0],h=t.length;if(0===h)return"complex64"===n?[o(u(e)[0],0,n)]:"bool"===n?[a(e[0])]:[e[0].toString()];if(1===h){if(d>20){const t=3*c;let r=Array.from(e.slice(0,t)),a=Array.from(e.slice((d-3)*c,d*c));return"complex64"===n&&(r=u(r),a=u(a)),["["+r.map(((e,t)=>o(e,s[t],n))).join(", ")+", ..., "+a.map(((e,t)=>o(e,s[d-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?u(e):Array.from(e)).map(((e,t)=>o(e,s[t],n))).join(", ")+"]"]}const p=t.slice(1),f=r.slice(1),m=r[0]*c,g=[];if(d>20){for(let t=0;t<3;t++){const r=t*m,o=r+m;g.push(...i(e.slice(r,o),p,n,f,s,!1))}g.push("...");for(let t=d-3;t<d;t++){const r=t*m,o=r+m;g.push(...i(e.slice(r,o),p,n,f,s,t===d-1))}}else for(let t=0;t<d;t++){const r=t*m,o=r+m;g.push(...i(e.slice(r,o),p,n,f,s,t===d-1))}const x=2===h?",":"";g[0]="["+g[0]+x;for(let e=1;e<g.length-1;e++)g[e]=" "+g[e]+x;let v=",\n";for(let e=2;e<h;e++)v+="\n";return g[g.length-1]=" "+g[g.length-1]+"]"+(l?"":v),g}function u(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}},80747:(e,t,n)=>{"use strict";n.d(t,{makeTypesMatch:()=>o,getTensorsInContainer:()=>a});var r=n(73327),s=n(71221);function o(e,t){if(e.dtype===t.dtype)return[e,t];const n=(0,s.x8)(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function a(e){const t=[];return i(e,t,new Set),t}function i(e,t,n){if(null==e)return;if(e instanceof r.es)return void t.push(e);if(s=e,!Array.isArray(s)&&"object"!=typeof s)return;var s;const o=e;for(const e in o){const r=o[e];n.has(r)||(n.add(r),i(r,t,n))}}},43740:(e,t,n)=>{"use strict";n.d(t,{C:()=>i,_1:()=>c,sI:()=>d});var r=n(23926),s=n(22885),o=n(73327),a=n(59155);function i(e,t){let n=e;if((0,a.isTypedArray)(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||(0,a.isTypedArray)(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&(0,s.OB)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&u(e,r,[]),r}function u(e,t,n){if(n=n||[],!Array.isArray(e)&&!(0,a.isTypedArray)(e))return void(0,a.assert)(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));(0,a.assert)(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),(0,a.assert)(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let t=0;t<e.length;++t)u(e[t],r,n.concat(t))}function l(e,t,n,r){if(null!=e&&("numeric"!==e&&e!==t||"numeric"===e&&"string"===t))throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}function c(e,t,n,s="numeric"){if(e instanceof o.es)return l(s,e.dtype,t,n),e;let u=(0,a.inferDtype)(e);if("string"!==u&&["bool","int32","float32"].indexOf(s)>=0&&(u=s),l(s,u,t,n),null==e||!(0,a.isTypedArray)(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const c=i(e,u);(0,a.isTypedArray)(e)||Array.isArray(e)||(e=[e]);const d="string"!==u?(0,a.toTypedArray)(e,u):(0,a.flatten)(e,[],!0);return r.BV.makeTensor(d,c,u)}function d(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,r)=>c(e,`${t}[${r}]`,n)),r)}},71221:(e,t,n)=>{"use strict";var r,s,o,a,i;n.d(t,{x8:()=>l,z4:()=>c}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(r||(r={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(s||(s={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(o||(o={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(a||(a={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(i||(i={}));const u={float32:a,int32:s,bool:o,complex64:i};function l(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return u[e][t]}function c(e){return l(e,"int32")}},59155:(e,t,n)=>{"use strict";n.d(t,{clamp:()=>s,nearestLargerEven:()=>o,sum:()=>a,assert:()=>i,assertShapesMatch:()=>u,assertNonNull:()=>l,flatten:()=>c,sizeFromShape:()=>d,arraysEqual:()=>h,isInt:()=>p,sizeToSquarishShape:()=>f,rightPad:()=>m,repeatedTry:()=>g,inferFromImplicitShape:()=>x,parseAxisParam:()=>v,squeezeShape:()=>b,getTypedArrayFromDType:()=>y,getArrayFromDType:()=>w,isValidDtype:()=>k,hasEncodingLoss:()=>I,isTypedArray:()=>C,bytesPerElement:()=>$,bytesFromStringArray:()=>S,isString:()=>R,inferDtype:()=>E,isFunction:()=>T,nearestDivisor:()=>A,computeStrides:()=>_,createScalarValue:()=>N,toTypedArray:()=>F,toNestedArray:()=>B,makeOnesTypedArray:()=>O,makeZerosTypedArray:()=>M,makeZerosNestedTypedArray:()=>P,now:()=>L,assertNonNegativeIntegerDimensions:()=>V,encodeString:()=>W,decodeString:()=>z,locToIndex:()=>U,indexToLoc:()=>H});var r=n(22885);function s(e,t,n){return Math.max(e,Math.min(t,n))}function o(e){return e%2==0?e:e+1}function a(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function i(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function u(e,t,n=""){i(h(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function l(e){i(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function c(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||C(e)&&!n)for(let r=0;r<e.length;++r)c(e[r],t,n);else t.push(e);return t}function d(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function h(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function p(e){return e%1==0}function f(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function m(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function g(e,t=(e=>0),n){return new Promise(((r,s)=>{let o=0;const a=()=>{if(e())return void r();o++;const i=t(o);null!=n&&o>=n?s():setTimeout(a,i)};a()}))}function x(e,t){let n=1,r=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${t}`);r=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}function v(e,t){const n=t.length;return i((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis `+e)),i(e.every((e=>p(e))),(()=>"All values in axis param must be integers but got axis "+e)),e.map((e=>e<0?n+e:e))}function b(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,o=null==t||s?null:v(t,e).sort();let a=0;for(let t=0;t<e.length;++t){if(null!=o){if(o[a]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==o[a]||o[a]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),o[a]<=t&&a++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function y(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error("Unknown data type "+e);n=new Uint8Array(t)}return n}function w(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error("Unknown data type "+e);n=new Array(t)}return n}function k(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function I(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function C(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array}function $(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error("Unknown dtype "+e)}function S(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function R(e){return"string"==typeof e||e instanceof String}function E(e){return Array.isArray(e)?E(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array?"int32":"number"==typeof e?"float32":R(e)?"string":"boolean"==typeof e?"bool":"float32"}function T(e){return!!(e&&e.constructor&&e.call&&e.apply)}function A(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function _(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function N(e,t){return"string"===t?W(e):F([e],t)}function F(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=c(e)),(0,r.OB)().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error("Unknown data type "+t)}function D(e,t,n){const r=new Array;if(1===t.length){const s=t[0];for(let t=0;t<s;t++)r[t]=n[e+t]}else{const s=t[0],o=t.slice(1),a=o.reduce(((e,t)=>e*t));for(let t=0;t<s;t++)r[t]=D(e+t*a,o,n)}return r}function B(e,t){if(0===e.length)return t[0];const n=e.reduce(((e,t)=>e*t));if(0===n)return[];if(n!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}.`);return D(0,e,t)}function O(e,t){const n=M(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function M(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error("Unknown data type "+t)}function P(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return B(e,new Float32Array(n));if("int32"===t)return B(e,new Int32Array(n));if("bool"===t)return B(e,new Uint8Array(n));throw new Error("Unknown data type "+t)}function L(){return(0,r.OB)().platform.now()}function V(e){e.forEach((t=>{i(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function W(e,t="utf-8"){return t=t||"utf-8",(0,r.OB)().platform.encode(e,t)}function z(e,t="utf-8"){return t=t||"utf-8",(0,r.OB)().platform.decode(e,t)}function U(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=n[t]*e[t];return r}function H(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let t=0;t<r.length-1;++t)r[t]=Math.floor(e/n[t]),e-=r[t]*n[t];return r[r.length-1]=e,r}},36377:(e,t,n)=>{var r=n(84832),s=n(68652),o=n(90801),a=n(92030),i=n(3618),u=n(89049),l=n(51971);l.alea=r,l.xor128=s,l.xorwow=o,l.xorshift7=a,l.xor4096=i,l.tychei=u,e.exports=l},84832:function(e,t,n){var r;!function(e,s,o){function a(e){var t,n=this,r=(t=4022871197,function(e){e=e.toString();for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function u(e,t){var n=new a(e),r=t&&t.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=function(){return u}.call(t,n,t,s))||(s.exports=r):this.alea=u}(0,e=n.nmd(e),n.amdD)},89049:function(e,t,n){var r;!function(e,s,o){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,s=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^s,t.a=s-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function u(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=function(){return u}.call(t,n,t,s))||(s.exports=r):this.tychei=u}(0,e=n.nmd(e),n.amdD)},68652:function(e,t,n){var r;!function(e,s,o){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function u(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=function(){return u}.call(t,n,t,s))||(s.exports=r):this.xor128=u}(0,e=n.nmd(e),n.amdD)},3618:function(e,t,n){var r;!function(e,s,o){function a(e){var t=this;t.next=function(){var e,n,r=t.w,s=t.X,o=t.i;return t.w=r=r+1640531527|0,n=s[o+34&127],e=s[o=o+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=s[o]=n^e,t.i=o,n+(r^r>>>16)|0},function(e,t){var n,r,s,o,a,i=[],u=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,u=Math.max(u,t.length)),s=0,o=-32;o<u;++o)t&&(r^=t.charCodeAt((o+32)%t.length)),0===o&&(a=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,o>=0&&(a=a+1640531527|0,s=0==(n=i[127&o]^=r+a)?s+1:0);for(s>=128&&(i[127&(t&&t.length||0)]=-1),s=127,o=512;o>0;--o)r=i[s+34&127],n=i[s=s+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,i[s]=r^n;e.w=a,e.X=i,e.i=s}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function u(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.X&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=function(){return u}.call(t,n,t,s))||(s.exports=r):this.xor4096=u}(0,e=n.nmd(e),n.amdD)},92030:function(e,t,n){var r;!function(e,s,o){function a(e){var t=this;t.next=function(){var e,n,r=t.x,s=t.i;return e=r[s],n=(e^=e>>>7)^e<<24,n^=(e=r[s+1&7])^e>>>10,n^=(e=r[s+3&7])^e>>>3,n^=(e=r[s+4&7])^e<<7,e=r[s+7&7],n^=(e^=e<<13)^e<<9,r[s]=n,t.i=s+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function u(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.x&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=function(){return u}.call(t,n,t,s))||(s.exports=r):this.xorshift7=u}(0,e=n.nmd(e),n.amdD)},90801:function(e,t,n){var r;!function(e,s,o){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function u(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=function(){return u}.call(t,n,t,s))||(s.exports=r):this.xorwow=u}(0,e=n.nmd(e),n.amdD)},51971:(e,t,n)=>{var r;!function(s,o){var a,i=this,u=256,l=o.pow(u,6),c=o.pow(2,52),d=2*c,h=255;function p(e,t,n){var r=[],h=x(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,v(s)]:null==e?function(){try{var e;return a&&(e=a.randomBytes)?e=e(u):(e=new Uint8Array(u),(i.crypto||i.msCrypto).getRandomValues(e)),v(e)}catch(e){var t=i.navigator,n=t&&t.plugins;return[+new Date,i,n,i.screen,v(s)]}}():e,3),r),p=new f(r),b=function(){for(var e=p.g(6),t=l,n=0;e<c;)e=(e+n)*u,t*=u,n=p.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return b.int32=function(){return 0|p.g(4)},b.quick=function(){return p.g(4)/4294967296},b.double=b,x(v(p.S),s),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(o.random=e,t):e})(b,h,"global"in t?t.global:this==o,t.state)}function f(e){var t,n=e.length,r=this,s=0,o=r.i=r.j=0,a=r.S=[];for(n||(e=[n++]);s<u;)a[s]=s++;for(s=0;s<u;s++)a[s]=a[o=h&o+e[s%n]+(t=a[s])],a[o]=t;(r.g=function(e){for(var t,n=0,s=r.i,o=r.j,a=r.S;e--;)t=a[s=h&s+1],n=n*u+a[h&(a[s]=a[o=h&o+t])+(a[o]=t)];return r.i=s,r.j=o,n})(u)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],s=typeof e;if(t&&"object"==s)for(n in e)try{r.push(g(e[n],t-1))}catch(e){}return r.length?r:"string"==s?e:e+"\0"}function x(e,t){for(var n,r=e+"",s=0;s<r.length;)t[h&s]=h&(n^=19*t[h&s])+r.charCodeAt(s++);return v(t)}function v(e){return String.fromCharCode.apply(0,e)}if(o.seedrandom=p,x(o.random(),s),e.exports){e.exports=p;try{a=n(63906)}catch(e){}}else void 0===(r=function(){return p}.call(t,n,t,e))||(e.exports=r)}([],Math)},63906:()=>{},78352:()=>{},61758:()=>{}},t={};function n(r){if(t[r])return t[r].exports;var s=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(s.exports,s,s.exports,n),s.loaded=!0,s.exports}n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),n(27710),n(33935)})();